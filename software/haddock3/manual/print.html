<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Haddock3 User Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro_manual.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="haddocking.html"><strong aria-hidden="true">1.1.</strong> HADDOCK - High Ambiguity Docking</a></li><li class="chapter-item expanded "><a href="haddock3.html"><strong aria-hidden="true">1.2.</strong> Haddock3 modularity</a></li></ol></li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="virtual-environments.html"><strong aria-hidden="true">2.1.</strong> Virtual environments (conda / venv)</a></li><li class="chapter-item expanded "><a href="download-haddock3.html"><strong aria-hidden="true">2.2.</strong> Obtaining HADDOCK</a></li><li class="chapter-item expanded "><a href="install-cns.html"><strong aria-hidden="true">2.3.</strong> CNS</a></li></ol></li><li class="chapter-item expanded "><a href="clis.html"><strong aria-hidden="true">3.</strong> Command Line Interfaces</a></li><li class="chapter-item expanded "><a href="structure_requirements.html"><strong aria-hidden="true">4.</strong> Preparing input files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="structure_requirements.html"><strong aria-hidden="true">4.1.</strong> Haddock3 requirements</a></li><li class="chapter-item expanded "><a href="pdbtools.html"><strong aria-hidden="true">4.2.</strong> Tools to manipulate structures</a></li></ol></li><li class="chapter-item expanded "><a href="intro_restraints.html"><strong aria-hidden="true">5.</strong> Generating restraints for HADDOCK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="restraints_cli.html"><strong aria-hidden="true">5.1.</strong> haddock3-restraints</a></li><li class="chapter-item expanded "><a href="symmetry_restraints.html"><strong aria-hidden="true">5.2.</strong> Symmetry restraints</a></li><li class="chapter-item expanded "><a href="abinitio_docking.html"><strong aria-hidden="true">5.3.</strong> Ab-initio docking mode</a></li><li class="chapter-item expanded "><a href="flexibility.html"><strong aria-hidden="true">5.4.</strong> Flexibility</a></li></ol></li><li class="chapter-item expanded "><a href="config_file.html"><strong aria-hidden="true">6.</strong> Generating a docking protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="global_parameters.html"><strong aria-hidden="true">6.1.</strong> Global parameters</a></li><li class="chapter-item expanded "><a href="modules_parameters.html"><strong aria-hidden="true">6.2.</strong> Concept of modules / parameters</a></li><li class="chapter-item expanded "><a href="important_parameters.html"><strong aria-hidden="true">6.3.</strong> Notable parameters</a></li></ol></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">7.</strong> Available modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules/topology.html"><strong aria-hidden="true">7.1.</strong> Topology</a></li><li class="chapter-item expanded "><a href="modules/sampling.html"><strong aria-hidden="true">7.2.</strong> Sampling</a></li><li class="chapter-item expanded "><a href="modules/refinement.html"><strong aria-hidden="true">7.3.</strong> Refinement</a></li><li class="chapter-item expanded "><a href="modules/scoring.html"><strong aria-hidden="true">7.4.</strong> Scoring</a></li><li class="chapter-item expanded "><a href="modules/analysis.html"><strong aria-hidden="true">7.5.</strong> Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="docking_scenarios.html"><strong aria-hidden="true">8.</strong> Docking scenarios</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docking_scenarios.html"><strong aria-hidden="true">8.1.</strong> protein-protein docking</a></li><li class="chapter-item expanded "><a href="docking_scenarios.html"><strong aria-hidden="true">8.2.</strong> antibody-antigen docking</a></li><li class="chapter-item expanded "><a href="docking_scenarios.html"><strong aria-hidden="true">8.3.</strong> protein-ligand docking</a></li><li class="chapter-item expanded "><a href="docking_scenarios.html"><strong aria-hidden="true">8.4.</strong> protein-glycan docking</a></li></ol></li><li class="chapter-item expanded "><a href="info.html"><strong aria-hidden="true">9.</strong> Getting support / How to ask for help</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="info.html"><strong aria-hidden="true">9.1.</strong> Getting support / How to ask for help</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">9.2.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">10.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">10.1.</strong> Access to various tutorials</a></li><li class="chapter-item expanded "><a href="bpg.html"><strong aria-hidden="true">10.2.</strong> HADDOCK best practice guide - A must read when starting to use our software!</a></li></ol></li><li class="chapter-item expanded "><a href="eco_system.html"><strong aria-hidden="true">11.</strong> Haddock3 eco-system</a></li><li class="chapter-item expanded "><a href="online_lectures.html"><strong aria-hidden="true">12.</strong> Online lectures</a></li><li class="chapter-item expanded "><a href="citing.html"><strong aria-hidden="true">13.</strong> How to cite haddock3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="citing.html"><strong aria-hidden="true">13.1.</strong> Citing haddock3</a></li><li class="chapter-item expanded "><a href="publications.html"><strong aria-hidden="true">13.2.</strong> Haddock3-related publications</a></li></ol></li><li class="chapter-item expanded "><a href="acknowledgements.html"><strong aria-hidden="true">14.</strong> Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Haddock3 User Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-the-haddock3-user-manual"><a class="header" href="#welcome-to-the-haddock3-user-manual">Welcome to the Haddock3 user manual</a></h1>
<figure style="text-align: center;">
<img width="100%" src="./images/HADDOCK3-logo.png">
</figure>
<p>HADDOCK, standing for <strong>H</strong>igh <strong>A</strong>mbiguity <strong>D</strong>riven protein-protein <strong>DOCK</strong>ing, is a widely used computational tool for the integrative modeling of biomolecular interactions.
Developed by researchers at <a href="https://uu.nl">Utrecht University</a> in the <a href="https://bonvinlab.org">BonvinLab</a> for more than 20 years, it integrates various types of experimental data, biochemical, biophysical, bioinformatic prediction and knowledge to guide the docking process.</p>
<p>In this manual, we will describe:</p>
<ul>
<li>the basic concepts of HADDOCK</li>
<li>the new functionalities of the haddock3 software suite</li>
<li>how to create custom workflows</li>
<li>provide example workflows</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haddock---high-ambiguity-driven-docking"><a class="header" href="#haddock---high-ambiguity-driven-docking">HADDOCK - High Ambiguity Driven Docking</a></h1>
<p>High Ambiguity Driven DOCKing (HADDOCK), is now a long standing docking software, that harness the power of CNS (Crystallography and NMR System – <a href="https://cns-online.org">https://cns-online.org</a>) for structure calculation of molecular complexes.
What distinguishes HADDOCK from other docking software is its ability, inherited from CNS, to incorporate experimental data as restraints and use these to guide the docking process alongside traditional energetics and shape complementarity.
Moreover, the intimate coupling with CNS endows HADDOCK with the ability to actually produce models of sufficient quality to be archived in the Protein Data Bank.</p>
<p>A central aspect of HADDOCK is the definition of Ambiguous Interaction Restraints or AIRs.
These allow the translation of raw data such as NMR chemical shift perturbation or mutagenesis experiments into distance restraints that are incorporated into the energy function used in the calculations.
AIRs are defined through a list of residues that fall under two categories: active and passive.
Generally, active residues are those of central importance for the interaction, such as residues whose knockouts abolish the interaction or those where the chemical shift perturbation is higher.
Throughout the simulation, these active residues are restrained to be part of the interface, if possible, otherwise incurring a scoring penalty.
Passive residues are those that contribute to the interaction but are deemed of less importance. If such a residue does not belong in the interface there is no scoring penalty.
Hence, a careful selection of which residues are active and which are passive is critical for the success of the docking.</p>
<h2 id="haddock-scoring-function"><a class="header" href="#haddock-scoring-function">HADDOCK scoring function</a></h2>
<p>CNS modules are using the HADDOCK scoring function to score and rank generated models.
The HADDOCK scoring function consists of a linear combination of various weighted physics-based energies terms and buried surface area.</p>
<p>The scoring is performed according to the <em>weighted sum</em> (HADDOCK score) of the 6 following terms:</p>
<ul>
<li><em>Eelec</em>: electrostatic intermolecular energy</li>
<li><em>Evdw</em>: van der Waals intermolecular energy</li>
<li><em>Edesol</em>: desolvation energy</li>
<li><em>BSA</em>: buried surface area</li>
<li><em>Eair</em>: distance restraints energy (only unambiguous and AIR (ambig) restraints)</li>
<li><em>Esym</em>: symmetry restraints energy (NCS and C2/C3/C5 terms)</li>
</ul>
<figure style="text-align: center;">
<img width="100%" src="./images/haddock_scoring_function_terms.png">
</figure>
<p>As the weights for each of the scoring function components differs for the various available CNS module, they will be described in each of the modules (see: <a href="./modules.html">haddock3 modules</a>).</p>
<p>Of course, these weights can be tuned by the user, by modifying their related parmeters:</p>
<ul>
<li><code>w_elec</code>: to tune the electrostatic intermolecular energy weight</li>
<li><code>w_vdw</code>: to tune the van der Waals intermolecular energy weight</li>
<li><code>w_desolv</code>: to tune the desolvation energy weight</li>
<li><code>w_bsa</code>: to tune the buried surface area weight</li>
<li><code>w_air</code>: to tune the distance restraints energy (only unambiguous and AIR (ambig) restraints) weight</li>
<li><code>w_sym</code>: to tune the symmetry restraints energy (NCS and C2/C3/C5 terms) weight</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haddock3"><a class="header" href="#haddock3">Haddock3</a></h1>
<p>HADDOCK3 is the next generation integrative modelling software of the long-lasting HADDOCK docking tool.
It represents a complete rethinking and rewriting of the HADDOCK2.X series, implementing a new way to interact with HADDOCK and offering new features to users who can now define custom workflows.</p>
<p>In the previous HADDOCK2.x versions, users had access to a highly parameterisable yet rigid simulation pipeline composed of three steps: rigid-body docking (<em>it0</em>), semi-flexible refinement (<em>it1</em>), and final refinement (<em>itw</em>).</p>
<figure style="text-align: center;">
<img width="75%" src="./images/HADDOCK2-stages.png">
</figure>
<p>In HADDOCK3, users have the freedom to configure docking workflows into functional pipelines by combining the different HADDOCK3 modules, thus adapting the workflows to their projects.
HADDOCK3 has therefore developed to truthfully work like a puzzle of many pieces (simulation modules) that users can combine freely.
To this end, the “old” HADDOCK machinery has been modularized, and several new modules added, including third-party software additions.
As a result, the modularization achieved in HADDOCK3 allows users to duplicate steps within one workflow (e.g., to repeat twice the it1 stage of the HADDOCK2.x rigid workflow).</p>
<p>Note that, for simplification purposes, at this time, not all functionalities of HADDOCK2.x have been ported to HADDOCK3, which does not (yet) support NMR RDC, PCS and diffusion anisotropy restraints, cryo-EM restraints and coarse-graining.
Any type of information that can be converted into ambiguous interaction restraints can, however, be used in HADDOCK3, which also supports the ab initio docking modes of HADDOCK.</p>
<p>To keep HADDOCK3 modules organized, we catalogued them into several categories.
However, there are no constraints on piping modules of different categories.</p>
<p>The main module categories are <em>“topology”</em>, <em>“sampling”</em>, <em>“refinement”</em>, <em>“scoring”</em>, and <em>“analysis”</em>.
There is no limit to how many modules can belong to a category. Modules are added as developed, and new categories will be created if/when needed.
You can access the <a href="https://www.bonvinlab.org/haddock3/modules/index.html">HADDOCK3 documentation page</a>{:target="_blank"}, or read the user manual for the <a href="./modules.html">list of all categories and modules</a>.</p>
<figure style="text-align: center;">
<img width="95%" src="./images/HADDOCK3-workflow-scheme.png">
</figure>
<p>The HADDOCK3 workflows are defined in simple configuration text files, similar to the <a href="https://toml.io/en/">TOML</a>{:target="_blank"} format but with extra features.
Contrary to HADDOCK2.X which follows a rigid (yet highly parameterisable) procedure, in HADDOCK3, you can create your own simulation workflows by combining a multitude of independent modules that perform specialized tasks.
Details on <a href="./config_file.html">how to create a workflow is provided in a dedicated section</a>.
We also provide a set of <a href="./docking_scenarios.html">docking scenario examples</a>, containing quite a variety of different protocols that can also guide you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-install-haddock3"><a class="header" href="#how-to-install-haddock3">How to install haddock3</a></h1>
<p>To install haddock3, you will need to sucessfully manage to get your hands on the following four steps:</p>
<ul>
<li><a href="./virtual-environments.html">Setup a virual environment</a></li>
<li><a href="./download-haddock3.html">Download haddock3 source code</a></li>
<li><a href="./install-cns.html">Install CNS</a></li>
</ul>
<p>A complete guide is also available on our <a href="https://github.com/haddocking/haddock3/blob/main/docs/INSTALL.md">haddock3 GitHub repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="virtual-environments"><a class="header" href="#virtual-environments">Virtual environments</a></h2>
<p>Haddock3 makes use of system variables as well as external libraries.
To ensure a reproducible and stable functional version of haddock3, we strongly advise to intall it using a virual environment.
When used from within a virtual environment, common installation tools such as <code>pip</code> will install Python packages into a virtual environment, limitting conflicts with other tools already installed on your computing engine.</p>
<p>Two major environment managing system are effective and capable of installing haddock3, namely
<a href="https://docs.python.org/3/library/venv.html">venv</a>
and <a href="https://conda.io/projects/conda/en/latest/user-guide/install/index.html">conda</a>.
Below you will find the instruction on how to install them and setup a proper haddock3 environment.</p>
<h3 id="venv"><a class="header" href="#venv">venv</a></h3>
<p>As the <code>venv</code> library is part of the python3 standard library, hence there is no need to installing it, considering python3 is installed on your machine.
By using <code>venv</code>, you will be able to set the python3 version you want (&gt;=3.9 for haddock3).</p>
<p>For more details and troubleshooting with the <code>venv</code> library, have a look at <a href="https://docs.python.org/3/library/venv.html">its documentation</a></p>
<p>Then create a new clean environement with the following command:</p>
<pre><code class="language-bash">python3.9 -m venv .haddock3-env
# or
python3.10 -m venv .haddock3-env
# or
python3.11 -m venv .haddock3-env
# or
python3.12 -m venv .haddock3-env
</code></pre>
<p>Finally, you should activate the environement, and you are readdy for the next steps</p>
<pre><code class="language-bash">source .haddock3-env/bin/activate
</code></pre>
<h3 id="anaconda--miniconda"><a class="header" href="#anaconda--miniconda">Anaconda / miniconda</a></h3>
<p>For more details and troubleshooting with the <code>conda</code> library, have a look at <a href="https://conda.io/projects/conda/en/latest/user-guide/install/index.html">its documentation</a></p>
<p>Then create a new <code>haddock3</code> environement with the following command:</p>
<pre><code class="language-bash">conda create -n haddock3 python=3.9
# or
conda create -n haddock3 python=3.10
# or
conda create -n haddock3 python=3.11
# or
conda create -n haddock3 python=3.12
</code></pre>
<p>Finally, you should activate the environement, and you are readdy for the next steps</p>
<pre><code class="language-bash">conda activate haddock3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="intall-via-the-python-package-index-pypi"><a class="header" href="#intall-via-the-python-package-index-pypi">Intall via the Python Package Index (PyPI)</a></h2>
<p>We have simplified the installation of Haddock3 by adding it to the Python Package Index.</p>
<p>Therefore, the only command you should run is the following:</p>
<pre><code class="language-bash">pip install haddock3
</code></pre>
<h2 id="download-haddock3-source-code"><a class="header" href="#download-haddock3-source-code">Download haddock3 source code</a></h2>
<p>Haddock3 is an open source software and therefore its source code can be downloaded at any time.
We are hosting the code on a dedicated <a href="https://github.com/haddocking/haddock3/">GitHub repository</a>, allowing for better version control, code development and maintainability.</p>
<p>For usage tracking purposes (to avoid counting robots downloading the tool), we advise users to download it from our <a href="https://www.bonvinlab.org/software/haddock3/#haddock3-distribution-download">lab page</a>, as it allows us for easier reporting to authoritise supporting the development of this project with grants.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="install-cns"><a class="header" href="#install-cns">Install CNS</a></h2>
<p>HADDOCK is using <a href="http://cns-online.org/v1.3/">Crystallography &amp; NMR System (CNS)</a> as core computing engine.
CNS is a FORTRAN66 code that must be compiled on your machine, for your own hardware.
Please see the up-to-date installation procedure of CNS <a href="https://github.com/haddocking/haddock3/blob/main/docs/CNS.md">here</a>, where you will find specific guide and troubleshooting sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interfaces"><a class="header" href="#command-line-interfaces">Command line interfaces</a></h1>
<p>Haddock3 is a software that can read configuration files and compute data.
While there will be <a href="">a web application</a>, haddock3 do not have interface, and you must use it from the command line.
While this may have some negative impact for some unexperienced user, it is also very powerful as it allows custom scripts to launch haddock, and therefore integrate it in your own pipelines.</p>
<p>To use the command line interface, you must open a terminal:</p>
<ul>
<li>[iTerm / Terminal]: for Mac users, defaults terminals are available and fully functional.</li>
<li>[WindowsPowerShell]: The windows solution to open a terminal.</li>
<li><a href="">VSCode</a>: an integrated developping environnment (IDE) that allows you to run command lines in the terminal.</li>
</ul>
<p>Haddock3 comes with several Command Line Interfaces (CLIs), that are described and listed below:</p>
<ul>
<li><a href="clis.html#haddock3">haddock3</a>: Main CLI for running a workflow.</li>
<li><a href="clis.html#haddock3-cfg">haddock3-cfg</a>: Obtain information about module parameters</li>
<li><a href="clis.html#haddock3-restraints">haddock3-restraints</a>: Generation of restraints.</li>
<li><a href="clis.html#haddock3-score">haddock3-score</a>: Scoring CLI.</li>
<li><a href="clis.html#haddock3-analyse">haddock3-analyse</a>: Analysis of output.</li>
<li><a href="clis.html#haddock3-analyse">haddock3-traceback</a>: Traceback of generated docking models.</li>
<li><a href="clis.html#haddock3-re">haddock3-re</a>: Recomputing modules with different parameters.
<ul>
<li><a href="clis.html#-re-score">haddock3-re score</a>: To modify scoring function weights.</li>
<li><a href="clis.html#-re-clustfcc">haddock3-re clustfcc</a>: To modify <code>[clustfcc]</code> parameters.</li>
<li><a href="clis.html#-re-clustrmsd">haddock3-re clustrmsd</a>: To modify <code>[clustrmsd]</code> parameters.</li>
</ul>
</li>
<li><a href="clis.html#haddock3-copy">haddock3-copy</a>: To copy a haddock3 run.</li>
<li><a href="clis.html#haddock3-clean">haddock3-clean</a>: Archiving a run.</li>
<li><a href="clis.html#haddock3-unpack">haddock3-unpack</a>: Uncompressing an archived a run.</li>
<li><a href="clis.html#haddock3-pp">haddock3-pp</a>: Pre-processing of input files.</li>
</ul>
<h2 id="haddock3-1"><a class="header" href="#haddock3-1">haddock3</a></h2>
<p>The main command line, <code>haddock3</code> is used to launch a Haddock3 workflow from a <a href="/software/haddock3/manual/config_file">configuration file</a>.
It takes a positional argument, the path to the configuration file.</p>
<pre><code class="language-bash">haddock3 workflow.cfg
</code></pre>
<p>Also two optional arguments can be used:</p>
<ul>
<li><code>--restart &lt;module_id&gt;</code>: allows to restart the workflow restarting for the module id. Note that previously generated folders from the selected step onward will be deleted.</li>
<li><code>--extend-run &lt;run_directory&gt;</code>: allows to start the new workflow from the last step of a previously computed run.</li>
</ul>
<h2 id="haddock3-cfg"><a class="header" href="#haddock3-cfg">haddock3-cfg</a></h2>
<p>An other very interesting CLI is <code>haddock3-cfg</code>.
This CLI allows you to list the parameter names, their description and default values for each available modules.
Used without any option, the command <code>haddock3-cfg</code> will return all <a href="/software/haddock3/manual/global_parameters">Global parameters</a>.</p>
<p>To access the list of parameters for a given module, you should use the optinal argument <code>-m &lt;module_name&gt;</code>.
As an example, to list available parameters for the module <code>seletopclusts</code>, you should run the following command:</p>
<pre><code class="language-bash">haddock3-cfg -m seletopclusts
</code></pre>
<p>Please note that all the parameters for each module are also available from the <a href="https://www.bonvinlab.org/haddock3/modules/index.html">online documentation</a>.</p>
<h2 id="haddock3-restraints"><a class="header" href="#haddock3-restraints">haddock3-restraints</a></h2>
<p>The CLI <code>haddock3-restraints</code> is made to generate restraints used either a ambiguous restraints or unambiguous ones.
The <code>haddock3-restraints</code> CLI is composed of several sub-commands, each one dedicated to some specific actions, such as:</p>
<ul>
<li>Searching for solvent accessible residues</li>
<li>Gathering neighbors of a selection</li>
<li>Maintaining the conformation of a single chain with potential gap</li>
<li>Generating ambiguous restraints from active and passive resiudes</li>
<li>Generating plans and corresponding restraints</li>
</ul>
<p>As this CLI is more specialized, we have made a <a href="/software/haddock3/manual/restraints_cli">special chapter in this manual</a> to explain all the functionalities.</p>
<h2 id="haddock3-score"><a class="header" href="#haddock3-score">haddock3-score</a></h2>
<p>The <code>haddock3-score</code> is a CLI made for scoring a single complex.
The topologies are created and a small energy minimization is performed on the complex before the evalutation of the haddock score components.
It is dedicated to the scoring of it and only returns the computed haddock score and its components.
It is a short cut to a full configuration file that would contain the <code>topoaa</code> and <code>emscoring</code> modules.</p>
<p>To use it, provide the path to the complex to be scored:</p>
<pre><code class="language-bash">haddock3-score path/to/complex.pdb
</code></pre>
<p>This CLI can take optional parameters using the <code>-p</code> flag, where the user can provide the set of parameter and values to tune the weights of the Haddock scoring function.
Be aware that only parameters available for the <code>emscoring</code> module are accepted.</p>
<p>To tune the haddock3 scoring function weights, there are basically only 5 parameters to be tuned.</p>
<ul>
<li><strong>w_vdw</strong>: to tune the weight of the Van der Walls term</li>
<li><strong>w_elec</strong>: to tune the weight of the Electrostatic term</li>
<li><strong>w_desolv</strong>: to tune the weight of the Desolvation term</li>
<li><strong>w_air</strong>: to tune the weight of the Ambiguous Restraints term</li>
<li><strong>w_bsa</strong>: to tune the weight of the Burried Surface Area term</li>
</ul>
<p>Note that, if a parameter is not tuned, the defaults scoring function weights are used.</p>
<p>As an example, this command would tune the Van der Walls term during the evaluation of the complex:</p>
<pre><code class="language-bash">haddock3-score path/to/complex.pdb -p w_vdw 0.5
</code></pre>
<p>Note how the parameter name and its new value are separated by a space.</p>
<p>To modify multiple parameters, just add the new parameter separate by a space:</p>
<pre><code class="language-bash">haddock3-score path/to/complex.pdb -p w_vdw 0.5 w_bsa 0.2
</code></pre>
<h2 id="haddock3-analyse"><a class="header" href="#haddock3-analyse">haddock3-analyse</a></h2>
<p>HADDOCK3 allows to analyse different steps of the workflow, even after it has been completed. The <code>haddock3-analyse</code> command is the main tool for the analysis of one or more workflow steps. Typically it runs automatically at the end of a HADDOCK3 workflow (activated by the <a href="clis.html#the-postprocess-option"><code>postprocess</code></a> option), but it can be run independently as well.</p>
<pre><code>haddock3-analyse -r my-run-folder -m 2 5 6
</code></pre>
<p>Here <code>my-run-folder</code> is the run directory and 2, 5, and 6 are the steps that you want to analyse.</p>
<p>The command will inspect the folder, looking for the existing models. If the selected module is a <code>caprieval</code> module, <code>haddock3-analyse</code> simply loads the <code>capri_ss.tsv</code> and <code>capri_clt.tsv</code> files
produced by the <code>caprieval</code> module. Otherwise, <code>haddock3-analyse</code> runs a <code>caprieval</code> analysis of the models.
You can provide some <a href="https://github.com/haddocking/haddock3/blob/main/src/haddock/modules/analysis/caprieval/defaults.yaml">caprieval-specific parameters</a>
using the following syntax:</p>
<pre><code>haddock3-analyse -r my-run-folder -m 2 5 6 -p reference_fname my_ref.pdb receptor_chain F
</code></pre>
<p>Here the <code>-p</code> key tells the code that you are about to insert caprieval parameters, whose name should match the parameter name. Each parameter name and the corresponding value must be separated by a space character.</p>
<p>Another parameter that can be specified is <code>top_cluster</code>, which defines how many of the first N clusters will be considered in the analysis.
This value is set to 10 by default.</p>
<pre><code>haddock3-analyse -r my-run-folder -m 2 5 6 --top_cluster 12
</code></pre>
<p>This number is meaningless when dealing with models with no cluster information, that is, models that have never been clustered before.</p>
<p>By default <code>haddock3-analyse</code> produces <a href="https://plotly.com/python/">plotly</a> plots in the html <code>format</code>, but the user can select
one of the formats available <a href="https://plotly.github.io/plotly.py-docs/generated/plotly.io.write_image.html">here</a>,
while also adjusting the resolution with the <code>scale</code> parameter:</p>
<pre><code>haddock3-analyse -r my-run-folder -m 2 5 6 --format pdf --scale 2.0
</code></pre>
<h4 id="the-analysis-folder"><a class="header" href="#the-analysis-folder">The analysis folder</a></h4>
<p>After running <code>haddock3-analyse</code> you can check the content of the <code>analysis</code> directory in your run folder.
If everything went succesfully, one of the above commands should have produced an analysis folder structured as</p>
<pre><code>my-run-folder/
|--- analysis/
     |--- 2_caprieval_analysis
     |--- 5_seletopclusts_analysis
     |--- 6_flexref_analysis
</code></pre>
<p>Each subfolder contains all the analysis plots related to that specific step of the workflow.</p>
<p>By default <code>haddock3-analyse</code> produces a set of scatter plots that compare each HADDOCK energy term
(i.e., the HADDOCK score and its components) to the different metrics used to evaluate the quality of a model,
such as the interface-RMSD, Fnat, DOCKQ, and so on. An example is available <a href="../../../education/HADDOCK3/HADDOCK3-antibody-antigen/plots/scenario1-surface/irmsd_score.html">here</a>.</p>
<p>For each of the energy component and the metrics mentioned above <code>haddock3-analyse</code> produces also a box plot, in which each cluster
is considered separately. An example is available <a href="../../../education/HADDOCK3/HADDOCK3-antibody-antigen/plots/scenario1-surface/score_clt.html">here</a>.</p>
<h4 id="the-report"><a class="header" href="#the-report">The report</a></h4>
<p>Scatter plots, box plots, CAPRI statistics and an interactive visualization of the models is available in the <code>report.html</code> file, present
in each analysis subfolder. In order to visualize the models it is necessary to start a local server at the end of the <code>haddock3-analyse</code> run,
following the indications provided in the log file:</p>
<pre><code>[2023-08-24 10:09:09,552 cli_analyse INFO] View the results in analysis/12_caprieval_analysis/report.html
[2023-08-24 10:09:09,552 cli_analyse INFO] To view structures or download the structure files, in a terminal run the command
`python -m http.server --directory /haddock3/examples/docking-antibody-antigen/run1-CDR-acc-cltsel-test`.
By default, http server runs on `http://0.0.0.0:8000/`. Open the link
http://0.0.0.0:8000/analysis/12_caprieval_analysis/report.html in a web browser.
</code></pre>
<p>Launch this command to open the report:</p>
<pre><code>python -m http.server --directory path-to-my-run
</code></pre>
<p>In the browser you can navigate to each analysis subfolder and open the <code>report.html</code> file. If you are not interested in
visualizing the models, you can simply open the <code>report.html</code> file in a standard browser. An example report can be visualized <a href="../../../education/HADDOCK3/HADDOCK3-protein-glycan/plots/report.html">here</a>.</p>
<h2 id="haddock3-traceback"><a class="header" href="#haddock3-traceback">haddock3-traceback</a></h2>
<p>HADDOCK3 is highly customisable and modular, as the user can introduce several refinement, clustering, and scoring steps in a workflow.
Quantifying the impact of the different modules is important while developing a novel docking protocol. The <code>haddock3-traceback</code> command
is developed to assist the user in this task, as it allows to "connect" all the models generated in a HADDOCK3 workflow:</p>
<pre><code>haddock3-traceback my-run-folder
</code></pre>
<p><code>haddock3-traceback</code> creates a traceback subfolder within the <code>my-run-folder</code> directory, containing a <code>traceback.tsv</code> table:</p>
<pre><code>00_topo1     00_topo2        01_rigidbody            01_rigidbody_rank       04_seletopclusts        04_seletopclusts_rank   06_flexref      06_flexref_rank 
4G6K.psf     4I1B.psf        rigidbody_10.pdb        3                       cluster_1_model_1.pdb   1                       flexref_1.pdb   2       
4G6K.psf     4I1B.psf        rigidbody_11.pdb        10                      cluster_1_model_2.pdb   3                       flexref_3.pdb   1       
4G6K.psf     4I1B.psf        rigidbody_18.pdb        4                       cluster_2_model_1.pdb   2                       flexref_2.pdb   4      
4G6K.psf     4I1B.psf        rigidbody_20.pdb        15                      cluster_2_model_2.pdb   4                       flexref_4.pdb   3       
</code></pre>
<p>In this table each row represents a model that has been produced by the workflow. The (typically) two used topologies are reported first,
and then each module has its own column, containing the name and rank of the model at that stage. As an example, in the first row of the
table above <code>rigidbody_10.pdb</code> is ranked 3rd at the <code>rigidbody</code> stage. Then, it becomes <code>cluster_1_model_1.pdb</code> (ranked 1st) after
the <code>seletopclusts</code> module. This model is then refined in <code>flexref_1.pdb</code>, which turns out to be the 2nd best model at the end of the workflow.</p>
<p>The table can be easily parsed and used to evaluate the impact of different refinement steps on the different models.</p>
<h2 id="the-postprocess-option"><a class="header" href="#the-postprocess-option">The postprocess option</a></h2>
<p>You may want to run the <code>haddock3-analyse</code> and <code>haddock3-traceback</code> commands by default at the end of the workflow.
The <code>postprocess</code> option of a standard HADDOCK3 configuration (.cfg) file is devoted to this task. At first, it forces HADDOCK3
to execute <code>haddock3-analyse</code> on all the <code>caprieval</code> folders found in the workflow, therefore loading data present in the CAPRI tables.
Second, it executes the <code>haddock3-traceback</code> command.</p>
<p>By default, <code>postprocess</code> is set to <code>true</code> but can also be de-activated at the beginning of your configuration file:</p>
<pre><code> ====================================================================
# This is a HADDOCK3 configuration file

# directory in which the docking will be done
run_dir = "my-run-folder"

# postprocess the run
postprocess = false

...
</code></pre>
<p><a class="prompt prompt-info">If speed is an issue, please turn the postprocess option off for your run!</a></p>
<p>You can find additional help by running the command: <code>haddock3-analyse -h</code> and <code>haddock3-traceback -h</code> and reading
the parameters' explanations. Otherwise, ask us in the <a href="https://github.com/haddocking/haddock3/issues">"issues" forum</a>.</p>
<h2 id="haddock3-re"><a class="header" href="#haddock3-re">haddock3-re</a></h2>
<p>The <code>haddock3-re</code> CLI is dedicated at <strong>re</strong>computing some steps in your workflow.
This can be very usefull as it allows to fine tune parameters and evaluate the impact in the results.</p>
<p><code>haddock3-re</code> takes two mandatory positional arguments:</p>
<ul>
<li>**1: **The name of the subcommand</li>
<li>**2: **Path to the module on which to apply the modifications in your run</li>
</ul>
<p>By running <code>haddock3-re</code>, a new directory will be created, with the <code>_interactive</code> suffix, where the new results are stored.
Relaunching several times <code>haddock3-re</code> on the same directory will update the content in the <code>_interactive</code> one.</p>
<p>For now, three modules can be <strong>re</strong>computed and tuned, <code>[caprieval]</code>, <code>[clustfcc]</code> and <code>[clustrmsd]</code>.</p>
<h3 id="-re-score"><a class="header" href="#-re-score">-re score</a></h3>
<p>The subcommand <code>haddock3-re score</code>, allows to tune the weights of the <a href="">HADDOCK scoring function</a>.
It takes a <code>[caprieval]</code> step folder as positional argument, and the tuned weights for the scoring function.</p>
<p>Note that if you do not provide new weights as optional arguments, previous weights used in the run are used.</p>
<p>Usage:</p>
<pre><code class="language-bash">haddock3-re clustrmsd &lt;path/to/the/module/step/X_caprieval&gt;

optional arguments:
  -e W_ELEC, --w_elec W_ELEC
                        weight of the electrostatic component.
  -w W_VDW, --w_vdw W_VDW
                        weight of the van-der-Waals component.
  -d W_DESOLV, --w_desolv W_DESOLV
                        weight of the desolvation component.
  -b W_BSA, --w_bsa W_BSA
                        weight of the BSA component.
  -a W_AIR, --w_air W_AIR
                        weight of the AIR component.
</code></pre>
<h3 id="-re-clustfcc"><a class="header" href="#-re-clustfcc">-re clustfcc</a></h3>
<p>The subcommand <code>haddock3-re clustfcc</code>, allows to tune the clustering parameters of the <code>[clustfcc]</code> module.
It takes a <code>[clustfcc]</code> step folder as positional argument, and the tuned parameters for the module.</p>
<p>Note that if you do not provide new parameters as optional arguments, previous ones will be used instead.</p>
<p>Usage:</p>
<pre><code class="language-bash">haddock3-re clustfcc &lt;path/to/the/module/step/X_clustfcc&gt;

optional arguments:
  -f CLUST_CUTOFF, --clust_cutoff CLUST_CUTOFF
                        Minimum fraction of common contacts to be considered in a cluster.
  -s STRICTNESS, --strictness STRICTNESS
                        Strictness factor.
  -t MIN_POPULATION, --min_population MIN_POPULATION
                        Clustering population threshold.
  -p, --plot_matrix     Generate the matrix plot with the clusters.
</code></pre>
<h3 id="-re-clustrmsd"><a class="header" href="#-re-clustrmsd">-re clustrmsd</a></h3>
<p>The subcommand <code>haddock3-re clustrmsd</code>, allows to tune the clustering parameters of the <code>[clustrmsd]</code> module.
It takes a <code>[clustrmsd]</code> step folder as positional argument, and the tuned parameters for the module.</p>
<p>Note that if you do not provide new parameters as optional arguments, previous ones will be used instead.</p>
<p>Usage:</p>
<pre><code class="language-bash">haddock3-re clustrmsd &lt;path/to/the/module/step/X_clustrmsd&gt;

optional arguments:
  -n N_CLUSTERS, --n_clusters N_CLUSTERS
                        number of clusters to generate.
  -d CLUST_CUTOFF, --clust_cutoff CLUST_CUTOFF
                        clustering cutoff distance.
  -t MIN_POPULATION, --min_population MIN_POPULATION
                        minimum cluster population.
  -p, --plot_matrix     Generate the matrix plot with the clusters.
</code></pre>
<p>Please note that parameters <code>--n_clusters</code> (defining the number of clusters you want)
and <code>--clust_cutoff</code> are mutually exclusive,
as the former is cutting the dendogram at a height satifying the number of desired clusters
while the latter is cutting the dendogram at the <code>--clust_cutoff</code> value height.</p>
<h2 id="haddock3-copy"><a class="header" href="#haddock3-copy">haddock3-copy</a></h2>
<p>The <code>haddock3-copy</code> CLI allows one to copy the content of a run to an other run directory.</p>
<p>It takes three arguments:</p>
<ul>
<li><strong><code>-r run_directory</code></strong> is the directory of a previously computed haddock3 run.</li>
<li><strong><code>-o new_run_directory</code></strong> is the new directory where to make to copy of the old run.</li>
<li><strong><code>-m module_id_X module_id_Y</code></strong> is the list of modules you wish to copy (separated by spaces).</li>
</ul>
<p>As an example, considering your previous run directory is named <code>run1</code> and contains the following modules:</p>
<pre><code class="language-bash">run1/
  0_topoaa/
  1_rigidbody/
  2_caprieval/
  3_seletop/
  4_flexref/
  (etc...)
</code></pre>
<p>You may want to use <code>4_flexref</code> step folder as a starting point for a new run names <code>run2</code>.
To do so, run the following command:</p>
<pre><code class="language-bash">haddock3-copy -r run1 -m 0 4 -o run2
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>the flag <code>-m</code> allows to define which modules must be copied, and modules <code>0</code> (for <code>0_topoaa</code>) and <code>4</code>  (for <code>4_flexref</code>) are space separated.</li>
<li>in this case, we also copy the content of <code>0_topoaa</code>, this is because topologies are stored in this module directory, and we must have access to them if we are using an other module requiering CNS topology to run.</li>
</ul>
<p><strong>WARNING</strong>:
To copy the content of a run and modify the paths, we are using the <code>sed</code> command, searching to replace the previous run directory name (<code>run1</code>) to the new one (<code>run2</code>) in all the generated files to make sure that paths will be functional in the new run directory.
In some cases, this can lead to some artefacts, such as the modification of attribute names if your run directory contain a name that is used by haddock3.</p>
<p>Here is a list of run directory names <strong>NOT</strong> to use:</p>
<ul>
<li>topology</li>
<li>score</li>
<li>emref</li>
<li>etc...</li>
</ul>
<p>The best solution is to always use a unique name that describe the content of the run.</p>
<h2 id="haddock3-clean"><a class="header" href="#haddock3-clean">haddock3-clean</a></h2>
<p>The<code> haddock3-clean</code> CLI performs file archiving and file compressing operations on the output of an haddock3 run directory.
This CLI can save you some harddrive storage space, as the multiple files generated by HADDOCK can lead to several GigaBites of data, therefore compressing them allows to keep them while saving some precious splace.</p>
<p>All <code>.inp</code> and <code>.out</code> files are deleted except for the first one, which is compressed to <code>.gz</code>.
On the other hand, all <code>.seed</code> and <code>.con</code> files are compressed and archived to <code>.tgz</code> files.
Finally, <code>.pdb</code> and <code>.psf</code> files are compressed to <code>.gz</code>.</p>
<p>The &lt;run_directory&gt; can either be a whole HADDOCK3 run folder or a specific folder of the workflow step. <ncores> defines the number of threads to use; by default uses a single core.</p>
<p>Please note that by default this CLI is launched automatically at the end of a workflow.
It is exposed as generaral parameter <code>clean = true</code>.
To switch off this behavior, you can set it to false in your configuration file.</p>
<p>Usages:</p>
<pre><code class="language-bash"># Display help
haddock3-clean -h
haddock3-clean run1 # Where run1 is a path to a haddock3 run directory
haddock3-clean run1/1_rigidbody  # Where 1_rigidbody is the output of the rigidbody module
haddock3-clean run1 -n  # uses all cores
haddock3-clean run1 -n 2  # uses 2 cores
</code></pre>
<p>Here is the list of arguments:</p>
<pre><code class="language-bash">positional arguments:
  run_dir               The run directory.

optional arguments:
  -n [NCORES], --ncores [NCORES]
                        The number of threads to use. Uses 1 if not specified. Uses all available threads if `-n` is given. Else,
                        uses the number indicated, for example: `-n 4` will use 4 threads.
  -v, --version         show version
</code></pre>
<h2 id="haddock3-unpack"><a class="header" href="#haddock3-unpack">haddock3-unpack</a></h2>
<p>The <code>haddock3-unpack</code> CLI is the oposite of the <code>haddock3-clean</code> one.
It takes a haddock3 run directory as input (or the output directory of a module), and uncompress archives found within.</p>
<p>This CLI can be especially usefull when your run has been archived, but you would like to open a PDB file using a molecular viewer.</p>
<p>The unpack process performs file unpacking and file decompressing operations.
File with extension <code>seed</code> and <code>con</code> are unpacked from their <code>.tgz</code> files.
While files with <code>.pdb.gz</code> and <code>.psf.gz</code> extension are uncompressed.
If <code>--all</code> is given, unpack also <code>.inp.gz</code> and <code>.out.gz</code> files.</p>
<p>Usage:</p>
<pre><code class="language-bash"># To display help
haddock3-unpack -h
# To unpack the entier run directory
haddock3-unpack run1
# To unpack the output directory of a specific module
haddock3-unpack run1/1_rigidbody
# Define the number of cores to use
haddock3-unpack run1 -n  # uses all cores
haddock3-unpack run1 -n 2  # uses 2 cores
# Add the -a or --all to specify that all compressed files must be unpacked
haddock3-unpack run1 -n 2 -a
haddock3-unpack run1 -n 2 --all
</code></pre>
<p>Arguments:</p>
<pre><code class="language-bash">positional arguments:
  run_dir               The run directory.

optional arguments:
  -h, --help            show this help message and exit
  --all, -a             Unpack all files (includes `.inp` and `.out`).
  -n [NCORES], --ncores [NCORES]
                        The number of threads to use. Uses 1 if not specified. Uses all available threads if `-n` is given. Else,
                        uses the number indicated, for example: `-n 4` will use 4 threads.
  -v, --version         show version
</code></pre>
<h2 id="haddock3-pp"><a class="header" href="#haddock3-pp">haddock3-pp</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-files"><a class="header" href="#input-files">Input files</a></h1>
<p>Over the years, HADDOCK was updated to increase the range of biomolecular entities to be delt with.
Currently, we support a broad range of molecular types, such as protein, DNA, RNA, glycans, cyclic-peptides and small-molecules.
In addition, several modified residues/nucleotides are also available.
For the full list of supported molecules, please refere to: <a href="https://wenmr.science.uu.nl/haddock2.4/library">https://wenmr.science.uu.nl/haddock2.4/library</a>.
If you wish to work with a molecule type that is not present in this list, please refere to the <a href="structure_requirements.html#dealing-with-non-standard-molecules">Dealing with non-standard molecules section</a>.</p>
<p>In the following sections, we will tackle the variety and specificity of each of the molecule types.</p>
<h2 id="supported-file-format"><a class="header" href="#supported-file-format">Supported file format</a></h2>
<p>Haddock3 currently supports files in PDB and mmCIF format.
The PDB format is quite strict, and all characters must be well positionned in the file.</p>
<p>To make sure your file is correctly formated, you can use the <code>pdbtools</code> library (should be already installed in your <code>haddock3</code> virtual environement),
or read go to <a href="https://cupnet.net/pdb-format/">this online resource</a> where it is well explained.</p>
<p>Please refere to the <a href="/software/haddock3/manual/pdbtools.html">pdb-tools</a> section for more information on how to use it.</p>
<h2 id="number-of-input-molecules"><a class="header" href="#number-of-input-molecules">Number of input molecules</a></h2>
<p>Haddock3 currently supports up to 20 separate input molecules, thus allowing multi-body (1 &lt;= N &lt;= 20) docking.
Each input molecule can be composed of an <a href="structure_requirements.html#conformational-ensemble">ensemble of conformations</a>, allowing to implicitly represent the conformational sampling.
Input molecules can also be composed of multiple chains, allowing for their evaluation using scoring and analysis modules.</p>
<p>To input molecules, use the <a href="/software/haddock3/manual/global_parameters">global parameter</a> <code>molecules = ["path/to/mol1.pdb", "path/to/mol2.pdb"]</code>.</p>
<h2 id="definition-of-a-chain"><a class="header" href="#definition-of-a-chain">Definition of a chain</a></h2>
<p>A chain is defined by a letter in the 22<sup>nd</sup> position in the PDB file format.
Within the same file, two chains must be separated by a <code>TER</code> statment.
Do not worry if you have gaps (missing resiudes) in your chain, it will be automatically detected by HADDOCK.
To make sure the structure do not fall appart during molecular dynamics steps, you can add <a href="/software/haddock3/manual/restraints_cli.html#body-restraints"><code>body-restraints</code></a> ensuring the constant distance originally observed in the input file.</p>
<h2 id="conformational-ensemble"><a class="header" href="#conformational-ensemble">Conformational ensemble</a></h2>
<p>Conformational ensembles are detected using the <code>MODEL</code> and <code>ENDMDL</code> keywords in the PDB file.
Note that if in your ensemble, we detect two types of <code>REMARK</code> statments when providing an ensemble:</p>
<ul>
<li><code>REMARK     MODEL X FROM conformationX.pdb</code>: as generated by <code>pdb_mkensemble</code>, we will keep track of the origin of the conformation.</li>
<li><code>REMARK   X MODEL Y MD5 XXXXXXXXXXXXXXXXXX</code>: as provided by CAPRI scroing set, we will keep track of the MD5 checksum of the input conformation/model.</li>
</ul>
<h2 id="dealing-with-non-standard-molecules"><a class="header" href="#dealing-with-non-standard-molecules">Dealing with non-standard molecules</a></h2>
<p>If you wish to work with a molecule type that is not present in the <a href="https://rascar.science.uu.nl/haddock2.4/library">list of supported molecules</a>, do not worry, as you will still be able to use HADDOCK.
To properly function, HADDOCK require to have access to the topology and parameters of a molecule to run the molecular dynamics protocols.
The force-field must therefore be updated by user provided topology and parameter files.</p>
<p>In modules that uses CNS, you can provide such files with the <code>ligand_top_fname</code> (for ligand topology filename) and <code>ligand_param_fname</code> (for ligand parameters filename) parameters, specifying the location where to find those two files.</p>
<h3 id="how-to-generate-topology-and-parameters-for-my-ligand"><a class="header" href="#how-to-generate-topology-and-parameters-for-my-ligand">How to generate topology and parameters for my ligand</a></h3>
<p>Generating topology and parameters for your ligand is not trivial.
For this, you will need to use dedicated tools, such as <code>acpype</code> or <a href="https://www.ccp4.ac.uk/html/index.html"><code>ccp4-prodrg</code></a>, or use dedicated libraries such as <a href="https://mmb.irbbarcelona.org/biobb/"><code>bioBB</code></a>.</p>
<p>Here are some usefull resources on how to generate those:</p>
<ul>
<li><strong>bioBB using acpype</strong>: https://mmb.irbbarcelona.org/biobb/workflows/tutorials/biobb_wf_ligand_parameterization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-files-1"><a class="header" href="#input-files-1">Input files</a></h1>
<p>Over the years, HADDOCK was updated to increase the range of biomolecular entities to be delt with.
Currently, we support a broad range of molecular types, such as protein, DNA, RNA, glycans, cyclic-peptides and small-molecules.
In addition, several modified residues/nucleotides are also available.
For the full list of supported molecules, please refere to: <a href="https://wenmr.science.uu.nl/haddock2.4/library">https://wenmr.science.uu.nl/haddock2.4/library</a>.
If you wish to work with a molecule type that is not present in this list, please refere to the <a href="structure_requirements.html#dealing-with-non-standard-molecules">Dealing with non-standard molecules section</a>.</p>
<p>In the following sections, we will tackle the variety and specificity of each of the molecule types.</p>
<h2 id="supported-file-format-1"><a class="header" href="#supported-file-format-1">Supported file format</a></h2>
<p>Haddock3 currently supports files in PDB and mmCIF format.
The PDB format is quite strict, and all characters must be well positionned in the file.</p>
<p>To make sure your file is correctly formated, you can use the <code>pdbtools</code> library (should be already installed in your <code>haddock3</code> virtual environement),
or read go to <a href="https://cupnet.net/pdb-format/">this online resource</a> where it is well explained.</p>
<p>Please refere to the <a href="/software/haddock3/manual/pdbtools.html">pdb-tools</a> section for more information on how to use it.</p>
<h2 id="number-of-input-molecules-1"><a class="header" href="#number-of-input-molecules-1">Number of input molecules</a></h2>
<p>Haddock3 currently supports up to 20 separate input molecules, thus allowing multi-body (1 &lt;= N &lt;= 20) docking.
Each input molecule can be composed of an <a href="structure_requirements.html#conformational-ensemble">ensemble of conformations</a>, allowing to implicitly represent the conformational sampling.
Input molecules can also be composed of multiple chains, allowing for their evaluation using scoring and analysis modules.</p>
<p>To input molecules, use the <a href="/software/haddock3/manual/global_parameters">global parameter</a> <code>molecules = ["path/to/mol1.pdb", "path/to/mol2.pdb"]</code>.</p>
<h2 id="definition-of-a-chain-1"><a class="header" href="#definition-of-a-chain-1">Definition of a chain</a></h2>
<p>A chain is defined by a letter in the 22<sup>nd</sup> position in the PDB file format.
Within the same file, two chains must be separated by a <code>TER</code> statment.
Do not worry if you have gaps (missing resiudes) in your chain, it will be automatically detected by HADDOCK.
To make sure the structure do not fall appart during molecular dynamics steps, you can add <a href="/software/haddock3/manual/restraints_cli.html#body-restraints"><code>body-restraints</code></a> ensuring the constant distance originally observed in the input file.</p>
<h2 id="conformational-ensemble-1"><a class="header" href="#conformational-ensemble-1">Conformational ensemble</a></h2>
<p>Conformational ensembles are detected using the <code>MODEL</code> and <code>ENDMDL</code> keywords in the PDB file.
Note that if in your ensemble, we detect two types of <code>REMARK</code> statments when providing an ensemble:</p>
<ul>
<li><code>REMARK     MODEL X FROM conformationX.pdb</code>: as generated by <code>pdb_mkensemble</code>, we will keep track of the origin of the conformation.</li>
<li><code>REMARK   X MODEL Y MD5 XXXXXXXXXXXXXXXXXX</code>: as provided by CAPRI scroing set, we will keep track of the MD5 checksum of the input conformation/model.</li>
</ul>
<h2 id="dealing-with-non-standard-molecules-1"><a class="header" href="#dealing-with-non-standard-molecules-1">Dealing with non-standard molecules</a></h2>
<p>If you wish to work with a molecule type that is not present in the <a href="https://rascar.science.uu.nl/haddock2.4/library">list of supported molecules</a>, do not worry, as you will still be able to use HADDOCK.
To properly function, HADDOCK require to have access to the topology and parameters of a molecule to run the molecular dynamics protocols.
The force-field must therefore be updated by user provided topology and parameter files.</p>
<p>In modules that uses CNS, you can provide such files with the <code>ligand_top_fname</code> (for ligand topology filename) and <code>ligand_param_fname</code> (for ligand parameters filename) parameters, specifying the location where to find those two files.</p>
<h3 id="how-to-generate-topology-and-parameters-for-my-ligand-1"><a class="header" href="#how-to-generate-topology-and-parameters-for-my-ligand-1">How to generate topology and parameters for my ligand</a></h3>
<p>Generating topology and parameters for your ligand is not trivial.
For this, you will need to use dedicated tools, such as <code>acpype</code> or <a href="https://www.ccp4.ac.uk/html/index.html"><code>ccp4-prodrg</code></a>, or use dedicated libraries such as <a href="https://mmb.irbbarcelona.org/biobb/"><code>bioBB</code></a>.</p>
<p>Here are some usefull resources on how to generate those:</p>
<ul>
<li><strong>bioBB using acpype</strong>: https://mmb.irbbarcelona.org/biobb/workflows/tutorials/biobb_wf_ligand_parameterization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pdb-tools"><a class="header" href="#pdb-tools">PDB-Tools</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docking-restraints"><a class="header" href="#docking-restraints">Docking restraints</a></h1>
<p>HADDOCK relies on restraints to guide the sampling during the docking.
Various types of restraints are available, namely <strong>Ambiguous</strong>, <strong>Unambiguous</strong> and <strong>Hydrogen</strong> distance restraints.
Restraints are defined using the CNS syntax, basically defining two selections and a pseudo-distance that must be satisfied.
In case of unsatisfied restraints, a pseudo-energetical penalty is applied to the HADDOCK scoring function, therefore enabling to rank lower complexes that do not respect the restraints.</p>
<h2 id="distance-restraints"><a class="header" href="#distance-restraints">Distance restraints</a></h2>
<p>In the definition of restraints, we define two type of selection, <em>active</em> (first selection) and <em>passive</em> (second selection) and a pseudo-distance to be satisfied.</p>
<ul>
<li>The <em><strong>active</strong></em> residues are those experimentally identified to be involved in the interaction between the two molecules <strong>AND</strong> solvent accessible (either main chain or side chain relative accessibility should be typically &gt; 40%, although a lower cutoff might be used as well).</li>
<li>The <em><strong>passive</strong></em> residues are all solvent accessible surface neighbors of active residues <strong>OR</strong> group of atoms possibly part of the interaction.</li>
</ul>
<p>A distance restraints is constructed as follow:</p>
<p><code>assign (active selection) (passive selection) distance lower_boundary upper_boundary</code></p>
<p>Where:</p>
<ul>
<li><code>assign</code>: is the CNS syntax to define a new set of restraints (multiple assign statements can be found in the same restraints file)</li>
<li><code>active selection</code>: is the first selection statement.</li>
<li><code>passive selection</code>: is the second selection statement.</li>
<li><code>distance</code>: is the pseudo-distance where we hope to find the two selection together</li>
<li><code>lower_boundary</code>:</li>
<li><code>upper_boundary</code>: is the upper</li>
</ul>
<p>Basically a restraint is satisfied if the pseudo-distance is found between <code>distance - lower_boundary</code> and <code>distance + upper_boundary</code> (<code>distance - lower_boundary</code> &lt;= pseudo-distance &lt;= <code>distance - upper_boundary</code>).</p>
<p>By default, we usually use the following values:</p>
<ul>
<li>distance = 2.0</li>
<li>lower_boundary = 2.0</li>
<li>upper_boundary = 0.0</li>
</ul>
<p>therefore expecting the find the pseudo-distance under 2.0 between the two selections for a restraint to be satisfied.</p>
<p>For a detailed explanation of the distance restraints, please refere to the following articles:</p>
<ul>
<li>R.V. Honorato, M.E. Trellet, B. Jiménez-García1, J.J. Schaarschmidt, M. Giulini, V. Reys,  P.I. Koukos, J.P.G.L.M. Rodrigues, E. Karaca, G.C.P. van Zundert, J. Roel-Touris, C.W. van Noort, Z. Jandová, A.S.J. Melquiond and A.M.J.J. Bonvin. <a href="https://www.nature.com/articles/s41596-024-01011-0.epdf?sharing_token=UHDrW9bNh3BqijxD2u9Xd9RgN0jAjWel9jnR3ZoTv0O8Cyf_B_3QikVaNIBRHxp9xyFsQ7dSV3t-kBtpCaFZWPfnuUnAtvRG_vkef9o4oWuhrOLGbBXJVlaaA9ALOULn6NjxbiqC2VkmpD2ZR_r-o0sgRZoHVz10JqIYOeus_nM%3D">The HADDOCK2.4 web server: A leap forward in integrative modelling of biomolecular complexes</a>. <em>Nature Prot.</em>, Advanced Online Publication DOI: 10.1038/s41596-024-01011-0 (2024).</li>
<li>A.M.J.J. Bonvin, E. Karaca, P.L. Kastritis &amp; J.P.G.L.M. Rodrigues. Correspondence: <a href="https://doi.org/10.1038/s41596-018-0017-6">Defining distance restraints in HADDOCK</a>. <em>Nature Protocols</em> <em>13</em>, 1503 (2018). <a href="https://rdcu.be/1OyH">Free online only access</a></li>
<li>S.J. de Vries, M. van Dijk and A.M.J.J. Bonvin. <a href="https://www.nature.com/nprot/journal/v5/n5/abs/nprot.2010.32.html">The HADDOCK web server for data-driven biomolecular docking.</a> <em>Nature Protocols</em>, <em>5</em>, 883-897 (2010).</li>
</ul>
<h2 id="ambiguous-distance-restraints"><a class="header" href="#ambiguous-distance-restraints">Ambiguous distance restraints</a></h2>
<p>Ambiguous restraints are usually defined between two different chains, aiming at bringing them closer and guiding the docking procedure.
The use of ambiguous restraints is made by defining the <code>ambig_fname</code> parameter and providing the file path containing the restraints.</p>
<p>Because of the explicit ambiguity present in this file, two other parameters are also strongly linked to the ambiguous restraints file.</p>
<ul>
<li><code>randremoval</code>: this binary parameter is stating that some of the distance restraints present in the ambiguous file should be randomly removed. By default, it is set to <code>true</code>. If set to <code>false</code>, ambiguous restraints will behave as any other distance restraints.</li>
<li><code>npart</code>: this parameter define the number of parts (splits) used to remove the ambiguous restraints. If set to <code>2</code> (default), for each complex, 50% of the restraints we be randomly removed, if set to <code>3</code>, 33% of the restraints will be randomly removed, etc...</li>
</ul>
<p>Please note that you can provide a set of multiple restraints files, compressed in a <code>.tgz</code> archive.
In this scenario, we strongly advise to set the parameter <code>previous_ambig = true</code> in subsequent modules (instead of defining the path to the ambiguous file), so that the same ambiguous restraint file used to generate the first complex will be used again along the workflow for this specific complex.</p>
<p>The force constant of the ambiguous distance restraints can be tuned using the <code>ambig_scale</code> parameter or <code>ambig_hot</code>, <code>ambig_cool1</code>, <code>ambig_cool2</code> and <code>ambig_cool3</code> for simulated annealing stages in <code>[flexref]</code> module.</p>
<h2 id="unambiguous-distance-restraints"><a class="header" href="#unambiguous-distance-restraints">Unambiguous distance restraints</a></h2>
<p>In unambiguous restraints files, we often define distance restraints for which we are sure.
No random removal is applied on this set of restraints.
This type of restraints can be used to set distance between chain breaks, making sure that the two parts will not diverge during the simulation.
The use of unambiguous restraints is made by defining the <code>unambig_fname</code> parameter and providing the file path containing the restraints.</p>
<p>The force constant of the unambiguous distance restraints can be tuned using the <code>unambig_scale</code> parameter.</p>
<h2 id="hydrogen-distance-restraints"><a class="header" href="#hydrogen-distance-restraints">Hydrogen distance restraints</a></h2>
<p>Yet another type of restraint file, quite similar the the unambiguous ones, with no random removal applied.
This second type of unambiguous restraints can be defined using the <code>hbond_fname</code> parameter and providing the file path containing the restraints.</p>
<p>While unambiguous and hbond restraints are similar in their behavior, one can play with the scaling of the force constant (<code>hbond_scale</code>) to make them different, or define one or the other at various module stages in the workflow.</p>
<h2 id="other-type-of-restraints"><a class="header" href="#other-type-of-restraints">Other type of restraints</a></h2>
<p>In the HADDOCK2.X series, other types of restraints were available, namely:</p>
<ul>
<li>Diffusion anisotropy (DANI)</li>
<li>cryo-EM density maps</li>
<li>Pseudo contact shifts (PCS)</li>
<li>Radius of Gyration (Rg)</li>
<li>Residual Dipolar Couplings (RDCs)</li>
</ul>
<p>With the current version of haddock3, these restraints are not yet ported.
Stay tuned, as they will again show up in the near future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-restraints-with-haddock3"><a class="header" href="#generating-restraints-with-haddock3">Generating restraints with Haddock3</a></h1>
<p>Ambiguous (or not) restraints file must comply with the CNS syntax.
Generating them can be quite difficult, and for this reason we added a dedicated command line interface <code>haddock3-restraints</code>, allowing to perform several maniputation to generate restraints files to be used later in your docking experiment.</p>
<p>Usage:</p>
<pre><code class="language-bash">haddock3-restraints &lt;TASK_NAME&gt; &lt;TASK_ARGS&gt;
</code></pre>
<p>For the list of available tasks, run:</p>
<pre><code class="language-bash">haddock3-restraints -h
</code></pre>
<p>For the list of arguments for a given task, run:</p>
<pre><code class="language-bash">haddock3-restraints &lt;TASK_NAME&gt; -h
</code></pre>
<p>This CLI holds multiple sub-commands, listed and explained below:</p>
<ul>
<li><a href="restraints_cli.html#calc-accessibility">calc_accessibility</a>:</li>
<li><a href="restraints_cli.html#passive-form-active">passive_from_active</a>:</li>
<li><a href="restraints_cli.html#active-passive-to-ambig">active_passive_to_ambig</a>:</li>
<li><a href="restraints_cli.html#restrain-bodies">restrain_bodies</a>:</li>
<li><a href="restraints_cli.html#z-surface-restraints">z_surface_restraints</a>:</li>
<li><a href="restraints_cli.html#validate-tbl">validate_tbl</a>:</li>
</ul>
<h2 id="calc-accessibility"><a class="header" href="#calc-accessibility">Calc Accessibility</a></h2>
<h2 id="passive-form-active"><a class="header" href="#passive-form-active">Passive form active</a></h2>
<h2 id="active-passive-to-ambig"><a class="header" href="#active-passive-to-ambig">Active passive to ambig</a></h2>
<h2 id="restrain-bodies"><a class="header" href="#restrain-bodies">Restrain bodies</a></h2>
<h2 id="z-surface-restraints"><a class="header" href="#z-surface-restraints">Z surface restraints</a></h2>
<h2 id="validate-tbl"><a class="header" href="#validate-tbl">Validate tbl</a></h2>
<h1 id="new-version-of-the-haddock-restraints"><a class="header" href="#new-version-of-the-haddock-restraints">New version of the haddock-restraints</a></h1>
<p>A new version of the haddock3-restraints is currently being developped.
This new implementation using <em>rust</em> will allow better maintainability as well as its deployment on various operating systems as well as on web-browser using WebAssembly.
Not yet part of the haddock3 intallation, you can already find it in its dedicated repository at <a href="https://github.com/haddocking/haddock-restraints">https://github.com/haddocking/haddock-restraints</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symmetry-restraints"><a class="header" href="#symmetry-restraints">Symmetry restraints</a></h1>
<p>CNS modules using restraints, such as <code>[rigidbody]</code>, <code>[flexref]</code>, <code>[emref]</code> or <code>[mdref]</code>, are also capable of handling symmetry restraints.
This can be very useful when you know that the system you are working with contain such property, and you wish to enforce sampled solutions to be symmetrical.</p>
<p>Various symmetry restraints are already available in Haddock3.
But custom symmetry restraints can also be provided, to learn more about it, read the <a href="symmetry_restraints.html#custom-symmetry-restraints">custom symmetry section</a>.</p>
<h2 id="pre-defined-symmetry-restraints"><a class="header" href="#pre-defined-symmetry-restraints">Pre-defined symmetry restraints</a></h2>
<p>3 types of symmetry restraints have been implemented in haddock3:</p>
<ul>
<li><a href="symmetry_restraints.html#non-crystallographic-symmetry"><strong>Non-crystallographic symmetry</strong></a>: Restraining the conformation to be identical</li>
<li><a href="symmetry_restraints.html#rotational-symmetry"><strong>Rotational symmetries</strong></a>: where C2, C3, C4, C5 and C6 symmetry can be enforced between selected partners.</li>
<li><a href="symmetry_restraints.html#s3-symmetry"><strong>S3 symmetry</strong></a>: The S3 rotational and translational symmetry.</li>
</ul>
<p>They are described in more details below.</p>
<p>Here is a related research article describing some of the available symmetries in HADDOCK: E. Karaca, A.S.J. Melquiond, S.J. de Vries, P.L. Kastritis and A.M.J.J. Bonvin
<a href="https://doi.org/doi:10.1074/mcp.M000051-MCP201">Building macromolecular assemblies by information-driven docking: Introducing the HADDOCK multi-body docking server.</a>
<em>Mol. Cell. Proteomics</em>, <em>9</em>, 1784-1794 (2010). Download the final author version <a href="https://igitur-archive.library.uu.nl/chem/2011-0314-200254/UUindex.html">here</a>.</p>
<h3 id="non-crystallographic-symmetry"><a class="header" href="#non-crystallographic-symmetry">Non crystallographic symmetry</a></h3>
<p>Non-crystallographic symmetry (NCS) restraints is a type of restraints available in CNS.
While symmetry is in the name, there is in fact no symmetry involved.
They are simply enforcing an RMSD = 0 between the selected segments, independently of any rotation and/or translation, restraining the conformations to be similar.</p>
<p>To make use of NCS parameters, one should first activate the use of such restraints using the <code>ncs_on = true</code> parameter!</p>
<p>NCS restraints are defined between two partners, but multiple NCS restraints can be set up in the same run.
Parameters used to define NCS restraints are always composed of 6 information (devied into three sections, separated by underscores <code>_</code>), that must be provided:</p>
<ul>
<li><strong>The prefix section</strong>:
<ul>
<li><strong>Symmetry type</strong>: the parameter must start with <code>ncs_</code> as prefix, indicating haddock3 on what type of symmetry restraints we are dealing with.</li>
</ul>
</li>
<li><strong>The infix section</strong>:
<ul>
<li><strong>Starting resiude</strong>: using the infix <code>sta</code> (for start), defines the first residue in the cns restraint segment.</li>
<li><strong>Ending resiude</strong>: using the infix <code>end</code> (for end), defines the last residue in the cns restraint segment.</li>
<li><strong>ChainID/SegmentID</strong>: using the infix <code>seg</code> (for segment), defines the segmentID in the cns restraint segment.</li>
<li><strong>Partner index</strong>: after the infix, must be set an integer defining the partner (e.g.: <code>seg1</code>). This index is used to group parameters related to the same partner together and match the start, end, and segment id.</li>
</ul>
</li>
<li><strong>The suffix section</strong>:
<ul>
<li><strong>Symmetry index</strong>: as suffix (<code>_Y</code>) must be defined the index of the symmetry, this allows to defined multiple C<strong>N</strong> symmetries at the same time.</li>
</ul>
</li>
</ul>
<p>It is also possible to tune the force constant for the NCS symmetries restraints using the <code>kncs</code> parameter.</p>
<p>Here is an example on how to define a NCS restraints:</p>
<pre><code class="language-toml"># Activation of the NCS restraints
ncs_on = true  # Very important, otherwise nothing will be considered
# Tune the force constant
kncs = 1.0  # Here default parameter is shown for the purpose of the manual

################################
# Definition of NCS restraints #
################################
## PRFIX:  ncs_ is used to define NCS restraints
## INFIX:  `sta`, `end`, `seg` must be defined for the 3 segments
## SUFFIX: _1 is used (as it's the first definition of C3 symmetry)
####################################
# Definition of the first partner
ncs_sta1_1 = 1    # Residue number of first residue in the first C3 symmetry segment 
ncs_end1_1 = 30   # Residue number of last  residue in the first C3 symmetry segment 
ncs_seg1_1 = "A"  # Segment ID (chain ID) of this segment
# Definition of the second partner
ncs_sta2_1 = 1    # Residue number of first residue in the first C3 symmetry segment 
ncs_end2_1 = 30   # Residue number of last  residue in the first C3 symmetry segment 
ncs_seg2_1 = "B"  # Segment ID (chain ID) of this segment
</code></pre>
<p>Note that for the use of NCS restraints:</p>
<ul>
<li>starting, and ending residues <strong>MUST</strong> be the same.</li>
<li>chains/segments must be different.</li>
<li>the two partners must have the same sequence and residue numbering.</li>
</ul>
<p>We have dedicated functions to assess the validity of the NCS parameters.</p>
<h3 id="rotational-symmetry"><a class="header" href="#rotational-symmetry">Rotational symmetry</a></h3>
<p>Rotational symmetries (<strong>C symmetries</strong>) can be enforced between partners.
Currently, C2, C3, C4, C5 and C6 symmetries are available.
Each symmetry type (C<strong>N</strong>) must be defined between <strong>N</strong> partners to be valid.</p>
<figure align="center">
<img src="/software/haddock3/manual/images/CN_symmetries_haddock.jpg">
</figure>
<p>To make use of C<strong>N</strong> symmetry parameters, one should first activate the use of such restraints using the <code>sym_on = true</code> parameter!</p>
<p>Parameters used to define segments on which symmetry must be enforced are always composed of 6 information (devied into three sections, separated by underscores <code>_</code>), that must be provided:</p>
<ul>
<li><strong>The prefix section</strong>:
<ul>
<li><strong>Symmetry type</strong>: the parameter must start with <code>cNsym_</code> as prefix, where <code>N</code> is an integer defining the symmetry type (e.g.: <code>c2sym_</code>), allowing haddock3 to understand how many partners should be expected and how to automatically build the symmetry distance restraints.</li>
</ul>
</li>
<li><strong>The infix section</strong>:
<ul>
<li><strong>Starting resiude</strong>: using the infix <code>sta</code> (for start), defines the first residue in the C<strong>N</strong> symmetry segment.</li>
<li><strong>Ending resiude</strong>: using the infix <code>end</code> (for end), defines the last residue in the C<strong>N</strong> symmetry segment.</li>
<li><strong>ChainID/SegmentID</strong>: using the infix <code>seg</code> (for segment), defines the segmentID in the C<strong>N</strong> symmetry segment.</li>
<li><strong>Partner index</strong>: after the infix, must be set an integer defining the partner (e.g.: <code>seg1</code>). This index is used to group parameters related to the same partner together and match the start, end, and segment id.</li>
</ul>
</li>
<li><strong>The suffix section</strong>:
<ul>
<li><strong>Symmetry index</strong>: as suffix (<code>_Y</code>) must be defined the index of the symmetry, this allows to defined multiple C<strong>N</strong> symmetries at the same time.</li>
</ul>
</li>
</ul>
<p>Note that multiple symmetry restraints can be set up in the same run.
This is performed by indexing (<code>_Y</code>) the parameter name (e.g: <code>cNsym_xxx_Y</code>)
The first definition must always start with an index of 1 (<code>_1</code>)!</p>
<p>Here is an example on how to define two C3 symmetry:</p>
<pre><code class="language-toml"># Activation of the symmetry restraints
sym_on = true  # Very important, otherwise nothing will be considered
# Tune the force constant
ksym = 10.0  # Here default parameter is shown for the purpose of the manual

###################################
# First definition of C3 Symmetry #
###################################
## PRFIX:  c3sym_ is used to define C3 symmetry
## INFIX:  `sta`, `end`, `seg` must be defined for the 3 segments
## SUFFIX: _1 is used (as it's the first definition of C3 symmetry)
####################################
# Definition of the first partner
c3sym_sta1_1 = 1    # Residue number of first residue in the first C3 symmetry segment 
c3sym_end1_1 = 30   # Residue number of last  residue in the first C3 symmetry segment 
c3sym_seg1_1 = "A"  # Segment ID (chain ID) of this segment
# Definition of the second partner
c3sym_sta2_1 = 1    # Residue number of first residue in the first C3 symmetry segment 
c3sym_end2_1 = 30   # Residue number of last  residue in the first C3 symmetry segment 
c3sym_seg2_1 = "B"  # Segment ID (chain ID) of this segment
# Definition of the third partner
c3sym_sta3_1 = 1    # Residue number of first residue in the first C3 symmetry segment 
c3sym_end3_1 = 30   # Residue number of last  residue in the first C3 symmetry segment 
c3sym_seg3_1 = "C"  # Segment ID (chain ID) of this segment

####################################
# Second definition of C3 Symmetry #
####################################
## PRFIX:  c3sym is used to define C3 symmetry
## INFIX:  `sta`, `end`, `seg` must be defined for the 3 segments
## SUFFIX: _2 is used (as it's the second definition of C3 symmetry)
####################################
# Definition of the first partner
c3sym_sta1_2 = 31
c3sym_end1_2 = 60
c3sym_seg1_2 = "A"
# Definition of the second partner
c3sym_sta2_2 = 31
c3sym_end2_2 = 60
c3sym_seg2_2 = "B"
# Definition of the third partner
c3sym_sta3_2 = 31
c3sym_end3_2 = 60
c3sym_seg3_2 = "C"
</code></pre>
<p>It is also possible to tune the force constant for the C<strong>N</strong> symmetries using the <code>ksym</code> parameter.</p>
<p>We are providing an example of protein-homotrimer docking using haddock3 <a href="/software/haddock3/manual/docking_scenarios#protein-homotrimer">here</a>.</p>
<h3 id="s3-symmetry"><a class="header" href="#s3-symmetry">S3 symmetry</a></h3>
<p>To make use of S3 symmetry parameters, one should first activate the use of such restraints using the <code>sym_on = true</code> parameter!</p>
<p>It is also possible to tune the force constant for the S3 symmetry using the <code>ksym</code> parameter.</p>
<h2 id="custom-symmetry-restraints"><a class="header" href="#custom-symmetry-restraints">Custom symmetry restraints</a></h2>
<p>If the type of symmetries already implemented in haddock3 is not sufficent for your needs, you can always supply your own symmetry restraint file.
This is performed by defining the path to this file using the <code>symtbl_fname = custom_symmetry_restraints.tbl</code> parameter.
This parameter is available in <code>[rigidbody]</code>, <code>[flexref]</code>, <code>[emref]</code> and <code>[mdref]</code> modules.</p>
<p>For more details on how to define symmetry restraints, please refere to the <a href="https://nmr.cit.nih.gov/xplor-nih/xplorMan/node393.html">Xplor documentation, Distance Symmetry Restraints</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ab-initio--naive-docking-protocols"><a class="header" href="#ab-initio--naive-docking-protocols">Ab-initio / naive docking protocols</a></h1>
<p>While HADDOCK is ment to use information from coming from experiments, literature or bioinformatic predictions to guide the sampling during the docking, sometimes you cannot obtain such kind of data.
For this reasons, dedicated parameters can be turned <strong>on</strong> to perform <em>ab-inito</em> docking.</p>
<p>Three different ways of doing <em>ab-inito</em> docking in haddock3 are discussed below.</p>
<h3 id="prior-considerations"><a class="header" href="#prior-considerations">Prior considerations</a></h3>
<ul>
<li>As ab-initio docking contains very loose information on how the various chains involed should interact, we strongly advise to increase the sampling at <code>[rigidbody]</code> docking stage (using <code>sampling</code> parameter) as finind a good solution relies on trials and errors.</li>
<li>The next trhee <em>ab-inito</em> docking solution described below are incompatible with each other, and you should not turn <strong>on</strong> multiple of them at the same time.</li>
</ul>
<h2 id="center-of-mass-restraints"><a class="header" href="#center-of-mass-restraints">Center of mass restraints</a></h2>
<p>Turning <strong>on</strong> the center of mass restraints parameter (<code>cmrest = true</code>), will automatically generates restraints between the center of masses of the different chains present the system, and use those during the docking.</p>
<p>This parameter goes together with the <code>cmtight</code> paraemter, which controls how the upper limit distance is defined for the center of mass restraints between molecules.
Each molecule is oriented along its principle components and the x, y and z dimensions are calculated.
If <code>cmtight=true</code>, the molecule distance (size) is set to the average of its smallest two half dimensions.
If <code>cmtight=false</code>, the molecule distance (size) is set to the average of its three half dimensions.
In case of DNA, RNA, small ligands or glycans, the molecule distance (size) is set to 0.
The effective upper distance limit for the center of mass distance restraint is the sum of the two molecule distances.</p>
<p><code>cmrest</code> and <code>cmtight</code> parameters are accessible in <code>[rigidbody]</code> and <code>[flexref]</code> modules.</p>
<p>This parameter goes together with its force constant (<code>kcm</code>), that can be tuned as well.</p>
<p>Please note that setting <code>cmrest = true</code> is more suited for globular structures.
As for example, for a long bDNA structure, the restraint will be defined to the center of the DNA.</p>
<h2 id="random-ambiguous-restraints"><a class="header" href="#random-ambiguous-restraints">Random Ambiguous Restraints</a></h2>
<p>An other solution is to generate random ambiguous restraints.
This is performed by turning <strong>on</strong> the <code>ranair</code> parameter (<code>ranair = true</code>) in the <code>[rigidbody]</code> module.</p>
<p>By doing so, for each rigidbody sampling performed, residues on the surface of each chains will be randomly picked together with surrounding ones to define a patch.
Ambiguous restraints will then be generated between all the patches and rigidbody minimisation performed.</p>
<p>We suggest to turn on <code>contactairs = true</code> parameters in later stages of the workflow for CNS modules (<code>[flexref]</code>, <code>[emref]</code>, <code>[mdref]</code>).</p>
<p><strong><em>Note</em></strong> that <code>ranair</code> is limitted to the docking of two chains only, and no other type of restraints will be considered (even tho specified in the configuration file).</p>
<h2 id="surface-restraints"><a class="header" href="#surface-restraints">Surface restraints</a></h2>
<p>An alternative solution is to turn <strong>on</strong> the <code>surfrest</code> parameter (<code>surfrest = true</code>).
By doing so, surface residues are first detected and contact restraints between molecules are generated on the fly.
These are defined as an ambiguous distance restraint between all backbone (CA, BB or N1) atoms of two molecules (for small ligands all atoms are considered).
If less than 3 CA and P atoms are found, all atoms will be selected instead.
The upper limit is set to 7A (or 4.5A in case of small ligands).</p>
<p>Such restraints can be useful in multi-body (N&gt;2) docking to ensure that all molecules are in contact and thus promote compactness of the docking solutions.
As for the <a href="abinitio_docking.html#random-ambiguous-restraints">random AIRs</a>, surface contact restraints can be used in ab-initio docking; in such a case it is important to have enough sampling of the random starting orientations and this significantly increases the number of structures for rigid-body docking.</p>
<p>Note that this option is computationally more expensive than the <a href="abinitio_docking.html#center-of-mass-restraints">center of mass restraints</a> and <a href="abinitio_docking.html#random-ambiguous-restraints">random AIRs</a>, as the number of restraints is increasing by the power of the number of resiudes present in the system.
Also, because of the high number of restraints, the physico-chemical components of the scoring function can be masked by the noise of the AIRs component.
Therefore setting the weight of the AIR component to 0 (<code>w_air = 0</code>), could help the scoring function to better decipher between model conformations.</p>
<p>This parameter goes along with its force constant <code>ksurf</code>, that can be tuned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flexibility-options-in-haddock3"><a class="header" href="#flexibility-options-in-haddock3">Flexibility Options in Haddock3</a></h1>
<p>A molecule or a part of it, i.e., its segment, can be defined as:</p>
<ul>
<li>rigid;</li>
<li>semi-flexible;</li>
<li>fully flexible.</li>
</ul>
<p>By default, rigid and semi-flexible segments of docking partners are automatically defined based on interface contacts. By default, none of the segments are defined as fully flexible.</p>
<p>Flexibility can be defined in any of the Model Refinement modules (emref, flexref, and mdref).</p>
<p>The process for manual definition is detailed below.</p>
<hr> 
<h2 id="manual-definition-of-rigid-or-semi-flexible-segments"><a class="header" href="#manual-definition-of-rigid-or-semi-flexible-segments">Manual Definition of Rigid or Semi-Flexible Segments</a></h2>
<p>Parameters <code>nsegX = &lt;integer&gt;</code> are used to define:</p>
<ul>
<li>the docking partner (<code>X</code>) to which the segments of interest belong;</li>
<li>the type of flexibility (<code>&lt;integer&gt;</code>)of the segments of interest;</li>
<li>the number of these segments.</li>
</ul>
<p>The docking partner to which the segments belong is encoded in the name of the parameter itself. For example, if the segments belong to the 1st docking partner, the parameter <code>nseg1</code> should be used (defined in .cfg file). If the segments belong to the 2nd docking partner, then <code>nseg2</code> should be used, and if they belong to the 3rd docking partner, then <code>nseg3</code>, etc. Haddock3 allows up to 20 docking partners simultaneously.</p>
<p>The value of the chosen parameter simultaneously defines the type of flexibility and the number of segments:</p>
<ul>
<li>If <code>nsegX = -1</code>, then the Xth docking partner will be defined as rigid or semi-flexible automatically (default setting);</li>
<li>If <code>nsegX = 0</code>, then the Xth docking partner is defined as rigid;</li>
<li>If <code>nsegX = y</code> with <code>y &gt; 0</code>, then:
<ul>
<li>The segments of interest are defined as semi-flexible;</li>
<li>The number of these segments is equal to <code>y</code>. In this case, the first and last residues of each segment should be defined using pairs of parameters <code>seg_sta_X_1</code>, <code>seg_end_X_1</code>, and consequently <code>seg_sta_X_2</code>, <code>seg_end_X_2</code>, etc., until all <code>y</code> segments are defined. Haddock3 allows for up to 1000 segments, with residues numbered from -999 up to 9999.</li>
</ul>
</li>
</ul>
<h4 id="example-two-semi-flexible-segments-of-a-dna"><a class="header" href="#example-two-semi-flexible-segments-of-a-dna">Example: Two Semi-Flexible Segments of a DNA</a></h4>
<p>Let's consider a docking scenario involving two partners, namely a DNA and a protein, with two segments of DNA defined manually as semi-flexible. Suppose the first segment contains residues 2 to 19, and the second segment contains residues 22 to 39.</p>
<p>Since the order of the docking partner is important, let's define DNA as the 1st partner and protein as the 2nd partner in .cfg file, like so:</p>
<pre><code>molecules = ["DNA.pdb", "protein.pdb"]
</code></pre>
<p>To define two segments of DNA (<strong>1</strong>st partner), we should assign 2 to the parameter <code>nseg1</code> (standing for: <strong>n</strong>umber of <strong>seg</strong>ments for molecule <strong>1</strong>):</p>
<pre><code class="language-toml">nseg1 = 2
</code></pre>
<p>The last step is to define the first and last residues of each segment. The first segment starts with residue 2 and ends with residue 19, and the second segment starts with residue 22 and ends with residue 39:</p>
<pre><code class="language-toml">seg_sta_1_1 = 2
seg_end_1_1 = 19

seg_sta_1_2 = 22
seg_end_1_2 = 39
</code></pre>
<hr>
<h2 id="manual-definition-of-fully-flexible-segments"><a class="header" href="#manual-definition-of-fully-flexible-segments">Manual Definition of Fully Flexible Segments</a></h2>
<p>This definition is very similar to the semi-flexible definition. Parameters <code>nfleX</code> are used to define:</p>
<ul>
<li>the docking partner to which the segments of interest belong;</li>
<li>the type of flexibility of the segments of interest;</li>
<li>the number of these segments.</li>
</ul>
<p>The docking partner to which the segments belong is encoded in the name of the parameter itself. For example, if the segments belong to the 1st docking partner, the parameter <code>nfle1</code> should be used. If the segments belong to the 2nd docking partner, then <code>nfle2</code> should be used, etc. Haddock3 allows for up to 20 docking partners simultaneously.</p>
<p>The value of the chosen parameter simultaneously defines the type of flexibility and the number of segments:</p>
<ul>
<li>If <code>nfleX = 0</code>, then the Xth docking partner is defined as rigid (default setting);</li>
<li>If <code>nfleX = y</code> with <code>y &gt; 0</code>, then:
<ul>
<li>The segments of interest are defined as fully flexible;</li>
<li>The number of these segments is equal to <code>y</code>. In this case, the first and last residues of each segment should be defined using pairs of parameters <code>fle_sta_X_1</code>, <code>fle_end_X_1</code>, and consequently <code>fle_sta_X_2</code>, <code>fle_end_X_2</code>, etc., until all y segments are defined. Haddock3 allows for up to 1000 segments, with residues numbered up to 9999.</li>
</ul>
</li>
</ul>
<h4 id="one-fully-flexible-segment-of-a-glycan"><a class="header" href="#one-fully-flexible-segment-of-a-glycan">One Fully Flexible Segment of a Glycan</a></h4>
<p>Let's consider a docking scenario involving two partners, namely a protein (chain A) and a glycan (chain B, consisting of 4 residues), with the latter being fully flexible.
Let's define the protein as the 1st docking partner and the glycan as the 2nd docking partner in .cfg file like so:</p>
<pre><code class="language-toml">molecules = [
  "protein.pdb", # chain A
  "glycan.pdb"   # chain B
  ]
</code></pre>
<p>To be defined as fully flexible, the entire glycan (2nd partner, chain B) should be defined as a single segment, where we will define the starting resiude (<code>sta</code>), ending residue (<code>end</code>) and the chainID/segmentID (<code>seg</code>).
For this, three parameter must be tuned:</p>
<pre><code class="language-toml"># Starting resiude for the flexibility
fle_sta_1 = 1
# Ending resiude for the flexibility
fle_end_1 = 4
# ChaindID/segmentID of the molecule
fle_seg_1 = "B"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflow-configuration-file"><a class="header" href="#workflow-configuration-file">Workflow configuration file</a></h1>
<p>Haddock3 is using a configuration file to define the workflow to be performed.
A workflow is defined in simple configuration text files, similar to the <a href="https://toml.io/en/">TOML</a> format but with extra features.</p>
<p>It basically contains two main parts:</p>
<ul>
<li><a href="/software/haddock3/manual/global_parameters">Global parameters</a>: General parameters to be applied to the workflow, including input molecules and location where to run the docking protocol.</li>
<li><a href="/software/haddock3/manual/modules_parameters">List of modules</a>: Sequence of [module names], defining the sequential order in which each module must be perfromed. Each module has several parameters, that can be defined to fine tune them, or left untouched therefore using default parameters.</li>
</ul>
<p>Examples of workflow configuration files are <a href="https://github.com/haddocking/haddock3/tree/main/examples">available here !</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-parameters"><a class="header" href="#global-parameters">Global parameters</a></h1>
<p>Global parameters must be defined before any use of <code>[modules]</code>, as they will act on every downstream <code>[modules]</code>.</p>
<p>Three types of global parameters are defined:</p>
<ul>
<li><a href="global_parameters.html#mandatory-global-parameters"><strong>Mandatory</strong></a>: These global parameters must be defined for a configuration file to be valid and properly exectued.</li>
<li><a href="global_parameters.html#execution-global-parameters"><strong>Execution</strong></a>: The execution parameters are related to the exeuction mode of haddock3, enabling to either run with local cores, use schedulers (such as slurm or torque) or even spread the workload over multiple nodes using MPI.</li>
<li><a href="global_parameters.html#optional-global-parameters"><strong>Optional</strong></a>: These optional parameters are mostly related to pre and post processing of the results.</li>
</ul>
<h2 id="mandatory-global-parameters"><a class="header" href="#mandatory-global-parameters">Mandatory global parameters</a></h2>
<ul>
<li><code>run_dir</code>: Define directory path where the run will take place.</li>
<li><code>molecules</code>: List of path to input molecules. Note that each input file can be an conformational ensemble of the same molecule. Currently limited to a maximum number of 20 input files.</li>
</ul>
<h2 id="execution-global-parameters"><a class="header" href="#execution-global-parameters">Execution global parameters</a></h2>
<ul>
<li><code>ncores</code>: Maximum number of cores to be used by the haddock3 run. If set to a higher number of cores than the ones available on the system, it will be tuned down and limmited to use all available cores.</li>
<li><code>max_cpus</code>: ??</li>
<li>The <code>mode</code> parameter allows to define the execution mode of haddock3.
<ul>
<li>Using 'local', allows to run haddock3 using the local resources, bound to the operating system</li>
<li>In 'batch' mode, haddock3 will send jobs to the queue of your choice (defined by the <code>batch_type</code> and <code>queue</code> parameters). Note that when using the 'batch' mode, you should also define parameters such as (<code>batch_type</code>, <code>queue</code>, <code>queue_limit</code>, <code>concat</code>)</li>
</ul>
</li>
<li><code>batch_type</code>: defines which batch submission tool must be used, between 'slurm' and 'torque'. Note that this require your computing engine to have access to such kind of queuing system.</li>
<li><code>queue</code>: name of the queue on which the submission should be performed. This allows to target queues that can process shorter / longer jobs. It requires you to have an estimation of how long your job will last.</li>
<li><code>queue_limit</code> = 100  # $min 1 / $max 9999 / $title Number of jobs to submit to the batch system / $short Number of jobs to submit to the batch system / $group execution</li>
<li><code>concat</code> = 1  # $min 1 / $max 9999 / $precision 0 / $title Number of models to produce per job. / $short Multiple models can be calculated within one job / $group execution</li>
<li><code>self_contained</code> = false  # $title Create a self-contained run / $short This option will copy the CNS scripts and executable to the run folder. / $group execution</li>
<li><code>clean</code> = true  # $title Clean the module output files. / $short Clean the module if run succeeds by compressing or removing output files. / $group clean</li>
<li><code>offline</code> = false  # $title Isolate haddock3 from internet. / $short Completely isolate the haddock3 run &amp; results from internet. / $group execution</li>
<li><code>debug</code> = true  # $title Reduce the amount of I/O operations. / $short Reduce the amount of I/O operations. / $group execution</li>
</ul>
<h3 id="local-mode"><a class="header" href="#local-mode">Local mode</a></h3>
<p>The local mode (targeted using the global parameter <code>mode = 'local'</code>), utilize the operating system device to perform the computations.
Setting the <code>ncores</code> parameter allows to tune the number of CPU cores to use during the run.
Note that if you set this value to high compared to your system capabilities, this value will be automatically lowered to the maximum number of cores available on the computer.</p>
<h3 id="batch-mode"><a class="header" href="#batch-mode">Batch mode</a></h3>
<ul>
<li><code>batch_type</code>: defines which batch submission tool must be used, between 'slurm' and 'torque'. Note that this require your computing engine to have access to such kind of queuing system.</li>
<li><code>queue</code>: name of the queue on which the submission should be performed. This allows to target queues that can process shorter / longer jobs. It requires you to have an estimation of how long your job will last.</li>
<li><code>queue_limit</code> = 100  # $min 1 / $max 9999 / $title Number of jobs to submit to the batch system / $short Number of jobs to submit to the batch system / $group execution</li>
<li><code>concat</code> = 1  # $min 1 / $max 9999 / $precision 0 / $title Number of models to produce per job. / $short Multiple models can be calculated within one job / $group execution</li>
</ul>
<h3 id="mpi-mode"><a class="header" href="#mpi-mode">MPI mode</a></h3>
<p>Requires the intallation of the <code>mpi4py</code> python library and <code>OpenMPI</code> to be installed on the operating system.</p>
<h2 id="optional-global-parameters"><a class="header" href="#optional-global-parameters">Optional global parameters</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-in-haddock3"><a class="header" href="#modules-in-haddock3">Modules in haddock3</a></h1>
<p>Haddock3 has this particularity (compared to the pervious HADDOCK2.X versions), that there is not a single static workflow to be processed, but rather a custom one requiring the user to design its own workflows by placing <code>[modules]</code> one after the other, enabling to generate a sequence of events to solve their research question.</p>
<figure align="center">
<img src="/software/haddock3/manual/images/hd3_custom_workflow.png">
</figure>
<p>Various <code>[modules]</code> are available in Haddock3, and they are grouped together by types:</p>
<ul>
<li><a href="modules_parameters.html#topology-modules"><strong>Topology modules</strong></a>: these modules focus in the building of missing atoms and generation of approriate topology files enabling downstream use of molecular dynamics protocols.</li>
<li><a href="modules_parameters.html#sampling-modules"><strong>Sampling modules</strong></a>: dedicated at performing sampling of initial conformations, such as rigidbody docking.</li>
<li><a href="modules_parameters.html#refinement-modules"><strong>Refinement modules</strong></a>: these modules aim at refining interaction interface, using simulated annealing protocol, energy minimisation or molecular dynamics with an explicit solvent shell.</li>
<li><a href="modules_parameters.html#scoring-modules"><strong>Scoring modules</strong></a>: these modules are evaluating provided complexes with dedicated scoring functions, such as the HADDOCK score.</li>
<li><a href="modules_parameters.html#analysis-modules"><strong>Analysis modules</strong></a>: these modules focus on the analysis of docking models. It ranges from the clustering of docking models, to the selection of best ranked ones passing by the evaluation of the models with respect to a reference structure using CAPRI criteria.</li>
</ul>
<figure align="center">
<img src="/software/haddock3/manual/images/list_modules.png">
</figure>
<h2 id="defining-module-parameters"><a class="header" href="#defining-module-parameters">Defining module parameters</a></h2>
<p>To tune modules parameters, you first need to define which <code>[module]</code> you will be using, then add the list of parameters and their new values.</p>
<p>Note that if a parameter is not defined, its default value will be used instead.</p>
<h3 id="tuning-a-module-parameter"><a class="header" href="#tuning-a-module-parameter">Tuning a module parameter</a></h3>
<p>In the configuration file, right after declaring which module you want to use, add the parameters and their new values in the subsequent lines.</p>
<p>Here is a synthetic example:</p>
<pre><code class="language-TOML">[module]
parameter1 = new_value_1
parameter3 = new_value_3
</code></pre>
<p><strong>Note</strong> that you can only define one parameter per line.</p>
<h3 id="definition-of-defaults-parameter-values"><a class="header" href="#definition-of-defaults-parameter-values">Definition of defaults parameter values</a></h3>
<p>Each module is having its own default parameters names and values, set in a file named <code>defaults.yaml</code>.
This is used to set defaults parameters when they are not specified in the configuration file.</p>
<p>The <code>defaults.yaml</code> file is not only used to check if the parameter name exists at execution time, but also as reference to know if the configuration file provided by the use respects the allowed value for a given parameter.</p>
<p><em>Note for <strong>advanced</strong> users</em>: If you feel that the parameter range is not suited for your research, you can always tune the defaults values or the maximum values that can be adopted by this parameter, by editing the <code>defaults.yaml</code> file inside the module directory (at your own risk).</p>
<h2 id="set-of-available-modules"><a class="header" href="#set-of-available-modules">Set of available modules</a></h2>
<p>Below is presented the list of available modules.
For detailed explannation of each modules and their respective parameters, please refere to <a href="https://bonvinlab/haddock3/">the online documentation</a>.
You can also use the <code>haddock3-cfg</code> command line to get information of each module and their parameters (<a href="/software/haddock3/manual/clis#haddock3_cfg">documentation here</a>).</p>
<h3 id="topology-modules"><a class="header" href="#topology-modules">Topology modules</a></h3>
<ul>
<li><a href="/software/haddock3/manual/modules/topology.html#topoaa"><code>[topoaa]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/topology.html#topocg"><code>[topocg]</code></a>: <em>comming soon</em></li>
</ul>
<h3 id="sampling-modules"><a class="header" href="#sampling-modules">Sampling modules</a></h3>
<ul>
<li><a href="/software/haddock3/manual/modules/sampling.html#rigidbody"><code>[rigidbody]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/sampling.html#gdock"><code>[gdock]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/sampling.html#lightdock"><code>[lightdock]</code></a>:</li>
</ul>
<h3 id="refinement-modules"><a class="header" href="#refinement-modules">Refinement modules</a></h3>
<ul>
<li><a href="/software/haddock3/manual/modules/refinements.html#flexref"><code>[flexref]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/refinements.html#emref"><code>[emref]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/refinements.html#mdref"><code>[mdref]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/sampling.html#openmm"><code>[openmm]</code></a>:</li>
</ul>
<h3 id="scoring-modules"><a class="header" href="#scoring-modules">Scoring modules</a></h3>
<ul>
<li>CNS scoring modules:
<ul>
<li><a href="/software/haddock3/manual/modules/scoring.html#emscoring"><code>[emscoring]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/scoring.html#mdscoring"><code>[mdscoring]</code></a>:</li>
</ul>
</li>
<li><a href="/software/haddock3/manual/modules/scoring.html#prodigyprotein"><code>[prodigyprotein]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/scoring.html#prodigyligand"><code>[prodigyligand]</code></a>:</li>
</ul>
<h3 id="analysis-modules"><a class="header" href="#analysis-modules">Analysis modules</a></h3>
<ul>
<li>Analysis:
<ul>
<li><a href="/software/haddock3/manual/modules/analysis.html#caprieval"><code>[caprieval]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/analysis.html#alascan"><code>[alascan]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/analysis.html#contactmap"><code>[contactmap]</code></a>:</li>
</ul>
</li>
<li>Clustering:
<ul>
<li><a href="/software/haddock3/manual/modules/analysis.html#rmsdmatrix"><code>[rmsdmatrix]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/analysis.html#clustrmsd"><code>[clustrmsd]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/analysis.html#clustfcc"><code>[clustfcc]</code></a>:</li>
</ul>
</li>
<li>Selection:
<ul>
<li><a href="/software/haddock3/manual/modules/analysis.html#seletop"><code>[seletop]</code></a>:</li>
<li><a href="/software/haddock3/manual/modules/analysis.html#seletopclusts"><code>[seletopclusts]</code></a>:</li>
</ul>
</li>
</ul>
<h2 id="developping-a-new-module"><a class="header" href="#developping-a-new-module">Developping a new module</a></h2>
<p>Haddock3 is a collaborative project, and researchers can contribute to it, increasing the scope and potential of the Haddock3 suite.
Information on how to contribute and setup a proper development environment are available on the GitHub repository:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/CONTRIBUTING.md"><strong>CONTRIBUTING.md</strong></a>, contains information on how to contribute.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/DEVELOPMENT.md"><strong>DEVELOPMENT.md</strong></a>, contains information on how to set up an adequate development environment.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name"><a class="header" href="#name">Name</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>More than 15 modules are currently available in HADDOCK3, grouped by category:</p>
<ul>
<li><a href="./modules/topology.html">Topology</a></li>
<li><a href="./modules/sampling.html">Sampling</a></li>
<li><a href="./modules/refinement.html">Refinement</a></li>
<li><a href="./modules/scoring.html">Scoring</a></li>
<li><a href="./modules/analysis.html">Analysis</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topology-modules-1"><a class="header" href="#topology-modules-1">Topology modules</a></h1>
<ul>
<li><a href="modules/topology.html#topoaa-module"><code>[topoaa]</code> module</a></li>
</ul>
<h2 id="topoaa-module"><a class="header" href="#topoaa-module"><code>[topoaa]</code> module</a></h2>
<p>The <code>[topoaa]</code> module is dedicated to the generation of CNS compatible
parameters (.param) and topologies (.psf) for each of the input structures.</p>
<p>It will:</p>
<ul>
<li>Detect missing atoms, including hydrogens</li>
<li>Re-build them when missing</li>
<li>Build and write out topologies (psf) and coordinates (pdb) files</li>
</ul>
<p>This module is a pre-requisite to run any downstream modules using CNS.
Having access to parameters and topology is mandatory for any kind
of EM/MD related tasks.
Therefore this is the reason why the module <code>[topoaa]</code> is often used as first
module in a workflow.</p>
<p>Note that for non-standard bio-molecules
(apart from standard amino-acids, some modified ones, DNA, RNA, ions
and carbohydrates ... see <a href="https://wenmr.science.uu.nl/haddock2.4/library">detailed list of supported molecules</a>),
such as small-molecules, parameters and topology must be obtained and provided
by the user, as there is currently no built-in solution to generate
them on the fly.</p>
<p>More information about <code>[topoaa]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/topology/haddock.modules.topology.topoaa.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m topoaa
</code></pre>
<p>Here an example configuration file snapshot of a typical execution of the
<code>[topoaa]</code> module in which a user specifies the protonation state of the histidine
residues:</p>
<pre><code class="language-TOML">...
molecules = [
    "1abc.pdb",
    "2xyz.pdb"
]

[topoaa]
autohis = false
[topoaa.mol1]
nhisd = 0
nhise = 1
hise_1 = 75
[topoaa.mol2]
nhisd = 1
hisd_1 = 76
nhise = 1
hise_1 = 15
...
</code></pre>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sampling-modules-1"><a class="header" href="#sampling-modules-1">Sampling modules</a></h1>
<ul>
<li><a href="modules/sampling.html#rigidbody-module"><code>[rigidbody]</code> module</a></li>
<li><a href="modules/sampling.html#lightdock-module"><code>[lightdock]</code> module</a></li>
<li><a href="modules/sampling.html#gdock-module"><code>[gdock]</code> module</a></li>
</ul>
<h2 id="rigidbody-module"><a class="header" href="#rigidbody-module"><code>[rigidbody]</code> module</a></h2>
<p>The <code>[rigidbody]</code> module does a <strong>randomization of orientations and rigid-body
minimization.</strong> It corresponds to the classical <code>it0</code> step in the HADDOCK2.x
series.</p>
<p>In this module, the interacting partners are treated as rigid bodies, meaning
that all geometrical parameters such as bond lengths, bond angles, and dihedral
angles are frozen. The partners are first separated in space and randomly
rotated around their respective centres of mass. Afterwards, the molecules are
brought together by rigid-body energy minimisation with rotations and
translation as the only degrees of freedom.</p>
<p>The driving force for this energy minimisation is the energy function, which
consists of the intermolecular van der Waals and electrostatic energy terms and
the restraints defined to guide the docking. The restraints are distance-based
and can consist of unambiguous or ambiguous interactions restraints (AIRS). In
<em>ab-initio</em> docking mode those restraints can be automatically defined in
various ways; e.g. between center of masses (CM restraints) or between randomly
selected patches on the surface (random AIRs).</p>
<p>The definition of those restraints is particularly important as they effectively
guide the minimisation process. For example, with a stringent set of AIRs or
unambiguous distance restraints, the solutions of the minimisation will converge
much better and the sampling can be limited. In <em>ab-initio</em> mode, however, very
diverse solutions will be obtained and the sampling should be increased to make
sure to sample enough the possible interaction space.</p>
<details >
<summary style="bold">
<b><i>See animation of the rigidbody protocol:</i></b>
</summary>
<figure align="center">
  <img src="modules/./images/haddock_mini.gif">
</figure>
</details>
<br>
<p>The default HADDOCK scoring function in the rigid-body module is the following:</p>
<p><img src="https://latex.codecogs.com/gif.latex?HS=0.01E_%7Bvdw%7D+1.0E_%7Belec%7D+0.01E_%7Bair%7D+1.0E_%7Bdesolv%7D-0.01BSA" alt="equ" /></p>
<p>For a detailed explanation of the components of the scoring function, please have a look <a href="modules/../haddocking.html#haddock-scoring-function">here</a>.</p>
<p>Throughout the years, the weights of the scoring function have been optimized for various systems. For example, when dealing with small molecules or glycans, it is recommended to scale up the van der Waals term:</p>
<pre><code class="language-TOML">...
[rigidbody]
w_vdw = 1.0
...
</code></pre>
<p><img src="https://latex.codecogs.com/gif.latex?HS_%7Bsmall%7D=1.0E_%7Bvdw%7D+1.0E_%7Belec%7D+0.01E_%7Bair%7D+1.0E_%7Bdesolv%7D-0.01BSA" alt="equ" /></p>
<p>Please refer to the <a href="modules/../docking_scenarios.html">different docking scenarios</a> for more information about how to tune the scoring function for your specific system.</p>
<h4 id="notable-parameters"><a class="header" href="#notable-parameters">Notable parameters</a></h4>
<p>The most important parameters for the <code>[rigidbody]</code> module are:</p>
<ul>
<li><code>ambig_fname</code>: file containing the ambiguous interaction restraints (AIRs)</li>
<li><code>unambig_fname</code>: file containing the unambiguous interaction restraints</li>
<li><code>randremoval</code>: whether or not to activate the random removal of restraints (default: True)</li>
<li><code>cmrest</code>: whether or not to use center of mass restraints (default: False)</li>
<li><code>sampling</code>: number of rigid body models to generate (default: 1000)</li>
</ul>
<p>More information about <code>[rigidbody]</code> parameters can be accessed <a href="modules/bonvinlab.org/haddock3/modules/sampling/haddock.modules.sampling.rigidbody.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m rigidbody
</code></pre>
<p>Here an example configuration file snapshot of a typical execution of the
<code>[rigidbody]</code> module:</p>
<pre><code class="language-TOML">...
molecules = [
    "1abc.pdb",
    "2xyz.pdb"
]

[topoaa]
[rigidbody]
ambig_fname = "ambig.tbl"
unambig_fname = "unambig.tbl"
sampling = 2000 # higher sampling if information is limited
[caprieval]
...
</code></pre>
<hr>
<h2 id="lightdock-module"><a class="header" href="#lightdock-module"><code>[lightdock]</code> module</a></h2>
<h2 id="gdock-module"><a class="header" href="#gdock-module"><code>[gdock]</code> module</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refinements-modules"><a class="header" href="#refinements-modules">Refinements modules</a></h1>
<ul>
<li><a href="modules/refinement.html#emref-module"><code>[emref]</code> module</a></li>
<li><a href="modules/refinement.html#flexref-module"><code>[flexref]</code> module</a></li>
<li><a href="modules/refinement.html#mdref-module"><code>[mdref]</code> module</a></li>
<li><a href="modules/refinement.html#openmm-module"><code>[openmm]</code> module</a></li>
</ul>
<h2 id="emref-module"><a class="header" href="#emref-module"><code>[emref]</code> module</a></h2>
<p>Energy minimization refinement with CNS.</p>
<p>The <code>[emref]</code> module refine the input complexes by energy minimization using
the conjugate gradient method implemented in CNS.</p>
<p>Coordinates of the energy minimized structures are saved, and each
complex is then evaluated using the HADDOCK scoring function.</p>
<p>The default HADDOCK scoring function in the <code>[emref]</code> module is the following:</p>
<p><img src="https://latex.codecogs.com/gif.latex?HS=1.0E_%7Bvdw%7D+0.2E_%7Belec%7D+0.1E_%7Bair%7D+1.0E_%7Bdesolv%7D" alt="equ" /></p>
<h4 id="notable-parameters-1"><a class="header" href="#notable-parameters-1">Notable parameters</a></h4>
<p>The most important parameters for the <code>[emref]</code> module are:</p>
<ul>
<li><code>ambig_fname</code>: file containing the ambiguous interaction restraints (AIRs)</li>
<li><code>unambig_fname</code>: file containing the unambiguous interaction restraints</li>
<li><code>randremoval</code>: whether or not to activate the random removal of restraints (default: True)</li>
<li><code>nemsteps</code>: number of energy minimization steps</li>
</ul>
<p>More information about <code>[emref]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/refinement/haddock.modules.refinement.emref.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m emref
</code></pre>
<hr>
<h2 id="flexref-module"><a class="header" href="#flexref-module"><code>[flexref]</code> module</a></h2>
<p>Flexible refinement with CNS.</p>
<p>The <code>[flexref]</code> module (also known as <code>it1</code> stage in HADDOCK2.X series),
is a semi-flexible simulated annealing (SA) protocol based on molecular
dynamics in torsion angle space.</p>
<p>This semi-flexible SA consists of several stages:</p>
<ul>
<li>High temperature rigid body molecular dynamics</li>
<li>Rigid body SA</li>
<li>Semi-flexible SA with flexible side-chains at the interface</li>
<li>Semi-flexible SA with fully flexible interface (both backbone and side-chains)</li>
</ul>
<p>By default, only the interface regions is treated as flexible. It is automatically
defined based on the intermolecular contacts made. It is also possible to manually
define the semi-flexible regions, and also define fully flexible regions that are
allowed to move throughout the entire protocol from the high temperature rigid
body molecular dynamics on.</p>
<details >
  <summary style="bold">
  <b><i>See animation of flexref protocol:</i></b>
  </summary>
  <figure align="center">
    <img src="modules/./images/haddock_sa.gif">
  </figure>
  </details>
  <br>
<p>The temperature and number of steps for the various stages can be tuned.</p>
<p>The default HADDOCK scoring function in the <code>[flexref]</code> module is the following:</p>
<p><img src="https://latex.codecogs.com/gif.latex?HS=1.0E_%7Bvdw%7D+1.0E_%7Belec%7D+0.1E_%7Bair%7D+1.0E_%7Bdesolv%7D-0.01BSA" alt="equ" /></p>
<h4 id="notable-parameters-2"><a class="header" href="#notable-parameters-2">Notable parameters</a></h4>
<p>The most important parameters for the <code>[flexref]</code> module are:</p>
<ul>
<li><code>ambig_fname</code>: file containing the ambiguous interaction restraints (AIRs)</li>
<li><code>unambig_fname</code>: file containing the unambiguous interaction restraints</li>
</ul>
<!-- TODO: add nfle description -->
<p>More information about <code>[flexref]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/refinement/haddock.modules.refinement.flexref.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m flexref
</code></pre>
<hr>
<h2 id="openmm-module"><a class="header" href="#openmm-module"><code>[openmm]</code> module</a></h2>
<hr>
<h2 id="mdref-module"><a class="header" href="#mdref-module"><code>[mdref]</code> module</a></h2>
<p>Explicit solvent MD refinement with CNS.</p>
<p>The <code>[mdref]</code> module (also known as <code>itw</code> in HADDOCK2.X series), is a small
molecular dynamics simulation, in cartesian space, using explicit solvent.</p>
<p>A layer of solvent (8A for water, 12.5A for DMSO) is generated around
surface residues.</p>
<p>The <code>mdref</code> protocol is composed of 4 sequential steps:</p>
<ul>
<li>Short energy minimization</li>
<li>3 stages of molecular dynamics to reach 300K (at 100, 200 and 300K)</li>
<li>Molecular dynamics at 300K.</li>
<li>3 stages of molecular dynamics, to reach 100K (at 300, 200 and 100K)</li>
</ul>
<details >
 <summary style="bold">
 <b><i>See animation of mdref protocol:</i></b>
 </summary>
 <figure align="center">
   <img src="modules/./images/haddock_water.gif">
 </figure>
 </details>
 <br>
<p>Using this protocol, with default parameters, no spectacular changes are
expected, however, the scoring of the various structures might be improved.</p>
<p>The default HADDOCK scoring function in the <code>[mdref]</code> module is the following:</p>
<p><img src="https://latex.codecogs.com/gif.latex?HS=1.0E_%7Bvdw%7D+0.2E_%7Belec%7D+0.1E_%7Bair%7D+1.0E_%7Bdesolv%7D" alt="equ" /></p>
<h4 id="notable-parameters-3"><a class="header" href="#notable-parameters-3">Notable parameters</a></h4>
<p>The most important parameters for the <code>[mdref]</code> module are:</p>
<ul>
<li><code>ambig_fname</code>: file containing the ambiguous interaction restraints (AIRs)</li>
<li><code>unambig_fname</code>: file containing the unambiguous interaction restraints</li>
<li><code>waterheatsteps</code>: number of MD steps for heating up the system</li>
<li><code>watersteps</code>: number of MD steps at 300K</li>
<li><code>watercoolsteps</code> : number of MD steps for cooling down the system</li>
</ul>
<p>More information about <code>[mdref]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/refinement/haddock.modules.refinement.mdref.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m mdref
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoring-modules-1"><a class="header" href="#scoring-modules-1">Scoring modules</a></h1>
<ul>
<li><a href="modules/scoring.html#emscoring-module"><code>[emscoring]</code> module</a></li>
<li><a href="modules/scoring.html#mdscoring-module"><code>[mdscoring]</code> module</a></li>
<li><a href="modules/scoring.html#prodigy-module">prodigy modules</a>
<ul>
<li><a href="modules/scoring.html#prodigyprotein-module"><code>[prodigyprotein]</code></a></li>
<li><a href="modules/scoring.html#prodigyligand-module"><code>[prodigyligand]</code></a></li>
</ul>
</li>
</ul>
<h2 id="emscoring-module"><a class="header" href="#emscoring-module"><code>[emscoring]</code> module</a></h2>
<p>EM scoring module.</p>
<p>This module performs energy minimization and scoring of the models generated in
the previous step of the workflow. No restraints are applied during this step.</p>
<p>The default HADDOCK scoring function in the <code>[emscoring]</code> module is therefore the following:</p>
<p><img src="https://latex.codecogs.com/gif.latex?HS=1.0E_%7Bvdw%7D+0.2E_%7Belec%7D+0.0E_%7Bair%7D+1.0E_%7Bdesolv%7D" alt="equ" /></p>
<p>For a detailed explanation of the components of the scoring function, please have a look <a href="modules/../haddocking.html#haddock-scoring-function">here</a>.</p>
<h4 id="notable-parameters-4"><a class="header" href="#notable-parameters-4">Notable parameters</a></h4>
<p>The most important parameters for the <code>[emscoring]</code> module are:</p>
<ul>
<li><code>nemsteps</code>: number of energy minimization steps</li>
<li><code>per_interface_scoring</code> : output per interface scores in the PDB header (default: False)</li>
</ul>
<p>More information about <code>[emscoring]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/scoring/haddock.modules.scoring.emscoring.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m emscoring
</code></pre>
<hr>
<h2 id="mdscoring-module"><a class="header" href="#mdscoring-module"><code>[mdscoring]</code> module</a></h2>
<p>MD scoring module.</p>
<p>This module will perform a short MD simulation on the input models and
score them. No restraints are applied during this step.</p>
<p>The same scoring function as in the <code>[emscoring]</code> module is used:</p>
<p><img src="https://latex.codecogs.com/gif.latex?HS=1.0E_%7Bvdw%7D+0.2E_%7Belec%7D+0.0E_%7Bair%7D+1.0E_%7Bdesolv%7D" alt="equ" /></p>
<h4 id="notable-parameters-5"><a class="header" href="#notable-parameters-5">Notable parameters</a></h4>
<p>The most important parameters for the <code>[mdscoring]</code> module are:</p>
<ul>
<li><code>nemsteps</code>: number of energy minimization steps</li>
<li><code>per_interface_scoring</code> : output per interface scores in the PDB header (default: False)</li>
<li><code>waterheatsteps</code>: number of MD steps for heating up the system</li>
<li><code>watersteps</code>: number of MD steps at 300K</li>
<li><code>watercoolsteps</code> : number of MD steps for cooling down the system</li>
</ul>
<p>More information about <code>[mdscoring]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/scoring/haddock.modules.scoring.mdscoring.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m mdscoring
</code></pre>
<h2 id="prodigy-modules"><a class="header" href="#prodigy-modules">prodigy modules</a></h2>
<h3 id="prodigyprotein-module"><a class="header" href="#prodigyprotein-module"><code>[prodigyprotein]</code> module</a></h3>
<h3 id="prodigyligand-module"><a class="header" href="#prodigyligand-module"><code>[prodigyligand]</code> module</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-modules-1"><a class="header" href="#analysis-modules-1">Analysis modules</a></h1>
<ul>
<li><a href="modules/analysis.html#alascan-module"><code>[alascan]</code> module</a></li>
<li><a href="modules/analysis.html#caprieval-module"><code>[caprieval]</code> module</a></li>
<li><a href="modules/analysis.html#clustfcc-module"><code>[clustfcc]</code> module</a></li>
<li><a href="modules/analysis.html#clustrmsd-module"><code>[clustrmsd]</code> module</a></li>
<li><a href="modules/analysis.html#contactmap-module"><code>[contactmap]</code> module</a></li>
<li><a href="modules/analysis.html#ilrmsdmatrix-module"><code>[ilrmsdmatrix]</code> module</a></li>
<li><a href="modules/analysis.html#rmsdmatrix-module"><code>[rmsdmatrix]</code> module</a></li>
<li><a href="modules/analysis.html#seletop-module"><code>[seletop]</code> module</a></li>
<li><a href="modules/analysis.html#seletopclusts-module"><code>[seletopclusts]</code> module</a></li>
</ul>
<h2 id="alascan-module"><a class="header" href="#alascan-module"><code>[alascan]</code> module</a></h2>
<p>HADDOCK3 module for alanine scanning.</p>
<p>This module is responsible for the alanine scan analysis of the models
generated in the previous step of the workflow. For each model, the module
will mutate the interface residues and calculate the energy differences
between the wild type and the mutant, thus providing a measure of the impact
of such mutation.</p>
<p>If cluster information is available, the module will also calculate the
average energy difference for each cluster of models.</p>
<h4 id="notable-parameters-6"><a class="header" href="#notable-parameters-6">Notable parameters</a></h4>
<p>The most important parameters for the <code>[alascan]</code> module are:</p>
<ul>
<li><code>scan_residue</code>: the probe residue used for the scanning (alanine by default)</li>
<li><code>resdic_</code>: list of residues to be mutated (by default all the interface residues). For example, to mutate only residues 2 and 3 of chain A, add resdic_A = [2,3]</li>
<li><code>plot</code>: plot scanning data (default: False)</li>
</ul>
<p>More information about <code>[alascan]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/analysis/haddock.modules.analysis.alascan.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m alascan
</code></pre>
<p>Here an example configuration file snapshot performing glycine scanning on some residues after Molecular Dynamics refinement:</p>
<pre><code class="language-TOML">...
[mdref]
ambig_fname = ambiguous_restraints.tbl
[alascan]
scan_residue = "GLY"
resdic_A = [2,3]
resdic_B = [24,25]

...
</code></pre>
<hr>
<h2 id="caprieval-module"><a class="header" href="#caprieval-module"><code>[caprieval]</code> module</a></h2>
<p>Calculate CAPRI metrics for the input models.</p>
<p>By default the following metrics are calculated:</p>
<ul>
<li>FNAT (fraction of native contacts), namely the fraction of
intermolecular contacts in the docked complex that are also
present in the reference complex.</li>
<li>IRMSD (interface root mean square deviation), namely the RMSD
of the interface of the docked complex with respect
to the reference complex.</li>
<li>LRMSD (ligand root mean square deviation), namely the RMSD of the
ligand of the docked complex with respect to the
reference complex upon superposition of the receptor.</li>
<li>DOCKQ, a measure of the quality of the docked model obtained
by combining FNAT, IRMSD and LRMSD (see
Basu and Wallner 2016,  11 (8), e0161879).</li>
<li>ILRMSD (interface ligand root mean square deviation), the RMSD of the
ligand of the docked complex with respect to the reference complex
upon superposition of the interface of the receptor.</li>
<li>GLOBAL_RMSD, the full RMSD between the reference and the model.</li>
</ul>
<p>The following files are generated:</p>
<ul>
<li><strong>capri_ss.tsv</strong>: a table with the CAPRI metrics for each model.</li>
<li><strong>capri_clt.tsv</strong>: a table with the CAPRI metrics for each cluster of models (if clustering information is available).</li>
</ul>
<p>These files are at the core of the <a href="https://bonvinlab.org/software/haddock3/manual/clis#the-report">analysis report produced by HADDOCK3</a>.</p>
<h4 id="notable-parameters-7"><a class="header" href="#notable-parameters-7">Notable parameters</a></h4>
<p>The most important parameters for the <code>[caprieval]</code> module are:</p>
<ul>
<li><code>allatoms</code>: whether to use all the atoms for the analysis (default: False)</li>
<li><code>reference_fname</code>: the reference structure to compare the models to. It can be the reference structure of the complex or another model (for example, an Alphafold model).</li>
<li><code>receptor_chain</code>: the chain to be considered as the receptor (default: A)</li>
<li><code>ligand_chains</code>: the chains to be considered as the ligands (default: all but the receptor chain)</li>
</ul>
<p>More information about <code>[caprieval]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/analysis/haddock.modules.analysis.caprieval.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m caprieval
</code></pre>
<hr>
<h2 id="clustfcc-module"><a class="header" href="#clustfcc-module"><code>[clustfcc]</code> module</a></h2>
<p>Cluster modules with Fraction of Common Contacts (FCC) similarity.</p>
<p>The module takes the models generated in the previous step and calculates the
contacts between them. Then, the module calculates the FCC matrix and clusters
the models based on the calculated contacts.</p>
<p>For more details please check <em>Rodrigues, J. P. et al. Proteins: Struct. Funct. Bioinform. 80, 1810–1817 (2012)</em>.</p>
<p>Typically, the module is run at the end of the docking protocol to cluster the
models and identify the best clusters. Alternatively, <code>[clustfcc]</code> can also be
used to cluster models generated in a sampling step (such as <code>[rigidbody]</code>) to
perform a <a href="modules/analysis.html#seletopclusts-module">cluster-based selection</a> before proceeding to the next steps (e.g. <a href="modules/./refinement">refinement modules</a>).</p>
<h4 id="notable-parameters-8"><a class="header" href="#notable-parameters-8">Notable parameters</a></h4>
<p>The most important parameters for the <code>[clustfcc]</code> module are:</p>
<ul>
<li><code>clust_cutoff</code>: Minimum fraction of common contacts to be considered in a cluster (default: 0.6). <em>Tip</em> In case you retrieve only one cluster with the default value, try to increase this value.</li>
<li><code>min_population</code>: Threshold employed to exclude clusters with less than this number of members (default: 4)</li>
<li><code>plot_matrix</code>: whether to plot the FCC matrix (default: False)</li>
</ul>
<hr>
<h2 id="clustrmsd-module"><a class="header" href="#clustrmsd-module"><code>[clustrmsd]</code> module</a></h2>
<p>RMSD clustering module.</p>
<p>This module takes in input the <a href="modules/analysis.html#rmsdmatrix-module">RMSD</a> (or the <a href="modules/analysis.html#ilrmsdmatrix-module">ILRMSD</a>) matrix calculated in the previous step and
performs a hierarchical clustering procedure on it, leveraging <a href="https://docs.scipy.org/doc/scipy/reference/cluster.hierarchy.html">scipy routines</a> for this purpose.</p>
<p>Essentially, the procedure amounts at lumping the input models in a
progressively coarser hierarchy of clusters, called the dendrogram.</p>
<p>Typically, the module is run at the end of a protein-small molecule docking protocol to cluster the
models and identify the best clusters. In these workflows, <code>[clustrmsd]</code> is more appropriate than <code>[clustfcc]</code>
as most models will share a consistent fraction of contacts, while still being structurally different.
In <a href="https://www.biorxiv.org/content/10.1101/2024.07.31.605986v1">this paper</a>, we show that, in the context of protein-glycan docking, RMSD clustering performed after
<code>[rigidbody]</code> docking increases the success rate. A detailed tutorial on this specific case is available <a href="https://www.bonvinlab.org/education/HADDOCK3/HADDOCK3-protein-glycan/">here</a>.</p>
<p>Example application of the <code>[clustrmsd]</code> module after rigid-body docking, retrieving 50 clusters:</p>
<pre><code class="language-TOML">...
[rigidbody]
ambig_fname = ambiguous_restraints.tbl
[rmsdmatrix]
resdic_A = [1,2,3,4]
resdic_B = [2,3,4,5]
[clustrmsd]
n_clusters = 50
...
</code></pre>
<h4 id="notable-parameters-9"><a class="header" href="#notable-parameters-9">Notable parameters</a></h4>
<p>The most important parameters for the <code>[clustrmsd]</code> module are:</p>
<ul>
<li><code>linkage</code>: governs the way clusters are merged together in the creation of
the dendrogram</li>
<li><code>criterion</code>: defines the prescription to cut the dendrogram and obtain the
desired clusters</li>
<li><code>n_clusters</code>: number of desired clusters (if <code>criterion</code> is <code>maxclust</code>).</li>
<li><code>clust_cutoff</code>: value of distance that separates distinct clusters (if <code>criterion</code> is
<code>distance</code>)</li>
<li><code>min_population</code> : analogously to the <code>clustfcc</code> module, it is the minimum number
of models that should be present in a cluster to consider it. If criterion is
<code>maxclust</code>, the value is ignored.</li>
</ul>
<ul>
<li><code>plot_matrix</code>: whether to plot the matrix of cluster members (default: False)</li>
</ul>
<hr>
<h2 id="contactmap-module"><a class="header" href="#contactmap-module"><code>[contactmap]</code> module</a></h2>
<p>Compute contacts between chains in complexes.</p>
<p>The <code>[contactmap]</code> module aims at generating heatmaps and chordcharts of
the contacts observed in the input complexes.</p>
<p>If complexes are clustered, the analysis of contacts will be performed
based on all structures from each cluster.</p>
<p><strong>Heatmaps</strong> are describing the probability of contacts (&lt;5A) between two
residues (both intramolecular and intermolecular).</p>
<p><strong>Chordcharts</strong> are describing only intermolecular contacts in circles,
connecting with <em>chords</em> the two residues that are contacting.</p>
<hr>
<h2 id="ilrmsdmatrix-module"><a class="header" href="#ilrmsdmatrix-module"><code>[ilrmsdmatrix]</code> module</a></h2>
<p>Calculate the Interface Ligand Root Mean Square Deviation (ILRMSD) matrix.</p>
<p>This module calculates of the interface-ligand RMSD (ilRMSD) matrix between all
the models generated in the previous step.</p>
<p>As all the pairwise ilRMSD calculations are independent, the module distributes
them over all the available cores in an optimal way.</p>
<p><strong>IMPORTANT</strong>: the module assumes coherent numbering for all the receptor and ligand
chains, as no sequence alignment is performed. The user must ensure that the numbering
is coherent.</p>
<h4 id="notable-parameters-10"><a class="header" href="#notable-parameters-10">Notable parameters</a></h4>
<p>The most important parameters for the <code>[ilrmsdmatrix]</code> module are:</p>
<ul>
<li><code>contact_distance_cutoff</code>: the distance cutoff to consider a contact (default: 5.0)</li>
<li><code>allatoms</code>: whether to use all the atoms for the ILRMSD calculation (default: False)</li>
<li><code>receptor_chain</code>: the chain to be considered as the receptor (default: A)</li>
<li><code>ligand_chains</code>: the chains to be considered as the ligands (default: all but the receptor chain)</li>
</ul>
<p>More information about <code>[ilrmsdmatrix]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/analysis/haddock.modules.analysis.ilrmsdmatrix.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m ilrmsdmatrix
</code></pre>
<p>Here an example configuration file snapshot using ILRMSD-based clustering after flexible refinement:</p>
<pre><code class="language-TOML">...
[flexref]
ambig_fname = ambiguous_restraints.tbl
[ilrmsdmatrix]
[clustrmsd]
clust_cutoff = 2.5
...
</code></pre>
<hr>
<h2 id="rmsdmatrix-module"><a class="header" href="#rmsdmatrix-module"><code>[rmsdmatrix]</code> module</a></h2>
<p>RMSD matrix module.</p>
<p>This module calculates of the RMSD matrix between all the models
generated in the previous step.</p>
<p>As all the pairwise RMSD calculations are independent, the module distributes
them over all the available cores in an optimal way.</p>
<p><strong>IMPORTANT</strong>: the module assumes coherent numbering for all the receptor and ligand
chains, as no sequence alignment is performed. The user must ensure that the numbering
is coherent.</p>
<h4 id="notable-parameters-11"><a class="header" href="#notable-parameters-11">Notable parameters</a></h4>
<ul>
<li><code>allatoms</code>: whether to use all the atoms for the ILRMSD calculation (default: False)</li>
<li><code>resdic_</code> : an expandable parameter to specify which residues must be
considered for the alignment and the RMSD calculation. If there are
two proteins denoted by chain IDs A and B, then the user can operate
such selection in the following way inside the configuration file</li>
</ul>
<pre><code class="language-TOML">resdic_A = [1,2,3,4]
resdic_B = [2,3,4]
</code></pre>
<p>thus telling the module to consider residues from 1 to 4 of chain A and from 2
to 4 of chain B for the alignment and RMSD calculation.</p>
<p>More information about <code>[rmsdmatrix]</code> parameters can be accessed <a href="https://bonvinlab.org/haddock3/modules/analysis/haddock.modules.analysis.rmsdmatrix.html#default-parameters">here</a> or retrieved by running</p>
<pre><code class="language-bash">haddock3-cfg -m rmsdmatrix
</code></pre>
<p>Here an example configuration file snapshot using RMSD-based clustering after energy minimization refinement:</p>
<pre><code class="language-TOML">...
[emref]
ambig_fname = ambiguous_restraints.tbl
[rmsdmatrix]
resdic_A = [1,2,3,4]
resdic_B = [2,3,4]
[clustrmsd]
clust_cutoff = 3.0
...
</code></pre>
<hr>
<h2 id="seletop-module"><a class="header" href="#seletop-module"><code>[seletop]</code> module</a></h2>
<p>Select a number of models.</p>
<p>This module selects a number of models from the input models. By default, the
selection is based on the HADDOCK score of the models.</p>
<p>The number of models to be selected is defined by the parameter <code>select</code>.
In the standard HADDOCK protocol, this number is 200, but this number can be increased
if more models should be refined (which is the recommended approach when limited experimental information is available).</p>
<pre><code class="language-TOML">...
[topoaa]
[rigidbody]
ambig_fname = ambiguous_restraints.tbl
[seletop]
select = 400
...
</code></pre>
<hr>
<h2 id="seletopclusts-module"><a class="header" href="#seletopclusts-module"><code>[seletopclusts]</code> module</a></h2>
<p>Select models from the top clusters.</p>
<p>This module selects a number of models from a number of clusters. The
selection is based on the score of the models within the clusters.</p>
<p>In the standard HADDOCK analysis, the top 4 models of the top 10 clusters
are shown. In case seletopclusts is run after a sampling module, we can
keep a few models from all the clusters to have more diversity at the
refinement stage(s).</p>
<h4 id="notable-parameters-12"><a class="header" href="#notable-parameters-12">Notable parameters</a></h4>
<p>The most important parameters for the <code>[seletopclusts]</code> module are:</p>
<ul>
<li><code>top_cluster</code>: the number of top clusters to consider</li>
<li><code>top_models</code>: the number of top models to select from each cluster</li>
</ul>
<p>Here an example selection of the top 10 models of the top 50 clusters after <code>[rigidbody]</code> docking:</p>
<pre><code class="language-TOML">...
[topoaa]
[rigidbody]
ambig_fname = ambiguous_restraints.tbl
[clustfcc]
[seletopclusts]
top_cluster = 50
top_models = 10
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-docking-scenario"><a class="header" href="#examples-of-docking-scenario">Examples of docking scenario</a></h1>
<p>As creating a new workflow can be complex at the beginning, we are providing a set of pre-defined haddock3 scenarios.
These examples are encompassing a wide range of applications, such as:</p>
<ul>
<li><a href="docking_scenarios.html#protein-protein-docking">Protein-protein docking</a></li>
<li><a href="docking_scenarios.html#protein-peptide-docking">Protein-peptide docking</a></li>
<li><a href="docking_scenarios.html#protein-dna-docking">Protein-DNA docking</a></li>
<li><a href="docking_scenarios.html#antibody-antigen-docking">Antibody-antigen docking</a></li>
<li><a href="docking_scenarios.html#protein-glycan-docking">Protein-glycan docking</a></li>
<li><a href="docking_scenarios.html#small-molecule-docking">Small-molecule docking</a></li>
<li><a href="docking_scenarios.html#refinement-protocols">Complexes refinement protocols</a></li>
<li><a href="docking_scenarios.html#cyclic-peptide">Building cyclic peptide</a></li>
<li><a href="docking_scenarios.html#scoring-workflow">Scoring workflow</a></li>
<li><a href="docking_scenarios.html#analysis-scenario">Analysis pipelines</a></li>
</ul>
<p>Alternatively, up-to-date examples can also be found:</p>
<ul>
<li>in your local installation of haddock3: <code>haddock3/examples/</code>.</li>
<li>online, on our <a href="https://github.com/haddocking/haddock3/tree/main/examples">GitHub repository <code>haddock3/examples/</code></a>.</li>
</ul>
<p>Please note the extension scheme we are using in the provided configuration file examples:</p>
<ul>
<li><strong>*-full.cfg</strong>: we are using the <code>*-full.cfg</code> suffix on protocols that have proper sampling, and therefore could be used in production. These are nice baseline workflow with appropriate parameters, but will obviously require more time to terminate the run. Examples making use of MPI are also provided in some cases, together with an associated job file that should be submitted to the slurm batch system (<strong>*-full-mpi.cfg</strong> and <strong>*-full-mpi.job</strong>). Make sure to adapt the full config files to your own system.</li>
<li><strong>*-test.cfg</strong>: we are using the <code>*-test.cfg</code> suffix on protocols that have low sampling, allowing for fast test of the functionalities present in the workflow. Of note, on a daily basis, we are running most of the <code>*-test.cfg</code> configuration files to make sure the <code>main</code> branch of haddock3 is functional.</li>
</ul>
<h2 id="protein-protein-docking"><a class="header" href="#protein-protein-docking">Protein-protein docking</a></h2>
<h3 id="two-body-docking"><a class="header" href="#two-body-docking">Two body docking</a></h3>
<p>Here we provide various examples using the standard HADDOCK2.X workflows, now well established and banchmarked, using <code>[rigidbody]</code> docking (former <em>it0</em>), followed by flexible refinement in torsional angle space with the <code>[flexref]</code> module (former <em>it1</em>), with a final refinement step using molecular dynamics simulation in an explicit solvent shell (<code>[mdref]</code>, former <em>itw</em>) or an energy minimisation step (<code>[emref]</code>).
The final set of complexes is later clustered using Fraction of Common Contacts clustering (FCC) with the <code>[clustfcc]</code> module.</p>
<p>The protein-protein docking example makes use of the NMR chemical shift perturbation data providing information on the residues of binding site to guide the docking.
The NMR-identified residues are defined as active with their surface neighbors as passive (the corresponding AIRs are defined in the <a href="../examples/docking-protein-protein/data/e2a-hpr_air.tbl">e2a-hpr_air.tbl</a> file in the <code>data</code> directory).
This system is the same as described in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-protein-protein-basic/">HADDOCK2.4 basic protein-protein docking tutorial</a>.
For the second molecule (HPR), an ensemble of 10 conformations (taken from the NMR solution structure of this protein) is used as starting point for the docking.
Refer to above tutorial for more details about the system and restraints.</p>
<p>Here are some examples:</p>
<ul>
<li>with molecular dynamics simulation in an explicit solvent shell -&gt; <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-mdref-full.cfg">docking-protein-protein-mdref-full.cfg</a></li>
<li>with an energy minimisation step only: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-full.cfg">docking-protein-protein-full.cfg</a></li>
</ul>
<p>Due to the flexibility allowed by haddock3, a clustering step can now be performed right after the rigidbody sampling, allowing to capture a higher structural diversity by not only relying on the HADDOCK scoring function to select the top ranked models.
Here is an example with an intermediate clustering step after the <code>[rigidbody]</code> docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-cltsel-full.cfg">docking-protein-protein-cltsel-full.cfg</a>.</p>
<h3 id="symmetrical-homotrimer-docking"><a class="header" href="#symmetrical-homotrimer-docking">Symmetrical homotrimer docking</a></h3>
<p>The homotimer docking scenario, <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-homotrimer">available here</a>, is first performing <code>[rigidbody]</code> docking, followed by <code>[flexref]</code> refinement and a final <code>[emref]</code> energy minimisation step of the complexe.
It also makes use of two types of symmetry restraints:</p>
<ul>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#non-crystallographic-symmetry">non-crystallographic symmetry restraints</a>: to make sure the three chains are having the same conformation.</li>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#rotational-symmetry">C3 symmetry restraints</a>: to obtain solutions respecting the C3 symmetry.</li>
</ul>
<h3 id="multiple-ambiguous-files"><a class="header" href="#multiple-ambiguous-files">Multiple ambiguous files</a></h3>
<p>In some case, restraints could be obtained from various sources; different experimental methods or multiple predictions.
In this case, knowing which AIR file will be leading to the correct complex can only be assessed once the docking is performed, and maybe some of them will lead to the same solutions.</p>
<p>It is possible to input multiple ambiguous restraints files in a single <code>.tgz</code> archive.
When providing the kind of input, each sampled docking solution will use an other AIR file contained in the archive.
A particular parameter should later be set in the downstream protocol, <code>previous_ambig = true</code>, enabling to use the AIR file used at the <code>[rigidbody]</code> stage and so on.</p>
<p>An example is <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig">provided here</a>.</p>
<p>This example shows how to use HADDOCK3 when several restraint files are available.
It is built upon the results obtained running <a href="https://github.com/haddocking/arctic3d">arctic3d</a> on two proteins forming the complex <code>2GAF</code>.
The presence of multiple interfaces in both structures allows to define several <code>.tbl</code> ambiguous restraint files to be used in the calculations.
At first, these files must be compressed in a <code>.tbl.tgz</code> archive.
During the workflow, the Haddock3 machinery unzips the archive and evenly assigns each <code>.tbl</code> file to a number of models to be generated.
Even if only one sixth of the restraint files contain reasonable information on the interface, Haddock3 is still able to retrieve good docking models in the best-scoring positions.</p>
<p><strong>Note</strong> how the information about restraint files is propagated during the workflow (<code>previous_ambig = true</code> for <code>flexref</code> and <code>emref</code> modules), so that each model is always refined with its corresponding <code>.tbl</code> file.</p>
<p>Importantly, in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig/docking-multiple-tbls-clt-full.cfg">docking-multiple-tbls-clt-full.cfg</a> example the clustering is performed right after the <code>rigidbody</code> module, so as to lump together solutions resulting from the application of different sets of restraints.</p>
<p>The <code>caprieval</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-peptide-docking"><a class="header" href="#protein-peptide-docking">Protein Peptide docking</a></h2>
<p>The protein-peptide docking example makes use of the knowledge of the binding site on the protein to guide the docking.
The active site residues are defined as active and the peptide as passive (the corresponding AIRs are defined in the <code>ambig.tbl</code> file in the <code>data</code> directory).
This example follows the protocol described in our protein-peptide docking article (<a href="https://dx.plos.org/10.1371/journal.pone.0058769">Trellet et. al. PLoS ONE 8, e58769 (2013)</a>).
For the peptide, an ensemble of three conformations (alpha-helix, polyproline-II and extended) is provided as starting point for the docking.
Those were built using PyMol (instructions on how to do that can be found <a href="https://www.bonvinlab.org/education/molmod_online/simulation/#preparing-the-system">here</a>).</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement and energy minimisation of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-full.cfg">docking-protein-peptide-full.cfg</a></li>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement followed by a final refinement in explicit solvent (water) of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-mdref-full.cfg">docking-protein-peptide-mdref-full.cfg</a></li>
<li>3000 rigidbody docking models, FCC clustering and selection of max 20 models per cluster followed by flexible refinement and energy minimisation (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-cltsel-full.cfg">docking-protein-peptide-cltsel-full.cfg</a>).</li>
</ul>
<p><strong>Note</strong> how the peptide is defined as fully flexible for the refinement phase in <code>[flexref]</code> (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>) and dihedral angle restraints are automatically defined to maintain secondary structure elements (<code>ssdihed = "alphabeta"</code>)</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-dna-docking"><a class="header" href="#protein-dna-docking">Protein DNA docking</a></h2>
<p>Haddock3 can also deal with nucleic acids, such as DNA and RNA molecules.
In such senario, various important parameters must be set, allowing to:</p>
<ul>
<li>keep the dielectric constant constant: <code>dielec = "cdie"</code></li>
<li>set the dielectric constant to an higher value: <code>epsilon = 78</code></li>
<li>remove the desolvation term from the scroing function, otherwise having a too strong influence due to the phosphate groups: <code>w_desolv = 0</code>.</li>
<li>automatically generate restraints allowing to keep the double stranded DNA 3' and 5' ends together: <code>dnarest_on = true</code>.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li>using a final energy minimisation step: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-full.cfg">docking-protein-DNA-full.cfg</a></li>
<li>refining the interface using MD in a solvent shell: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-mdref-full.cfg">docking-protein-DNA-mdref-full.cfg</a></li>
<li>with an intermediate clustering step after rigidbody docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cltsel-full.cfg">docking-protein-DNA-cltsel-full.cfg</a></li>
<li>using center of mass restraints instead of ambiguous restraints extracted from the literature: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cmrest-test.cfg">docking-protein-DNA-cmrest-test.cfg</a></li>
</ul>
<h2 id="antibody-antigen-docking"><a class="header" href="#antibody-antigen-docking">Antibody-antigen docking</a></h2>
<p>Multiple antibody - antigen docking configuration files are <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-antibody-antigen">available here</a>.
They encompass various aspects of docking, mainly related to the information available to guide the docking:</p>
<ul>
<li><a href="docking_scenarios.html#no-information-about-the-paratop">No information about the paratop</a>: No information is known about the paratop, therefore tagetting the entire surface accessible resiude of the antigen.</li>
<li><a href="docking_scenarios.html#nmr-informed-paratop">Experimental knowledge of the paratop resiudes</a>: NMR data was aquired and allowed to obtain information about residues involded in the binding on the antigen side.</li>
</ul>
<h3 id="no-information-about-the-paratop"><a class="header" href="#no-information-about-the-paratop">No information about the paratop</a></h3>
<p>When no information is known about the paratop on the antigen side, our only solution is to rely on the CDR loops of the antibody, as we know that a least a subset of the resiudes on those loops will be part of the interaction.
Two appoaches can then be used:</p>
<ul>
<li>One where a distance restraints file is generated, where CDR loops resiudes are targetting all surface residues on the antigen side.</li>
<li>The other one defining random distance restraints between the CDR loops and random patches on the antigen side.</li>
</ul>
<h4 id="using-surface-accessible-resiudes"><a class="header" href="#using-surface-accessible-resiudes">Using surface accessible resiudes</a></h4>
<p>Generating restraints guiding the antibody CDR loops towards surface resiudes on the antigen side is a solution that will sample the entire surface of the antigen. For this, two major information must be extracted:</p>
<ul>
<li>The residue indices of the antibody CDR loops: can be predicted using bioinformatics tools such as <a href="https://wenmr.science.uu.nl/proabc2">proABC2</a>.</li>
<li>The surface residue indices of the antigen: can be predicted computed using <code>haddock3-restraints calc_accessibility antigen.pdb</code>.</li>
</ul>
<p>Defining the CDR loops as <code>active</code> residues and all surface residues on the antigen as <code>passive</code>, we can create an ambiguous restraints file <code>ambig.tbl</code>, that will guide the docking sampling the entire surface of the antigen while making sure the CDR loops are interacting. For more details on how to generate restraints, please refere to the <a href="/software/haddock3/manual/restraints_cli.html"><code>haddock3-restraints</code> documention</a>.</p>
<p>For such kind of naive approach, increasing the sampling at the <code>[rigidbody]</code> level is important.</p>
<p>Various examples are available:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full.cfg">docking-antibody-antigen-CDR-accessible-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-clt-full.cfg">docking-antibody-antigen-CDR-accessible-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.cfg">docking-antibody-antigen-CDR-accessible-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.job">docking-antibody-antigen-CDR-accessible-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h4 id="using-random-distance-restraints"><a class="header" href="#using-random-distance-restraints">Using random distance restraints</a></h4>
<p>An other alternative for pseudo-naive antibody-antigen docking is to define random restraints.
In this case, we will define segments on the antibody CDR loops to limit the search on the antibody side, and do not provide any definition on the antigen side.
By doing so, random residues on the CDR loops will be restraints to random patches on the antigen surface accessible residues.
This is performed in the <code>[rigidbody]</code> module by:</p>
<ul>
<li>turning on the <code>randair</code> parameter</li>
<li>defining 6 segments to define what are the CDR loops residues</li>
<li>increasing the sampling</li>
</ul>
<pre><code class="language-toml"># Turning on the randair parameter
randair = true
# About to define 6 random segments for the antigen
nrair_1 = 6
# Start and end of first CDR loop
rair_sta_1_1 = 26
rair_end_1_1 = 32
# Start and end of second CDR loop
rair_sta_1_2 = 55
rair_end_1_2 = 57
# Start and end of third CDR loop
rair_sta_1_3 = 101
rair_end_1_3 = 108
# Start and end of fourth CDR loop
rair_sta_1_4 = 146
rair_end_1_4 = 152
# Start and end of fifth CDR loop
rair_sta_1_5 = 170
rair_end_1_5 = 172
# Start and end of sixth CDR loop
rair_sta_1_6 = 212
rair_end_1_6 = 215

# Increasing the sampling
sampling = 10000

###
# ....
# Insert other modules here if you want
# ....
###

[flexref]
contactairs = true
</code></pre>
<p>In this case, no AIR restraints files can be accepted (nor <code>unambig</code> and <code>hbond</code> ones).</p>
<p>Note that after random air definition, we will use <code>contactairs = true</code> in later stage modules such as <code>[flexref]</code> and <code>[emref]</code>, generating restraints based on resiudes already in contact, ensuring the complex will not detach.</p>
<p>Here are some examples:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full.cfg">docking-antibody-antigen-ranairCDR-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-clt-full.cfg">docking-antibody-antigen-ranairCDR-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.cfg">docking-antibody-antigen-ranairCDR-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.job">docking-antibody-antigen-ranairCDR-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h3 id="nmr-informed-paratop"><a class="header" href="#nmr-informed-paratop">NMR informed paratop</a></h3>
<p>An ideal case would be to have information about the antigen paratop.
Coming from experimental methods or bioinformatic predictions, this information is extremly valuable as it will focus the  search by sampling comformations near key residues involed in the interaction.
By generating a dedicated ambiguous restraint file (<code>ambig-CDR-NMR-CSP.tbl</code>), only antigen CDR residues and few residues on the antigen side will be interacting.</p>
<p>Here is an  example: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-NMR-CSP-full.cfg">docking-antibody-antigen-CDR-NMR-CSP-full.cfg</a></p>
<h2 id="protein-glycan-docking"><a class="header" href="#protein-glycan-docking">Protein glycan docking</a></h2>
<p>A protein-glycan docking example making use of the knowledge of the binding site on the protein to guide the docking. The conformation of the glycan has been obtained from the <a href="http://glycam.org/">GLYCAM webserver</a>, while the structure of the protein is taken from the PDB in its unbound form. In the proposed workflows, a clustering step is always performed after initial docking stage, so as to increase the diversity of the ensemble of models to be refined.</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-glycan/docking-protein-glycan-full.cfg">docking-protein-glycan-full.cfg</a>: 1000 rigidbody docking models, RMSD clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final RMSD clustering for cluster-based scoring. The RMSD clustering assumes a good knowledge of the interface, as the user has to define the residues involved in the binding site by means of the resdic_ parameter.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-protein-glycan-ilrmsd-full.cfg">docking-protein-glycan-ilrmsd-full.cfg</a>: 1000 rigidbody docking models, interface-ligand-RMSD (<code>ilrmsd</code>) clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final ilRMSD clustering for cluster-based scoring. The interface-ligand-RMSD clustering is a more general approach, as it does not require the user to define the residues involved in the binding site. The interface is automatically defined by the residues involved in the protein-glycan interaction in the input models.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-flexref-protein-glycan-full.cfg">docking-flexref-protein-glycan-full.cfg</a>: 500 flexible docking runs + final RMSD clustering for cluster-based scoring. In this case, the rigidbody docking is skipped and the docking is performed at the flexible refinement level. In this case the flexible refinement has more steps than usual (<code>mdsteps_rigid = 5000</code>, <code>mdsteps_cool1 = 5000</code> and so on) and the glycan is defined as fully flexible (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>).</li>
</ul>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>), as in the <a href="docking_scenarios.html#small-molecule-docking">protein-ligand example</a>.</p>
<h2 id="small-molecule-docking"><a class="header" href="#small-molecule-docking">Small molecule docking</a></h2>
<p>Small molecule docking can also be performed using haddock3.
It requires the use of custom topology and paramter files for the ligand, as it they are out of the scope of the OPLS force-field.
To generate them, please refere to the section: <a href="/software/haddock3/manual/structure_requirements.html#How-to-generate-topology-and-parameters-for-my-ligand">How to generate topology and parameters for my ligand ?</a></p>
<p>Two protocols have been proposed:</p>
<ul>
<li><a href="docking_scenarios.html#template-based-shape-docking">By homology docking using experimental template</a></li>
<li><a href="docking_scenarios.html#using-binding-site-definition">By defining a binding site</a></li>
</ul>
<h3 id="template-based-shape-docking"><a class="header" href="#template-based-shape-docking">Template-based shape docking</a></h3>
<p>The use of experimental structure as template for docking have been shown to provide helpful information to guide the conformation of the ligand towards both the binding site and an adequate conformation (see: <a href="https://doi.org/10.1007/s10822-019-00244-6">D3R Grand Challenge 4</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0022283624003139">@TOME 3.0</a> and <a href="">CAPRI16 (soon)</a>)</p>
<p>A protein-ligand docking example making use of the knowledge of a template ligand (a ligand similar to the ligand we want to dock and bind to the same receptor).
The template ligand information is used in the form of shape consisting of dummy beads and positioned within the binding site to which distance restraints are defined.
More details about the method and the performance of the protocol when benchmarked on a fully unbound dataset
can be seen in our freely available <a href="https://pubs.acs.org/doi/full/10.1021/acs.jcim.1c00796">paper on JCIM</a>.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule HADDOCK2.4 tutorial</a>, during the docking and refinement the protein and the shape are kept in their original positions (see the <code>mol_fix_origin_X</code> parameters in the config file) and ambiguous distance restraints between the ligand and the shape beads are defined (the corresponding AIRs are defined in the <code>shape-restraints-from-shape-1.tbl</code> file in the <code>data</code> directory).
This is effectively a three body docking.
For the ligand an ensemble of 10 different conformations is provided as starting point for the docking (<code>ligand-ensemble.pdb</code> in the <code>data</code> directory).
Please refer to our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule tutorial</a> for information on how to generate such an ensemble.</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand-shape/docking-protein-ligand-shape-full.cfg">docking-protein-ligand-shape-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models with the protein and shape kept in their origin position, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>).
To allow the ligand to penetrate better into the binding site the intermolecular energy components are scaled down during the rigidbody docking phase (<code>inter_rigid = 0.001</code>).
As for the protein-ligand example, parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h3 id="using-binding-site-definition"><a class="header" href="#using-binding-site-definition">Using binding site definition</a></h3>
<p>A protein-ligand docking example making use of the knowledge of the binding site on the protein to guide the docking.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-binding-sites/">protein-ligand HADDOCK2.4 tutorial</a>, in the rigidbody docking phase all residues of the binding site are defined as active to draw the ligand into it (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-active-rigidbody.tbl">ambig-active-rigidbody.tbl</a> file in the <code>data</code> directory).
For the flexible refinement only the ligand is defined as active and the binding site as passive to allow the ligand to explore the binding site (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-passive.tbl">ambig-passive.tbl</a> file in the <code>data</code> directory).</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/docking-protein-ligand-full.cfg">docking-protein-ligand-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the <code>[rigidbody]</code> docking models (<code>w_vdw = 1.0</code>) and the skipping of the high temperature first two stages of the simulated annealing protocol during the <code>[flexref]</code> refinement (<code>mdsteps_rigid = 0</code> and <code>mdsteps_cool1 = 0</code>).
Parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="refinement-protocols"><a class="header" href="#refinement-protocols">Refinement protocols</a></h2>
<p>All refinements examples can be found <a href="https://github.com/haddocking/haddock3/tree/main/examples/refine-complex">here</a>.</p>
<h3 id="short-molecular-dynamics-symulation-in-explicit-solvent"><a class="header" href="#short-molecular-dynamics-symulation-in-explicit-solvent">Short molecular dynamics symulation in explicit solvent</a></h3>
<p>This example illustrates the refinement of a complex.
In this case (workflow <code>refine-complex-test.cfg</code>) the molecules are kept in their original positions and the complex is subjected to a short flexible refinement in explicit solvent with the <code>[mdref]</code> module.
The same complex as for the <code>docking-protein-protein</code> example is used.
The molecules are defined separately in the config file (and could consist each of an ensemble, provided the two ensembles have exactly the same number of models).</p>
<p>In this example all parameters are left to their default settings, except for manually defining the histidines' protonation states and setting the <code>sampling_factor</code> to 10, which means that from each starting complex 10 models will be generated with different random seeds for initiating the molecular dynamics phase.</p>
<p>The <code>caprieval</code> module is called at the end to assess the quality of the models with respect to the known reference structure.</p>
<p>Here is an example:</p>
<pre><code class="language-toml">run_dir = "mdref_complex_5replicas"
molecules = "model.pdb"

[topoaa]
autohis = false
[topoaa.mol1]
nhisd = 0
nhise = 1
hise_1 = 75
[topoaa.mol2]
nhisd = 1
hisd_1 = 76
nhise = 1
hise_1 = 15

[mdref]
# Setting sampling factor to 10 will generate 
# 10 replicas with different initial seeds to set the velocities
sampling_factor = 10
</code></pre>
<p><a href="https://github.com/haddocking/haddock3/blob/main/examples/refine-complex/refine-complex-test.cfg">Here is a full example</a> with provided input file and also using an experimental reference to track the evolution of the refinement.</p>
<h3 id="openmm-md-simulation"><a class="header" href="#openmm-md-simulation">OpenMM MD simulation</a></h3>
<p>The OpenMM molecular dynamics engine has its own module in haddock3, where users can setup short molecular dynamics similation using openMM.
It can be used as a refinement module, in implicit or explicit solvent.
Note that the use of the <code>[openmm]</code> module is a thirdparty module that requires its own installation procedure that is not part of the standard haddock3 suite.</p>
<h4 id="as-quality-assessment-of-a-docking-pose"><a class="header" href="#as-quality-assessment-of-a-docking-pose">As quality assessment of a docking pose</a></h4>
<p>Using the <code>[openmm]</code> module allows to run unbiased molecular dynamics simulations in explicit solvent.
Previous work of <a href="https://doi.org/10.1021/acs.jctc.1c00336">Z. Jandova, <em>et al.</em>, <em>J. Chem. Theo. and Comp.</em> 2021</a>, showed that near-native complexes have less deviation from their input structure after 10 ns of simulation.
Setting up such kind of experiment with haddock3 is extremely easy, as it simply requires to use the <code>[openmm]</code> module with an input complex model, followed by the <code>[caprieval]</code> using the same input complex as reference structure.
This will allow to track how far from the original pose the final frame reached.</p>
<p>Here is an example configuration file:</p>
<pre><code class="language-toml"># General parameters
run_dir = "md_to_the_rescue"
molecules = "model_1.pdb"

[topoaa]
[openmm]
# Define the timesteps
timestep_ps = 0.002  # default parameter
# Increase the simulation timesteps (500000 * 0.002 = 10 ns)
simulation_timesteps = 5000000
# Save 100 intermediate frames
save_intermediate = 100
# Define force-field
forcefield = 'amber14-all.xml'  # default parameter
# Use TIP3P explicit water model
explicit_solvent_model = 'amber14/tip3p.xml'  # default parameter
# Keep HBonds rigid
constraints = 'HBonds'  # default parameter
# Generate a final ensemble composed of all the frames
generate_ensemble = true  # default parameter

[topoaa]
# Compare the generated ensemble with the initial model
[caprieval]
reference_fname = "model_1.pdb"
sort_by = "dockq"
</code></pre>
<p>This protocol has been used during CAPRI round 55 for target 231, to validate the docking poses of the FLAG-peptide on the antibody (see: <a href="https://www.biorxiv.org/content/10.1101/2024.09.16.613212v2">CAPRI rounds 47-55 paper</a>).</p>
<h2 id="peptide-cyclisation"><a class="header" href="#peptide-cyclisation">Peptide cyclisation</a></h2>
<p>The generation of cyclic peptides usually involve the formation of a disulphide bridge between two cysteins or the formation of a peptide bond between the N-terminus and C-terminus residues.
This can be performed by haddock3 in a two step process, by first generating restraints between the two resiudes involved to induce a pre-cyclic conformation, and then re-generating the topology with an increased range of chemical bond detection (tuning <code>cyclicpept_dist</code>, <code>disulphide_dist</code> and turning on the <code>cyclicpept</code> parameters in <code>[topoaa]</code> module), therefore detecting and creating the covalent cyclic bond and refining again.</p>
<p>Protocol described in: <a href="https://doi.org/10.1021/acs.jctc.2c00075">https://doi.org/10.1021/acs.jctc.2c00075</a></p>
<p>Two examples are provided in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/"><code>examples/peptide-cyclisation/</code></a>:</p>
<ul>
<li>1SFI, a 14 residue cyclic peptide with both backbone and disulphide bridge cyclisation: <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/cyclise-peptide-full.cfg">cyclise-peptide-full.cfg</a></li>
<li>3WNE, a 6 residue backbone cyclic peptide</li>
</ul>
<p>The input peptide was generated using PyMOL, using beta and polyproline initial conformation (available in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb"><code>examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb</code></a>).</p>
<p>The first step is using the <code>[flexref]</code> module, setting the <code>unambig_fname</code> to <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_unambig.tbl">1sfi_unambig.tbl</a> to drive both the backbone and disulphide bridge cyclisation, giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters), increasing the number steps by a factor 10 to allow for more flexible refinement (<code>mdsteps_rigid</code>, <code>mdsteps_cool1</code>, <code>mdsteps_cool2</code>, <code>mdsteps_cool3</code>), turning off the electrostatic <code>elecflag = false</code>. By setting <code>sampling_factor = 200</code>, we will generate 200 replicas with different initial seeds for each of the input conformations (in this case 2).
This is followed by an short molecular dynamics simulation in explicit solvent <code>[mdref]</code>, also giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters).</p>
<p>A RMSD clustering step is perfomed using <code>[rmsdmatrix]</code>, <code>[clustrmsd]</code> (with <code>criterion="maxclust"</code> and <code>n_clusters=50</code>) to generate a subset of 50 clusters, finalized by <code>[seletopclusts]</code> module setting <code>top_models=1</code>, to only extract one single model per clusters.</p>
<p><code>[topoaa]</code> module is then used again to re-generate the topology. In this case the three <strong>important</strong> parameters (<code>cyclicpept_dist</code>, <code>disulphide_dist</code>, and <code>cyclicpept</code>) are set, allowing for the detection of the disulphide bridge and peptide bond at higher distance, therefore generating the proper cyclicised topology.</p>
<p>A second round of <code>[emref]</code>, <code>[flexref]</code> and <code>[mdref]</code> is then performed, allowing to reduce the length of the newly formed chemical bonds and optimise the cyclic peptide conformation.</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the conformation of the peptide with respect to the known reference structure. Note that in this case, only the <code>global_rmsd</code> value is computed, as the structure is not a complex.</p>
<h2 id="scoring-workflow"><a class="header" href="#scoring-workflow">Scoring workflow</a></h2>
<h2 id="defining-a-haddock3-configuration-file"><a class="header" href="#defining-a-haddock3-configuration-file">Defining a haddock3 configuration file</a></h2>
<p>This example illustrates the use of Haddock3 for scoring purposes.
In contrast to HADDOCK2.X, Haddock3 can score a heterogenous set of complexes within one run/workflow.
In this example, four different types of complexes are scored within the same workflow:</p>
<ul>
<li>an ensemble of 5 models taken from CAPRI Target161</li>
<li>a protein-DNA complex (model taken from our protein-DNA docking example)</li>
<li>two models of a protein-protein complex (taken from our protein-protein docking example)</li>
<li>a homotrimer model (taken from our protein-homotrimer docking examples)</li>
</ul>
<p>Three scoring workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/emscoring-test.cfg">emscoring-test.cfg</a>: Only a short energy minimisation is performed on each model using <code>[emref]</code> module.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/mdscoring-test.cfg">mdscoring-test.cfg</a>: A short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module. In that case contact AIRs (<code>contactairs = true</code>), dihedral angle restraints on secondary structure element (<code>ssdihed = alphabeta</code>) and DNA restraints (<code>dnarest_on = true</code>) are automatically defined.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/capri-scoring-test.cfg">capri-scoring-test.cfg</a>: An example scoring pipeline using in the CAPRI55 competition, where energy minimisation ()<code>[emref]</code>) is followed by FCC clustering (<code>[clustfcc]</code>) and selection of the top 2 models per cluster (<code>[seletopclusts]</code> with <code>top_models = 2</code>). Then a short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module and the models are clustered again.</li>
</ul>
<p>The model listings with their associated HADDOCK scores can be found in a <code>.tsv</code> file in the stage <code>01_xxx</code> directory of the respective runs.</p>
<h3 id="using-scoring-command-line"><a class="header" href="#using-scoring-command-line">Using scoring command line</a></h3>
<p>Haddock3 also contain a simple command line interface that allows you to score a single pdb file.
To do so, just run:</p>
<pre><code class="language-bash">haddock3-score complex.pdb
</code></pre>
<p>This command is a short-cut to the following parameter file, and therefore can be really handy, as it simplify a lot the procedure, but is limitted to the scoring of a single model.</p>
<pre><code class="language-toml">run_dir = "tmp_score"
molecules = "complex.pdb"
[topoaa]
[emscoring]
</code></pre>
<p>For more details on the <code>haddock3-score</code> CLI, please refere to <a href="/software/haddock3/module/clis.html#haddock3-score">this section</a>.</p>
<h2 id="analysis-scenario"><a class="header" href="#analysis-scenario">Analysis scenario</a></h2>
<p>The addition and inclusion of analysis modules in haddock3 is one of its major new strength, as it allows to perform various kind of analysis directly during the workflow.
For the complete list of analysis modules and their capabilities, please refere to the <a href="software/haddock3/manual/modules/analysis.html">Analysis Modules section</a>.</p>
<h3 id="comparison-to-a-reference-structure"><a class="header" href="#comparison-to-a-reference-structure">Comparison to a reference structure</a></h3>
<p>The <code>[caprieval]</code> module is dedicated to the computation of the CAPRI metrics (rmsd, interface-rmsd, ligand-rmsd, interface-ligand rmsd and dockq) on a set of input models. A reference structure can be provided using the <code>reference_fname</code> parameter. If this parameter is not defined, the best scoring model will be used as reference.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/topoaa-caprieval-test.cfg">topoaa-caprieval-test.cfg</a>.</p>
<h3 id="hot-spot-detection"><a class="header" href="#hot-spot-detection">Hot spot detection</a></h3>
<p>The analysis of hot-spots and key residues involved in the interaction between two chain can be of valuable information for mutagenesis or design purposes.
The <code>[alascan]</code> module is designed to perform point mutation of residues at the interface of a complex, and evaluate the difference in HADDOCK score with respect to the original input complex. It also splits the scoring function in its various components and generate an interactive graph allowing for a visual representation of the scanned resiudes contributions.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/alascan-test.cfg">alascan-test.cfg</a>.</p>
<h3 id="generation-of-contact-maps"><a class="header" href="#generation-of-contact-maps">Generation of contact maps</a></h3>
<p>While HADDOCK is producing 3D atomistic models, having the opportunity to have a 2D representation of the complexes can allow to understand at the sequence level the contacts involved in the compelex.
The <code>[contactmap]</code> module is specially designed to produce interactive plots describing the contacts observed in the structures.
It will produce two types of figures:</p>
<ul>
<li>a pair-wise distance matrix between all residues</li>
<li>a chord chart recapitulating the residue-residue contacts observed</li>
</ul>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/contmap-test.cfg">contmap-test.cfg</a></p>
<h3 id="fine-tuning-clustering-parameters"><a class="header" href="#fine-tuning-clustering-parameters">Fine tuning clustering parameters</a></h3>
<p>Finding the appropriate threshold for the clustering parameters can be quite tricky, and often requires a first trial, followed by manual inspection to understand the content of the dataset.
We are providing examples (for <code>clustrmsd</code> and <code>clustfcc</code>) fine tuning of the parameters with visualisation of the matrices, to help you understand how to investigate the results you obtained after clustering.</p>
<p>Here are the two important step to analyse the structural diversity of you set of complexes in a clustering module:</p>
<ul>
<li>turn on the <code>plot_matrix</code> parameter to obtain a visual representation of the distance matrix.</li>
<li>set the <code>min_population</code> to 1, so even singloton complexes will be forwarded to the next module and displayed on the plot.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-ilrmsdmatrix-clustrmsd.cfg">fine tuning of the <code>clustrmsd</code> parameters</a>.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-clustfcc.cfg">fine tuning of the <code>clustfcc</code> parameters</a>.</li>
</ul>
<p>Note that fine tuning of clustering parameters can also be performed with the <code>haddock3-re</code> command, as both <code>[clustfcc]</code> and <code>[clustrmsd]</code> modules are subcommands of the <code>haddock3-re</code> CLI.</p>
<h1 id="web-application-pre-defined-scenario"><a class="header" href="#web-application-pre-defined-scenario">Web-application pre-defined scenario</a></h1>
<p><em>comming soon...</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-docking-scenario-1"><a class="header" href="#examples-of-docking-scenario-1">Examples of docking scenario</a></h1>
<p>As creating a new workflow can be complex at the beginning, we are providing a set of pre-defined haddock3 scenarios.
These examples are encompassing a wide range of applications, such as:</p>
<ul>
<li><a href="docking_scenarios.html#protein-protein-docking">Protein-protein docking</a></li>
<li><a href="docking_scenarios.html#protein-peptide-docking">Protein-peptide docking</a></li>
<li><a href="docking_scenarios.html#protein-dna-docking">Protein-DNA docking</a></li>
<li><a href="docking_scenarios.html#antibody-antigen-docking">Antibody-antigen docking</a></li>
<li><a href="docking_scenarios.html#protein-glycan-docking">Protein-glycan docking</a></li>
<li><a href="docking_scenarios.html#small-molecule-docking">Small-molecule docking</a></li>
<li><a href="docking_scenarios.html#refinement-protocols">Complexes refinement protocols</a></li>
<li><a href="docking_scenarios.html#cyclic-peptide">Building cyclic peptide</a></li>
<li><a href="docking_scenarios.html#scoring-workflow">Scoring workflow</a></li>
<li><a href="docking_scenarios.html#analysis-scenario">Analysis pipelines</a></li>
</ul>
<p>Alternatively, up-to-date examples can also be found:</p>
<ul>
<li>in your local installation of haddock3: <code>haddock3/examples/</code>.</li>
<li>online, on our <a href="https://github.com/haddocking/haddock3/tree/main/examples">GitHub repository <code>haddock3/examples/</code></a>.</li>
</ul>
<p>Please note the extension scheme we are using in the provided configuration file examples:</p>
<ul>
<li><strong>*-full.cfg</strong>: we are using the <code>*-full.cfg</code> suffix on protocols that have proper sampling, and therefore could be used in production. These are nice baseline workflow with appropriate parameters, but will obviously require more time to terminate the run. Examples making use of MPI are also provided in some cases, together with an associated job file that should be submitted to the slurm batch system (<strong>*-full-mpi.cfg</strong> and <strong>*-full-mpi.job</strong>). Make sure to adapt the full config files to your own system.</li>
<li><strong>*-test.cfg</strong>: we are using the <code>*-test.cfg</code> suffix on protocols that have low sampling, allowing for fast test of the functionalities present in the workflow. Of note, on a daily basis, we are running most of the <code>*-test.cfg</code> configuration files to make sure the <code>main</code> branch of haddock3 is functional.</li>
</ul>
<h2 id="protein-protein-docking-1"><a class="header" href="#protein-protein-docking-1">Protein-protein docking</a></h2>
<h3 id="two-body-docking-1"><a class="header" href="#two-body-docking-1">Two body docking</a></h3>
<p>Here we provide various examples using the standard HADDOCK2.X workflows, now well established and banchmarked, using <code>[rigidbody]</code> docking (former <em>it0</em>), followed by flexible refinement in torsional angle space with the <code>[flexref]</code> module (former <em>it1</em>), with a final refinement step using molecular dynamics simulation in an explicit solvent shell (<code>[mdref]</code>, former <em>itw</em>) or an energy minimisation step (<code>[emref]</code>).
The final set of complexes is later clustered using Fraction of Common Contacts clustering (FCC) with the <code>[clustfcc]</code> module.</p>
<p>The protein-protein docking example makes use of the NMR chemical shift perturbation data providing information on the residues of binding site to guide the docking.
The NMR-identified residues are defined as active with their surface neighbors as passive (the corresponding AIRs are defined in the <a href="../examples/docking-protein-protein/data/e2a-hpr_air.tbl">e2a-hpr_air.tbl</a> file in the <code>data</code> directory).
This system is the same as described in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-protein-protein-basic/">HADDOCK2.4 basic protein-protein docking tutorial</a>.
For the second molecule (HPR), an ensemble of 10 conformations (taken from the NMR solution structure of this protein) is used as starting point for the docking.
Refer to above tutorial for more details about the system and restraints.</p>
<p>Here are some examples:</p>
<ul>
<li>with molecular dynamics simulation in an explicit solvent shell -&gt; <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-mdref-full.cfg">docking-protein-protein-mdref-full.cfg</a></li>
<li>with an energy minimisation step only: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-full.cfg">docking-protein-protein-full.cfg</a></li>
</ul>
<p>Due to the flexibility allowed by haddock3, a clustering step can now be performed right after the rigidbody sampling, allowing to capture a higher structural diversity by not only relying on the HADDOCK scoring function to select the top ranked models.
Here is an example with an intermediate clustering step after the <code>[rigidbody]</code> docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-cltsel-full.cfg">docking-protein-protein-cltsel-full.cfg</a>.</p>
<h3 id="symmetrical-homotrimer-docking-1"><a class="header" href="#symmetrical-homotrimer-docking-1">Symmetrical homotrimer docking</a></h3>
<p>The homotimer docking scenario, <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-homotrimer">available here</a>, is first performing <code>[rigidbody]</code> docking, followed by <code>[flexref]</code> refinement and a final <code>[emref]</code> energy minimisation step of the complexe.
It also makes use of two types of symmetry restraints:</p>
<ul>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#non-crystallographic-symmetry">non-crystallographic symmetry restraints</a>: to make sure the three chains are having the same conformation.</li>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#rotational-symmetry">C3 symmetry restraints</a>: to obtain solutions respecting the C3 symmetry.</li>
</ul>
<h3 id="multiple-ambiguous-files-1"><a class="header" href="#multiple-ambiguous-files-1">Multiple ambiguous files</a></h3>
<p>In some case, restraints could be obtained from various sources; different experimental methods or multiple predictions.
In this case, knowing which AIR file will be leading to the correct complex can only be assessed once the docking is performed, and maybe some of them will lead to the same solutions.</p>
<p>It is possible to input multiple ambiguous restraints files in a single <code>.tgz</code> archive.
When providing the kind of input, each sampled docking solution will use an other AIR file contained in the archive.
A particular parameter should later be set in the downstream protocol, <code>previous_ambig = true</code>, enabling to use the AIR file used at the <code>[rigidbody]</code> stage and so on.</p>
<p>An example is <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig">provided here</a>.</p>
<p>This example shows how to use HADDOCK3 when several restraint files are available.
It is built upon the results obtained running <a href="https://github.com/haddocking/arctic3d">arctic3d</a> on two proteins forming the complex <code>2GAF</code>.
The presence of multiple interfaces in both structures allows to define several <code>.tbl</code> ambiguous restraint files to be used in the calculations.
At first, these files must be compressed in a <code>.tbl.tgz</code> archive.
During the workflow, the Haddock3 machinery unzips the archive and evenly assigns each <code>.tbl</code> file to a number of models to be generated.
Even if only one sixth of the restraint files contain reasonable information on the interface, Haddock3 is still able to retrieve good docking models in the best-scoring positions.</p>
<p><strong>Note</strong> how the information about restraint files is propagated during the workflow (<code>previous_ambig = true</code> for <code>flexref</code> and <code>emref</code> modules), so that each model is always refined with its corresponding <code>.tbl</code> file.</p>
<p>Importantly, in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig/docking-multiple-tbls-clt-full.cfg">docking-multiple-tbls-clt-full.cfg</a> example the clustering is performed right after the <code>rigidbody</code> module, so as to lump together solutions resulting from the application of different sets of restraints.</p>
<p>The <code>caprieval</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-peptide-docking-1"><a class="header" href="#protein-peptide-docking-1">Protein Peptide docking</a></h2>
<p>The protein-peptide docking example makes use of the knowledge of the binding site on the protein to guide the docking.
The active site residues are defined as active and the peptide as passive (the corresponding AIRs are defined in the <code>ambig.tbl</code> file in the <code>data</code> directory).
This example follows the protocol described in our protein-peptide docking article (<a href="https://dx.plos.org/10.1371/journal.pone.0058769">Trellet et. al. PLoS ONE 8, e58769 (2013)</a>).
For the peptide, an ensemble of three conformations (alpha-helix, polyproline-II and extended) is provided as starting point for the docking.
Those were built using PyMol (instructions on how to do that can be found <a href="https://www.bonvinlab.org/education/molmod_online/simulation/#preparing-the-system">here</a>).</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement and energy minimisation of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-full.cfg">docking-protein-peptide-full.cfg</a></li>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement followed by a final refinement in explicit solvent (water) of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-mdref-full.cfg">docking-protein-peptide-mdref-full.cfg</a></li>
<li>3000 rigidbody docking models, FCC clustering and selection of max 20 models per cluster followed by flexible refinement and energy minimisation (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-cltsel-full.cfg">docking-protein-peptide-cltsel-full.cfg</a>).</li>
</ul>
<p><strong>Note</strong> how the peptide is defined as fully flexible for the refinement phase in <code>[flexref]</code> (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>) and dihedral angle restraints are automatically defined to maintain secondary structure elements (<code>ssdihed = "alphabeta"</code>)</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-dna-docking-1"><a class="header" href="#protein-dna-docking-1">Protein DNA docking</a></h2>
<p>Haddock3 can also deal with nucleic acids, such as DNA and RNA molecules.
In such senario, various important parameters must be set, allowing to:</p>
<ul>
<li>keep the dielectric constant constant: <code>dielec = "cdie"</code></li>
<li>set the dielectric constant to an higher value: <code>epsilon = 78</code></li>
<li>remove the desolvation term from the scroing function, otherwise having a too strong influence due to the phosphate groups: <code>w_desolv = 0</code>.</li>
<li>automatically generate restraints allowing to keep the double stranded DNA 3' and 5' ends together: <code>dnarest_on = true</code>.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li>using a final energy minimisation step: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-full.cfg">docking-protein-DNA-full.cfg</a></li>
<li>refining the interface using MD in a solvent shell: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-mdref-full.cfg">docking-protein-DNA-mdref-full.cfg</a></li>
<li>with an intermediate clustering step after rigidbody docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cltsel-full.cfg">docking-protein-DNA-cltsel-full.cfg</a></li>
<li>using center of mass restraints instead of ambiguous restraints extracted from the literature: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cmrest-test.cfg">docking-protein-DNA-cmrest-test.cfg</a></li>
</ul>
<h2 id="antibody-antigen-docking-1"><a class="header" href="#antibody-antigen-docking-1">Antibody-antigen docking</a></h2>
<p>Multiple antibody - antigen docking configuration files are <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-antibody-antigen">available here</a>.
They encompass various aspects of docking, mainly related to the information available to guide the docking:</p>
<ul>
<li><a href="docking_scenarios.html#no-information-about-the-paratop">No information about the paratop</a>: No information is known about the paratop, therefore tagetting the entire surface accessible resiude of the antigen.</li>
<li><a href="docking_scenarios.html#nmr-informed-paratop">Experimental knowledge of the paratop resiudes</a>: NMR data was aquired and allowed to obtain information about residues involded in the binding on the antigen side.</li>
</ul>
<h3 id="no-information-about-the-paratop-1"><a class="header" href="#no-information-about-the-paratop-1">No information about the paratop</a></h3>
<p>When no information is known about the paratop on the antigen side, our only solution is to rely on the CDR loops of the antibody, as we know that a least a subset of the resiudes on those loops will be part of the interaction.
Two appoaches can then be used:</p>
<ul>
<li>One where a distance restraints file is generated, where CDR loops resiudes are targetting all surface residues on the antigen side.</li>
<li>The other one defining random distance restraints between the CDR loops and random patches on the antigen side.</li>
</ul>
<h4 id="using-surface-accessible-resiudes-1"><a class="header" href="#using-surface-accessible-resiudes-1">Using surface accessible resiudes</a></h4>
<p>Generating restraints guiding the antibody CDR loops towards surface resiudes on the antigen side is a solution that will sample the entire surface of the antigen. For this, two major information must be extracted:</p>
<ul>
<li>The residue indices of the antibody CDR loops: can be predicted using bioinformatics tools such as <a href="https://wenmr.science.uu.nl/proabc2">proABC2</a>.</li>
<li>The surface residue indices of the antigen: can be predicted computed using <code>haddock3-restraints calc_accessibility antigen.pdb</code>.</li>
</ul>
<p>Defining the CDR loops as <code>active</code> residues and all surface residues on the antigen as <code>passive</code>, we can create an ambiguous restraints file <code>ambig.tbl</code>, that will guide the docking sampling the entire surface of the antigen while making sure the CDR loops are interacting. For more details on how to generate restraints, please refere to the <a href="/software/haddock3/manual/restraints_cli.html"><code>haddock3-restraints</code> documention</a>.</p>
<p>For such kind of naive approach, increasing the sampling at the <code>[rigidbody]</code> level is important.</p>
<p>Various examples are available:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full.cfg">docking-antibody-antigen-CDR-accessible-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-clt-full.cfg">docking-antibody-antigen-CDR-accessible-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.cfg">docking-antibody-antigen-CDR-accessible-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.job">docking-antibody-antigen-CDR-accessible-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h4 id="using-random-distance-restraints-1"><a class="header" href="#using-random-distance-restraints-1">Using random distance restraints</a></h4>
<p>An other alternative for pseudo-naive antibody-antigen docking is to define random restraints.
In this case, we will define segments on the antibody CDR loops to limit the search on the antibody side, and do not provide any definition on the antigen side.
By doing so, random residues on the CDR loops will be restraints to random patches on the antigen surface accessible residues.
This is performed in the <code>[rigidbody]</code> module by:</p>
<ul>
<li>turning on the <code>randair</code> parameter</li>
<li>defining 6 segments to define what are the CDR loops residues</li>
<li>increasing the sampling</li>
</ul>
<pre><code class="language-toml"># Turning on the randair parameter
randair = true
# About to define 6 random segments for the antigen
nrair_1 = 6
# Start and end of first CDR loop
rair_sta_1_1 = 26
rair_end_1_1 = 32
# Start and end of second CDR loop
rair_sta_1_2 = 55
rair_end_1_2 = 57
# Start and end of third CDR loop
rair_sta_1_3 = 101
rair_end_1_3 = 108
# Start and end of fourth CDR loop
rair_sta_1_4 = 146
rair_end_1_4 = 152
# Start and end of fifth CDR loop
rair_sta_1_5 = 170
rair_end_1_5 = 172
# Start and end of sixth CDR loop
rair_sta_1_6 = 212
rair_end_1_6 = 215

# Increasing the sampling
sampling = 10000

###
# ....
# Insert other modules here if you want
# ....
###

[flexref]
contactairs = true
</code></pre>
<p>In this case, no AIR restraints files can be accepted (nor <code>unambig</code> and <code>hbond</code> ones).</p>
<p>Note that after random air definition, we will use <code>contactairs = true</code> in later stage modules such as <code>[flexref]</code> and <code>[emref]</code>, generating restraints based on resiudes already in contact, ensuring the complex will not detach.</p>
<p>Here are some examples:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full.cfg">docking-antibody-antigen-ranairCDR-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-clt-full.cfg">docking-antibody-antigen-ranairCDR-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.cfg">docking-antibody-antigen-ranairCDR-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.job">docking-antibody-antigen-ranairCDR-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h3 id="nmr-informed-paratop-1"><a class="header" href="#nmr-informed-paratop-1">NMR informed paratop</a></h3>
<p>An ideal case would be to have information about the antigen paratop.
Coming from experimental methods or bioinformatic predictions, this information is extremly valuable as it will focus the  search by sampling comformations near key residues involed in the interaction.
By generating a dedicated ambiguous restraint file (<code>ambig-CDR-NMR-CSP.tbl</code>), only antigen CDR residues and few residues on the antigen side will be interacting.</p>
<p>Here is an  example: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-NMR-CSP-full.cfg">docking-antibody-antigen-CDR-NMR-CSP-full.cfg</a></p>
<h2 id="protein-glycan-docking-1"><a class="header" href="#protein-glycan-docking-1">Protein glycan docking</a></h2>
<p>A protein-glycan docking example making use of the knowledge of the binding site on the protein to guide the docking. The conformation of the glycan has been obtained from the <a href="http://glycam.org/">GLYCAM webserver</a>, while the structure of the protein is taken from the PDB in its unbound form. In the proposed workflows, a clustering step is always performed after initial docking stage, so as to increase the diversity of the ensemble of models to be refined.</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-glycan/docking-protein-glycan-full.cfg">docking-protein-glycan-full.cfg</a>: 1000 rigidbody docking models, RMSD clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final RMSD clustering for cluster-based scoring. The RMSD clustering assumes a good knowledge of the interface, as the user has to define the residues involved in the binding site by means of the resdic_ parameter.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-protein-glycan-ilrmsd-full.cfg">docking-protein-glycan-ilrmsd-full.cfg</a>: 1000 rigidbody docking models, interface-ligand-RMSD (<code>ilrmsd</code>) clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final ilRMSD clustering for cluster-based scoring. The interface-ligand-RMSD clustering is a more general approach, as it does not require the user to define the residues involved in the binding site. The interface is automatically defined by the residues involved in the protein-glycan interaction in the input models.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-flexref-protein-glycan-full.cfg">docking-flexref-protein-glycan-full.cfg</a>: 500 flexible docking runs + final RMSD clustering for cluster-based scoring. In this case, the rigidbody docking is skipped and the docking is performed at the flexible refinement level. In this case the flexible refinement has more steps than usual (<code>mdsteps_rigid = 5000</code>, <code>mdsteps_cool1 = 5000</code> and so on) and the glycan is defined as fully flexible (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>).</li>
</ul>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>), as in the <a href="docking_scenarios.html#small-molecule-docking">protein-ligand example</a>.</p>
<h2 id="small-molecule-docking-1"><a class="header" href="#small-molecule-docking-1">Small molecule docking</a></h2>
<p>Small molecule docking can also be performed using haddock3.
It requires the use of custom topology and paramter files for the ligand, as it they are out of the scope of the OPLS force-field.
To generate them, please refere to the section: <a href="/software/haddock3/manual/structure_requirements.html#How-to-generate-topology-and-parameters-for-my-ligand">How to generate topology and parameters for my ligand ?</a></p>
<p>Two protocols have been proposed:</p>
<ul>
<li><a href="docking_scenarios.html#template-based-shape-docking">By homology docking using experimental template</a></li>
<li><a href="docking_scenarios.html#using-binding-site-definition">By defining a binding site</a></li>
</ul>
<h3 id="template-based-shape-docking-1"><a class="header" href="#template-based-shape-docking-1">Template-based shape docking</a></h3>
<p>The use of experimental structure as template for docking have been shown to provide helpful information to guide the conformation of the ligand towards both the binding site and an adequate conformation (see: <a href="https://doi.org/10.1007/s10822-019-00244-6">D3R Grand Challenge 4</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0022283624003139">@TOME 3.0</a> and <a href="">CAPRI16 (soon)</a>)</p>
<p>A protein-ligand docking example making use of the knowledge of a template ligand (a ligand similar to the ligand we want to dock and bind to the same receptor).
The template ligand information is used in the form of shape consisting of dummy beads and positioned within the binding site to which distance restraints are defined.
More details about the method and the performance of the protocol when benchmarked on a fully unbound dataset
can be seen in our freely available <a href="https://pubs.acs.org/doi/full/10.1021/acs.jcim.1c00796">paper on JCIM</a>.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule HADDOCK2.4 tutorial</a>, during the docking and refinement the protein and the shape are kept in their original positions (see the <code>mol_fix_origin_X</code> parameters in the config file) and ambiguous distance restraints between the ligand and the shape beads are defined (the corresponding AIRs are defined in the <code>shape-restraints-from-shape-1.tbl</code> file in the <code>data</code> directory).
This is effectively a three body docking.
For the ligand an ensemble of 10 different conformations is provided as starting point for the docking (<code>ligand-ensemble.pdb</code> in the <code>data</code> directory).
Please refer to our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule tutorial</a> for information on how to generate such an ensemble.</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand-shape/docking-protein-ligand-shape-full.cfg">docking-protein-ligand-shape-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models with the protein and shape kept in their origin position, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>).
To allow the ligand to penetrate better into the binding site the intermolecular energy components are scaled down during the rigidbody docking phase (<code>inter_rigid = 0.001</code>).
As for the protein-ligand example, parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h3 id="using-binding-site-definition-1"><a class="header" href="#using-binding-site-definition-1">Using binding site definition</a></h3>
<p>A protein-ligand docking example making use of the knowledge of the binding site on the protein to guide the docking.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-binding-sites/">protein-ligand HADDOCK2.4 tutorial</a>, in the rigidbody docking phase all residues of the binding site are defined as active to draw the ligand into it (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-active-rigidbody.tbl">ambig-active-rigidbody.tbl</a> file in the <code>data</code> directory).
For the flexible refinement only the ligand is defined as active and the binding site as passive to allow the ligand to explore the binding site (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-passive.tbl">ambig-passive.tbl</a> file in the <code>data</code> directory).</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/docking-protein-ligand-full.cfg">docking-protein-ligand-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the <code>[rigidbody]</code> docking models (<code>w_vdw = 1.0</code>) and the skipping of the high temperature first two stages of the simulated annealing protocol during the <code>[flexref]</code> refinement (<code>mdsteps_rigid = 0</code> and <code>mdsteps_cool1 = 0</code>).
Parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="refinement-protocols-1"><a class="header" href="#refinement-protocols-1">Refinement protocols</a></h2>
<p>All refinements examples can be found <a href="https://github.com/haddocking/haddock3/tree/main/examples/refine-complex">here</a>.</p>
<h3 id="short-molecular-dynamics-symulation-in-explicit-solvent-1"><a class="header" href="#short-molecular-dynamics-symulation-in-explicit-solvent-1">Short molecular dynamics symulation in explicit solvent</a></h3>
<p>This example illustrates the refinement of a complex.
In this case (workflow <code>refine-complex-test.cfg</code>) the molecules are kept in their original positions and the complex is subjected to a short flexible refinement in explicit solvent with the <code>[mdref]</code> module.
The same complex as for the <code>docking-protein-protein</code> example is used.
The molecules are defined separately in the config file (and could consist each of an ensemble, provided the two ensembles have exactly the same number of models).</p>
<p>In this example all parameters are left to their default settings, except for manually defining the histidines' protonation states and setting the <code>sampling_factor</code> to 10, which means that from each starting complex 10 models will be generated with different random seeds for initiating the molecular dynamics phase.</p>
<p>The <code>caprieval</code> module is called at the end to assess the quality of the models with respect to the known reference structure.</p>
<p>Here is an example:</p>
<pre><code class="language-toml">run_dir = "mdref_complex_5replicas"
molecules = "model.pdb"

[topoaa]
autohis = false
[topoaa.mol1]
nhisd = 0
nhise = 1
hise_1 = 75
[topoaa.mol2]
nhisd = 1
hisd_1 = 76
nhise = 1
hise_1 = 15

[mdref]
# Setting sampling factor to 10 will generate 
# 10 replicas with different initial seeds to set the velocities
sampling_factor = 10
</code></pre>
<p><a href="https://github.com/haddocking/haddock3/blob/main/examples/refine-complex/refine-complex-test.cfg">Here is a full example</a> with provided input file and also using an experimental reference to track the evolution of the refinement.</p>
<h3 id="openmm-md-simulation-1"><a class="header" href="#openmm-md-simulation-1">OpenMM MD simulation</a></h3>
<p>The OpenMM molecular dynamics engine has its own module in haddock3, where users can setup short molecular dynamics similation using openMM.
It can be used as a refinement module, in implicit or explicit solvent.
Note that the use of the <code>[openmm]</code> module is a thirdparty module that requires its own installation procedure that is not part of the standard haddock3 suite.</p>
<h4 id="as-quality-assessment-of-a-docking-pose-1"><a class="header" href="#as-quality-assessment-of-a-docking-pose-1">As quality assessment of a docking pose</a></h4>
<p>Using the <code>[openmm]</code> module allows to run unbiased molecular dynamics simulations in explicit solvent.
Previous work of <a href="https://doi.org/10.1021/acs.jctc.1c00336">Z. Jandova, <em>et al.</em>, <em>J. Chem. Theo. and Comp.</em> 2021</a>, showed that near-native complexes have less deviation from their input structure after 10 ns of simulation.
Setting up such kind of experiment with haddock3 is extremely easy, as it simply requires to use the <code>[openmm]</code> module with an input complex model, followed by the <code>[caprieval]</code> using the same input complex as reference structure.
This will allow to track how far from the original pose the final frame reached.</p>
<p>Here is an example configuration file:</p>
<pre><code class="language-toml"># General parameters
run_dir = "md_to_the_rescue"
molecules = "model_1.pdb"

[topoaa]
[openmm]
# Define the timesteps
timestep_ps = 0.002  # default parameter
# Increase the simulation timesteps (500000 * 0.002 = 10 ns)
simulation_timesteps = 5000000
# Save 100 intermediate frames
save_intermediate = 100
# Define force-field
forcefield = 'amber14-all.xml'  # default parameter
# Use TIP3P explicit water model
explicit_solvent_model = 'amber14/tip3p.xml'  # default parameter
# Keep HBonds rigid
constraints = 'HBonds'  # default parameter
# Generate a final ensemble composed of all the frames
generate_ensemble = true  # default parameter

[topoaa]
# Compare the generated ensemble with the initial model
[caprieval]
reference_fname = "model_1.pdb"
sort_by = "dockq"
</code></pre>
<p>This protocol has been used during CAPRI round 55 for target 231, to validate the docking poses of the FLAG-peptide on the antibody (see: <a href="https://www.biorxiv.org/content/10.1101/2024.09.16.613212v2">CAPRI rounds 47-55 paper</a>).</p>
<h2 id="peptide-cyclisation-1"><a class="header" href="#peptide-cyclisation-1">Peptide cyclisation</a></h2>
<p>The generation of cyclic peptides usually involve the formation of a disulphide bridge between two cysteins or the formation of a peptide bond between the N-terminus and C-terminus residues.
This can be performed by haddock3 in a two step process, by first generating restraints between the two resiudes involved to induce a pre-cyclic conformation, and then re-generating the topology with an increased range of chemical bond detection (tuning <code>cyclicpept_dist</code>, <code>disulphide_dist</code> and turning on the <code>cyclicpept</code> parameters in <code>[topoaa]</code> module), therefore detecting and creating the covalent cyclic bond and refining again.</p>
<p>Protocol described in: <a href="https://doi.org/10.1021/acs.jctc.2c00075">https://doi.org/10.1021/acs.jctc.2c00075</a></p>
<p>Two examples are provided in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/"><code>examples/peptide-cyclisation/</code></a>:</p>
<ul>
<li>1SFI, a 14 residue cyclic peptide with both backbone and disulphide bridge cyclisation: <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/cyclise-peptide-full.cfg">cyclise-peptide-full.cfg</a></li>
<li>3WNE, a 6 residue backbone cyclic peptide</li>
</ul>
<p>The input peptide was generated using PyMOL, using beta and polyproline initial conformation (available in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb"><code>examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb</code></a>).</p>
<p>The first step is using the <code>[flexref]</code> module, setting the <code>unambig_fname</code> to <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_unambig.tbl">1sfi_unambig.tbl</a> to drive both the backbone and disulphide bridge cyclisation, giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters), increasing the number steps by a factor 10 to allow for more flexible refinement (<code>mdsteps_rigid</code>, <code>mdsteps_cool1</code>, <code>mdsteps_cool2</code>, <code>mdsteps_cool3</code>), turning off the electrostatic <code>elecflag = false</code>. By setting <code>sampling_factor = 200</code>, we will generate 200 replicas with different initial seeds for each of the input conformations (in this case 2).
This is followed by an short molecular dynamics simulation in explicit solvent <code>[mdref]</code>, also giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters).</p>
<p>A RMSD clustering step is perfomed using <code>[rmsdmatrix]</code>, <code>[clustrmsd]</code> (with <code>criterion="maxclust"</code> and <code>n_clusters=50</code>) to generate a subset of 50 clusters, finalized by <code>[seletopclusts]</code> module setting <code>top_models=1</code>, to only extract one single model per clusters.</p>
<p><code>[topoaa]</code> module is then used again to re-generate the topology. In this case the three <strong>important</strong> parameters (<code>cyclicpept_dist</code>, <code>disulphide_dist</code>, and <code>cyclicpept</code>) are set, allowing for the detection of the disulphide bridge and peptide bond at higher distance, therefore generating the proper cyclicised topology.</p>
<p>A second round of <code>[emref]</code>, <code>[flexref]</code> and <code>[mdref]</code> is then performed, allowing to reduce the length of the newly formed chemical bonds and optimise the cyclic peptide conformation.</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the conformation of the peptide with respect to the known reference structure. Note that in this case, only the <code>global_rmsd</code> value is computed, as the structure is not a complex.</p>
<h2 id="scoring-workflow-1"><a class="header" href="#scoring-workflow-1">Scoring workflow</a></h2>
<h2 id="defining-a-haddock3-configuration-file-1"><a class="header" href="#defining-a-haddock3-configuration-file-1">Defining a haddock3 configuration file</a></h2>
<p>This example illustrates the use of Haddock3 for scoring purposes.
In contrast to HADDOCK2.X, Haddock3 can score a heterogenous set of complexes within one run/workflow.
In this example, four different types of complexes are scored within the same workflow:</p>
<ul>
<li>an ensemble of 5 models taken from CAPRI Target161</li>
<li>a protein-DNA complex (model taken from our protein-DNA docking example)</li>
<li>two models of a protein-protein complex (taken from our protein-protein docking example)</li>
<li>a homotrimer model (taken from our protein-homotrimer docking examples)</li>
</ul>
<p>Three scoring workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/emscoring-test.cfg">emscoring-test.cfg</a>: Only a short energy minimisation is performed on each model using <code>[emref]</code> module.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/mdscoring-test.cfg">mdscoring-test.cfg</a>: A short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module. In that case contact AIRs (<code>contactairs = true</code>), dihedral angle restraints on secondary structure element (<code>ssdihed = alphabeta</code>) and DNA restraints (<code>dnarest_on = true</code>) are automatically defined.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/capri-scoring-test.cfg">capri-scoring-test.cfg</a>: An example scoring pipeline using in the CAPRI55 competition, where energy minimisation ()<code>[emref]</code>) is followed by FCC clustering (<code>[clustfcc]</code>) and selection of the top 2 models per cluster (<code>[seletopclusts]</code> with <code>top_models = 2</code>). Then a short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module and the models are clustered again.</li>
</ul>
<p>The model listings with their associated HADDOCK scores can be found in a <code>.tsv</code> file in the stage <code>01_xxx</code> directory of the respective runs.</p>
<h3 id="using-scoring-command-line-1"><a class="header" href="#using-scoring-command-line-1">Using scoring command line</a></h3>
<p>Haddock3 also contain a simple command line interface that allows you to score a single pdb file.
To do so, just run:</p>
<pre><code class="language-bash">haddock3-score complex.pdb
</code></pre>
<p>This command is a short-cut to the following parameter file, and therefore can be really handy, as it simplify a lot the procedure, but is limitted to the scoring of a single model.</p>
<pre><code class="language-toml">run_dir = "tmp_score"
molecules = "complex.pdb"
[topoaa]
[emscoring]
</code></pre>
<p>For more details on the <code>haddock3-score</code> CLI, please refere to <a href="/software/haddock3/module/clis.html#haddock3-score">this section</a>.</p>
<h2 id="analysis-scenario-1"><a class="header" href="#analysis-scenario-1">Analysis scenario</a></h2>
<p>The addition and inclusion of analysis modules in haddock3 is one of its major new strength, as it allows to perform various kind of analysis directly during the workflow.
For the complete list of analysis modules and their capabilities, please refere to the <a href="software/haddock3/manual/modules/analysis.html">Analysis Modules section</a>.</p>
<h3 id="comparison-to-a-reference-structure-1"><a class="header" href="#comparison-to-a-reference-structure-1">Comparison to a reference structure</a></h3>
<p>The <code>[caprieval]</code> module is dedicated to the computation of the CAPRI metrics (rmsd, interface-rmsd, ligand-rmsd, interface-ligand rmsd and dockq) on a set of input models. A reference structure can be provided using the <code>reference_fname</code> parameter. If this parameter is not defined, the best scoring model will be used as reference.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/topoaa-caprieval-test.cfg">topoaa-caprieval-test.cfg</a>.</p>
<h3 id="hot-spot-detection-1"><a class="header" href="#hot-spot-detection-1">Hot spot detection</a></h3>
<p>The analysis of hot-spots and key residues involved in the interaction between two chain can be of valuable information for mutagenesis or design purposes.
The <code>[alascan]</code> module is designed to perform point mutation of residues at the interface of a complex, and evaluate the difference in HADDOCK score with respect to the original input complex. It also splits the scoring function in its various components and generate an interactive graph allowing for a visual representation of the scanned resiudes contributions.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/alascan-test.cfg">alascan-test.cfg</a>.</p>
<h3 id="generation-of-contact-maps-1"><a class="header" href="#generation-of-contact-maps-1">Generation of contact maps</a></h3>
<p>While HADDOCK is producing 3D atomistic models, having the opportunity to have a 2D representation of the complexes can allow to understand at the sequence level the contacts involved in the compelex.
The <code>[contactmap]</code> module is specially designed to produce interactive plots describing the contacts observed in the structures.
It will produce two types of figures:</p>
<ul>
<li>a pair-wise distance matrix between all residues</li>
<li>a chord chart recapitulating the residue-residue contacts observed</li>
</ul>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/contmap-test.cfg">contmap-test.cfg</a></p>
<h3 id="fine-tuning-clustering-parameters-1"><a class="header" href="#fine-tuning-clustering-parameters-1">Fine tuning clustering parameters</a></h3>
<p>Finding the appropriate threshold for the clustering parameters can be quite tricky, and often requires a first trial, followed by manual inspection to understand the content of the dataset.
We are providing examples (for <code>clustrmsd</code> and <code>clustfcc</code>) fine tuning of the parameters with visualisation of the matrices, to help you understand how to investigate the results you obtained after clustering.</p>
<p>Here are the two important step to analyse the structural diversity of you set of complexes in a clustering module:</p>
<ul>
<li>turn on the <code>plot_matrix</code> parameter to obtain a visual representation of the distance matrix.</li>
<li>set the <code>min_population</code> to 1, so even singloton complexes will be forwarded to the next module and displayed on the plot.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-ilrmsdmatrix-clustrmsd.cfg">fine tuning of the <code>clustrmsd</code> parameters</a>.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-clustfcc.cfg">fine tuning of the <code>clustfcc</code> parameters</a>.</li>
</ul>
<p>Note that fine tuning of clustering parameters can also be performed with the <code>haddock3-re</code> command, as both <code>[clustfcc]</code> and <code>[clustrmsd]</code> modules are subcommands of the <code>haddock3-re</code> CLI.</p>
<h1 id="web-application-pre-defined-scenario-1"><a class="header" href="#web-application-pre-defined-scenario-1">Web-application pre-defined scenario</a></h1>
<p><em>comming soon...</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-docking-scenario-2"><a class="header" href="#examples-of-docking-scenario-2">Examples of docking scenario</a></h1>
<p>As creating a new workflow can be complex at the beginning, we are providing a set of pre-defined haddock3 scenarios.
These examples are encompassing a wide range of applications, such as:</p>
<ul>
<li><a href="docking_scenarios.html#protein-protein-docking">Protein-protein docking</a></li>
<li><a href="docking_scenarios.html#protein-peptide-docking">Protein-peptide docking</a></li>
<li><a href="docking_scenarios.html#protein-dna-docking">Protein-DNA docking</a></li>
<li><a href="docking_scenarios.html#antibody-antigen-docking">Antibody-antigen docking</a></li>
<li><a href="docking_scenarios.html#protein-glycan-docking">Protein-glycan docking</a></li>
<li><a href="docking_scenarios.html#small-molecule-docking">Small-molecule docking</a></li>
<li><a href="docking_scenarios.html#refinement-protocols">Complexes refinement protocols</a></li>
<li><a href="docking_scenarios.html#cyclic-peptide">Building cyclic peptide</a></li>
<li><a href="docking_scenarios.html#scoring-workflow">Scoring workflow</a></li>
<li><a href="docking_scenarios.html#analysis-scenario">Analysis pipelines</a></li>
</ul>
<p>Alternatively, up-to-date examples can also be found:</p>
<ul>
<li>in your local installation of haddock3: <code>haddock3/examples/</code>.</li>
<li>online, on our <a href="https://github.com/haddocking/haddock3/tree/main/examples">GitHub repository <code>haddock3/examples/</code></a>.</li>
</ul>
<p>Please note the extension scheme we are using in the provided configuration file examples:</p>
<ul>
<li><strong>*-full.cfg</strong>: we are using the <code>*-full.cfg</code> suffix on protocols that have proper sampling, and therefore could be used in production. These are nice baseline workflow with appropriate parameters, but will obviously require more time to terminate the run. Examples making use of MPI are also provided in some cases, together with an associated job file that should be submitted to the slurm batch system (<strong>*-full-mpi.cfg</strong> and <strong>*-full-mpi.job</strong>). Make sure to adapt the full config files to your own system.</li>
<li><strong>*-test.cfg</strong>: we are using the <code>*-test.cfg</code> suffix on protocols that have low sampling, allowing for fast test of the functionalities present in the workflow. Of note, on a daily basis, we are running most of the <code>*-test.cfg</code> configuration files to make sure the <code>main</code> branch of haddock3 is functional.</li>
</ul>
<h2 id="protein-protein-docking-2"><a class="header" href="#protein-protein-docking-2">Protein-protein docking</a></h2>
<h3 id="two-body-docking-2"><a class="header" href="#two-body-docking-2">Two body docking</a></h3>
<p>Here we provide various examples using the standard HADDOCK2.X workflows, now well established and banchmarked, using <code>[rigidbody]</code> docking (former <em>it0</em>), followed by flexible refinement in torsional angle space with the <code>[flexref]</code> module (former <em>it1</em>), with a final refinement step using molecular dynamics simulation in an explicit solvent shell (<code>[mdref]</code>, former <em>itw</em>) or an energy minimisation step (<code>[emref]</code>).
The final set of complexes is later clustered using Fraction of Common Contacts clustering (FCC) with the <code>[clustfcc]</code> module.</p>
<p>The protein-protein docking example makes use of the NMR chemical shift perturbation data providing information on the residues of binding site to guide the docking.
The NMR-identified residues are defined as active with their surface neighbors as passive (the corresponding AIRs are defined in the <a href="../examples/docking-protein-protein/data/e2a-hpr_air.tbl">e2a-hpr_air.tbl</a> file in the <code>data</code> directory).
This system is the same as described in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-protein-protein-basic/">HADDOCK2.4 basic protein-protein docking tutorial</a>.
For the second molecule (HPR), an ensemble of 10 conformations (taken from the NMR solution structure of this protein) is used as starting point for the docking.
Refer to above tutorial for more details about the system and restraints.</p>
<p>Here are some examples:</p>
<ul>
<li>with molecular dynamics simulation in an explicit solvent shell -&gt; <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-mdref-full.cfg">docking-protein-protein-mdref-full.cfg</a></li>
<li>with an energy minimisation step only: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-full.cfg">docking-protein-protein-full.cfg</a></li>
</ul>
<p>Due to the flexibility allowed by haddock3, a clustering step can now be performed right after the rigidbody sampling, allowing to capture a higher structural diversity by not only relying on the HADDOCK scoring function to select the top ranked models.
Here is an example with an intermediate clustering step after the <code>[rigidbody]</code> docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-cltsel-full.cfg">docking-protein-protein-cltsel-full.cfg</a>.</p>
<h3 id="symmetrical-homotrimer-docking-2"><a class="header" href="#symmetrical-homotrimer-docking-2">Symmetrical homotrimer docking</a></h3>
<p>The homotimer docking scenario, <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-homotrimer">available here</a>, is first performing <code>[rigidbody]</code> docking, followed by <code>[flexref]</code> refinement and a final <code>[emref]</code> energy minimisation step of the complexe.
It also makes use of two types of symmetry restraints:</p>
<ul>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#non-crystallographic-symmetry">non-crystallographic symmetry restraints</a>: to make sure the three chains are having the same conformation.</li>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#rotational-symmetry">C3 symmetry restraints</a>: to obtain solutions respecting the C3 symmetry.</li>
</ul>
<h3 id="multiple-ambiguous-files-2"><a class="header" href="#multiple-ambiguous-files-2">Multiple ambiguous files</a></h3>
<p>In some case, restraints could be obtained from various sources; different experimental methods or multiple predictions.
In this case, knowing which AIR file will be leading to the correct complex can only be assessed once the docking is performed, and maybe some of them will lead to the same solutions.</p>
<p>It is possible to input multiple ambiguous restraints files in a single <code>.tgz</code> archive.
When providing the kind of input, each sampled docking solution will use an other AIR file contained in the archive.
A particular parameter should later be set in the downstream protocol, <code>previous_ambig = true</code>, enabling to use the AIR file used at the <code>[rigidbody]</code> stage and so on.</p>
<p>An example is <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig">provided here</a>.</p>
<p>This example shows how to use HADDOCK3 when several restraint files are available.
It is built upon the results obtained running <a href="https://github.com/haddocking/arctic3d">arctic3d</a> on two proteins forming the complex <code>2GAF</code>.
The presence of multiple interfaces in both structures allows to define several <code>.tbl</code> ambiguous restraint files to be used in the calculations.
At first, these files must be compressed in a <code>.tbl.tgz</code> archive.
During the workflow, the Haddock3 machinery unzips the archive and evenly assigns each <code>.tbl</code> file to a number of models to be generated.
Even if only one sixth of the restraint files contain reasonable information on the interface, Haddock3 is still able to retrieve good docking models in the best-scoring positions.</p>
<p><strong>Note</strong> how the information about restraint files is propagated during the workflow (<code>previous_ambig = true</code> for <code>flexref</code> and <code>emref</code> modules), so that each model is always refined with its corresponding <code>.tbl</code> file.</p>
<p>Importantly, in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig/docking-multiple-tbls-clt-full.cfg">docking-multiple-tbls-clt-full.cfg</a> example the clustering is performed right after the <code>rigidbody</code> module, so as to lump together solutions resulting from the application of different sets of restraints.</p>
<p>The <code>caprieval</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-peptide-docking-2"><a class="header" href="#protein-peptide-docking-2">Protein Peptide docking</a></h2>
<p>The protein-peptide docking example makes use of the knowledge of the binding site on the protein to guide the docking.
The active site residues are defined as active and the peptide as passive (the corresponding AIRs are defined in the <code>ambig.tbl</code> file in the <code>data</code> directory).
This example follows the protocol described in our protein-peptide docking article (<a href="https://dx.plos.org/10.1371/journal.pone.0058769">Trellet et. al. PLoS ONE 8, e58769 (2013)</a>).
For the peptide, an ensemble of three conformations (alpha-helix, polyproline-II and extended) is provided as starting point for the docking.
Those were built using PyMol (instructions on how to do that can be found <a href="https://www.bonvinlab.org/education/molmod_online/simulation/#preparing-the-system">here</a>).</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement and energy minimisation of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-full.cfg">docking-protein-peptide-full.cfg</a></li>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement followed by a final refinement in explicit solvent (water) of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-mdref-full.cfg">docking-protein-peptide-mdref-full.cfg</a></li>
<li>3000 rigidbody docking models, FCC clustering and selection of max 20 models per cluster followed by flexible refinement and energy minimisation (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-cltsel-full.cfg">docking-protein-peptide-cltsel-full.cfg</a>).</li>
</ul>
<p><strong>Note</strong> how the peptide is defined as fully flexible for the refinement phase in <code>[flexref]</code> (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>) and dihedral angle restraints are automatically defined to maintain secondary structure elements (<code>ssdihed = "alphabeta"</code>)</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-dna-docking-2"><a class="header" href="#protein-dna-docking-2">Protein DNA docking</a></h2>
<p>Haddock3 can also deal with nucleic acids, such as DNA and RNA molecules.
In such senario, various important parameters must be set, allowing to:</p>
<ul>
<li>keep the dielectric constant constant: <code>dielec = "cdie"</code></li>
<li>set the dielectric constant to an higher value: <code>epsilon = 78</code></li>
<li>remove the desolvation term from the scroing function, otherwise having a too strong influence due to the phosphate groups: <code>w_desolv = 0</code>.</li>
<li>automatically generate restraints allowing to keep the double stranded DNA 3' and 5' ends together: <code>dnarest_on = true</code>.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li>using a final energy minimisation step: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-full.cfg">docking-protein-DNA-full.cfg</a></li>
<li>refining the interface using MD in a solvent shell: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-mdref-full.cfg">docking-protein-DNA-mdref-full.cfg</a></li>
<li>with an intermediate clustering step after rigidbody docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cltsel-full.cfg">docking-protein-DNA-cltsel-full.cfg</a></li>
<li>using center of mass restraints instead of ambiguous restraints extracted from the literature: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cmrest-test.cfg">docking-protein-DNA-cmrest-test.cfg</a></li>
</ul>
<h2 id="antibody-antigen-docking-2"><a class="header" href="#antibody-antigen-docking-2">Antibody-antigen docking</a></h2>
<p>Multiple antibody - antigen docking configuration files are <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-antibody-antigen">available here</a>.
They encompass various aspects of docking, mainly related to the information available to guide the docking:</p>
<ul>
<li><a href="docking_scenarios.html#no-information-about-the-paratop">No information about the paratop</a>: No information is known about the paratop, therefore tagetting the entire surface accessible resiude of the antigen.</li>
<li><a href="docking_scenarios.html#nmr-informed-paratop">Experimental knowledge of the paratop resiudes</a>: NMR data was aquired and allowed to obtain information about residues involded in the binding on the antigen side.</li>
</ul>
<h3 id="no-information-about-the-paratop-2"><a class="header" href="#no-information-about-the-paratop-2">No information about the paratop</a></h3>
<p>When no information is known about the paratop on the antigen side, our only solution is to rely on the CDR loops of the antibody, as we know that a least a subset of the resiudes on those loops will be part of the interaction.
Two appoaches can then be used:</p>
<ul>
<li>One where a distance restraints file is generated, where CDR loops resiudes are targetting all surface residues on the antigen side.</li>
<li>The other one defining random distance restraints between the CDR loops and random patches on the antigen side.</li>
</ul>
<h4 id="using-surface-accessible-resiudes-2"><a class="header" href="#using-surface-accessible-resiudes-2">Using surface accessible resiudes</a></h4>
<p>Generating restraints guiding the antibody CDR loops towards surface resiudes on the antigen side is a solution that will sample the entire surface of the antigen. For this, two major information must be extracted:</p>
<ul>
<li>The residue indices of the antibody CDR loops: can be predicted using bioinformatics tools such as <a href="https://wenmr.science.uu.nl/proabc2">proABC2</a>.</li>
<li>The surface residue indices of the antigen: can be predicted computed using <code>haddock3-restraints calc_accessibility antigen.pdb</code>.</li>
</ul>
<p>Defining the CDR loops as <code>active</code> residues and all surface residues on the antigen as <code>passive</code>, we can create an ambiguous restraints file <code>ambig.tbl</code>, that will guide the docking sampling the entire surface of the antigen while making sure the CDR loops are interacting. For more details on how to generate restraints, please refere to the <a href="/software/haddock3/manual/restraints_cli.html"><code>haddock3-restraints</code> documention</a>.</p>
<p>For such kind of naive approach, increasing the sampling at the <code>[rigidbody]</code> level is important.</p>
<p>Various examples are available:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full.cfg">docking-antibody-antigen-CDR-accessible-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-clt-full.cfg">docking-antibody-antigen-CDR-accessible-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.cfg">docking-antibody-antigen-CDR-accessible-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.job">docking-antibody-antigen-CDR-accessible-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h4 id="using-random-distance-restraints-2"><a class="header" href="#using-random-distance-restraints-2">Using random distance restraints</a></h4>
<p>An other alternative for pseudo-naive antibody-antigen docking is to define random restraints.
In this case, we will define segments on the antibody CDR loops to limit the search on the antibody side, and do not provide any definition on the antigen side.
By doing so, random residues on the CDR loops will be restraints to random patches on the antigen surface accessible residues.
This is performed in the <code>[rigidbody]</code> module by:</p>
<ul>
<li>turning on the <code>randair</code> parameter</li>
<li>defining 6 segments to define what are the CDR loops residues</li>
<li>increasing the sampling</li>
</ul>
<pre><code class="language-toml"># Turning on the randair parameter
randair = true
# About to define 6 random segments for the antigen
nrair_1 = 6
# Start and end of first CDR loop
rair_sta_1_1 = 26
rair_end_1_1 = 32
# Start and end of second CDR loop
rair_sta_1_2 = 55
rair_end_1_2 = 57
# Start and end of third CDR loop
rair_sta_1_3 = 101
rair_end_1_3 = 108
# Start and end of fourth CDR loop
rair_sta_1_4 = 146
rair_end_1_4 = 152
# Start and end of fifth CDR loop
rair_sta_1_5 = 170
rair_end_1_5 = 172
# Start and end of sixth CDR loop
rair_sta_1_6 = 212
rair_end_1_6 = 215

# Increasing the sampling
sampling = 10000

###
# ....
# Insert other modules here if you want
# ....
###

[flexref]
contactairs = true
</code></pre>
<p>In this case, no AIR restraints files can be accepted (nor <code>unambig</code> and <code>hbond</code> ones).</p>
<p>Note that after random air definition, we will use <code>contactairs = true</code> in later stage modules such as <code>[flexref]</code> and <code>[emref]</code>, generating restraints based on resiudes already in contact, ensuring the complex will not detach.</p>
<p>Here are some examples:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full.cfg">docking-antibody-antigen-ranairCDR-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-clt-full.cfg">docking-antibody-antigen-ranairCDR-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.cfg">docking-antibody-antigen-ranairCDR-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.job">docking-antibody-antigen-ranairCDR-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h3 id="nmr-informed-paratop-2"><a class="header" href="#nmr-informed-paratop-2">NMR informed paratop</a></h3>
<p>An ideal case would be to have information about the antigen paratop.
Coming from experimental methods or bioinformatic predictions, this information is extremly valuable as it will focus the  search by sampling comformations near key residues involed in the interaction.
By generating a dedicated ambiguous restraint file (<code>ambig-CDR-NMR-CSP.tbl</code>), only antigen CDR residues and few residues on the antigen side will be interacting.</p>
<p>Here is an  example: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-NMR-CSP-full.cfg">docking-antibody-antigen-CDR-NMR-CSP-full.cfg</a></p>
<h2 id="protein-glycan-docking-2"><a class="header" href="#protein-glycan-docking-2">Protein glycan docking</a></h2>
<p>A protein-glycan docking example making use of the knowledge of the binding site on the protein to guide the docking. The conformation of the glycan has been obtained from the <a href="http://glycam.org/">GLYCAM webserver</a>, while the structure of the protein is taken from the PDB in its unbound form. In the proposed workflows, a clustering step is always performed after initial docking stage, so as to increase the diversity of the ensemble of models to be refined.</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-glycan/docking-protein-glycan-full.cfg">docking-protein-glycan-full.cfg</a>: 1000 rigidbody docking models, RMSD clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final RMSD clustering for cluster-based scoring. The RMSD clustering assumes a good knowledge of the interface, as the user has to define the residues involved in the binding site by means of the resdic_ parameter.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-protein-glycan-ilrmsd-full.cfg">docking-protein-glycan-ilrmsd-full.cfg</a>: 1000 rigidbody docking models, interface-ligand-RMSD (<code>ilrmsd</code>) clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final ilRMSD clustering for cluster-based scoring. The interface-ligand-RMSD clustering is a more general approach, as it does not require the user to define the residues involved in the binding site. The interface is automatically defined by the residues involved in the protein-glycan interaction in the input models.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-flexref-protein-glycan-full.cfg">docking-flexref-protein-glycan-full.cfg</a>: 500 flexible docking runs + final RMSD clustering for cluster-based scoring. In this case, the rigidbody docking is skipped and the docking is performed at the flexible refinement level. In this case the flexible refinement has more steps than usual (<code>mdsteps_rigid = 5000</code>, <code>mdsteps_cool1 = 5000</code> and so on) and the glycan is defined as fully flexible (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>).</li>
</ul>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>), as in the <a href="docking_scenarios.html#small-molecule-docking">protein-ligand example</a>.</p>
<h2 id="small-molecule-docking-2"><a class="header" href="#small-molecule-docking-2">Small molecule docking</a></h2>
<p>Small molecule docking can also be performed using haddock3.
It requires the use of custom topology and paramter files for the ligand, as it they are out of the scope of the OPLS force-field.
To generate them, please refere to the section: <a href="/software/haddock3/manual/structure_requirements.html#How-to-generate-topology-and-parameters-for-my-ligand">How to generate topology and parameters for my ligand ?</a></p>
<p>Two protocols have been proposed:</p>
<ul>
<li><a href="docking_scenarios.html#template-based-shape-docking">By homology docking using experimental template</a></li>
<li><a href="docking_scenarios.html#using-binding-site-definition">By defining a binding site</a></li>
</ul>
<h3 id="template-based-shape-docking-2"><a class="header" href="#template-based-shape-docking-2">Template-based shape docking</a></h3>
<p>The use of experimental structure as template for docking have been shown to provide helpful information to guide the conformation of the ligand towards both the binding site and an adequate conformation (see: <a href="https://doi.org/10.1007/s10822-019-00244-6">D3R Grand Challenge 4</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0022283624003139">@TOME 3.0</a> and <a href="">CAPRI16 (soon)</a>)</p>
<p>A protein-ligand docking example making use of the knowledge of a template ligand (a ligand similar to the ligand we want to dock and bind to the same receptor).
The template ligand information is used in the form of shape consisting of dummy beads and positioned within the binding site to which distance restraints are defined.
More details about the method and the performance of the protocol when benchmarked on a fully unbound dataset
can be seen in our freely available <a href="https://pubs.acs.org/doi/full/10.1021/acs.jcim.1c00796">paper on JCIM</a>.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule HADDOCK2.4 tutorial</a>, during the docking and refinement the protein and the shape are kept in their original positions (see the <code>mol_fix_origin_X</code> parameters in the config file) and ambiguous distance restraints between the ligand and the shape beads are defined (the corresponding AIRs are defined in the <code>shape-restraints-from-shape-1.tbl</code> file in the <code>data</code> directory).
This is effectively a three body docking.
For the ligand an ensemble of 10 different conformations is provided as starting point for the docking (<code>ligand-ensemble.pdb</code> in the <code>data</code> directory).
Please refer to our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule tutorial</a> for information on how to generate such an ensemble.</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand-shape/docking-protein-ligand-shape-full.cfg">docking-protein-ligand-shape-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models with the protein and shape kept in their origin position, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>).
To allow the ligand to penetrate better into the binding site the intermolecular energy components are scaled down during the rigidbody docking phase (<code>inter_rigid = 0.001</code>).
As for the protein-ligand example, parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h3 id="using-binding-site-definition-2"><a class="header" href="#using-binding-site-definition-2">Using binding site definition</a></h3>
<p>A protein-ligand docking example making use of the knowledge of the binding site on the protein to guide the docking.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-binding-sites/">protein-ligand HADDOCK2.4 tutorial</a>, in the rigidbody docking phase all residues of the binding site are defined as active to draw the ligand into it (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-active-rigidbody.tbl">ambig-active-rigidbody.tbl</a> file in the <code>data</code> directory).
For the flexible refinement only the ligand is defined as active and the binding site as passive to allow the ligand to explore the binding site (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-passive.tbl">ambig-passive.tbl</a> file in the <code>data</code> directory).</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/docking-protein-ligand-full.cfg">docking-protein-ligand-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the <code>[rigidbody]</code> docking models (<code>w_vdw = 1.0</code>) and the skipping of the high temperature first two stages of the simulated annealing protocol during the <code>[flexref]</code> refinement (<code>mdsteps_rigid = 0</code> and <code>mdsteps_cool1 = 0</code>).
Parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="refinement-protocols-2"><a class="header" href="#refinement-protocols-2">Refinement protocols</a></h2>
<p>All refinements examples can be found <a href="https://github.com/haddocking/haddock3/tree/main/examples/refine-complex">here</a>.</p>
<h3 id="short-molecular-dynamics-symulation-in-explicit-solvent-2"><a class="header" href="#short-molecular-dynamics-symulation-in-explicit-solvent-2">Short molecular dynamics symulation in explicit solvent</a></h3>
<p>This example illustrates the refinement of a complex.
In this case (workflow <code>refine-complex-test.cfg</code>) the molecules are kept in their original positions and the complex is subjected to a short flexible refinement in explicit solvent with the <code>[mdref]</code> module.
The same complex as for the <code>docking-protein-protein</code> example is used.
The molecules are defined separately in the config file (and could consist each of an ensemble, provided the two ensembles have exactly the same number of models).</p>
<p>In this example all parameters are left to their default settings, except for manually defining the histidines' protonation states and setting the <code>sampling_factor</code> to 10, which means that from each starting complex 10 models will be generated with different random seeds for initiating the molecular dynamics phase.</p>
<p>The <code>caprieval</code> module is called at the end to assess the quality of the models with respect to the known reference structure.</p>
<p>Here is an example:</p>
<pre><code class="language-toml">run_dir = "mdref_complex_5replicas"
molecules = "model.pdb"

[topoaa]
autohis = false
[topoaa.mol1]
nhisd = 0
nhise = 1
hise_1 = 75
[topoaa.mol2]
nhisd = 1
hisd_1 = 76
nhise = 1
hise_1 = 15

[mdref]
# Setting sampling factor to 10 will generate 
# 10 replicas with different initial seeds to set the velocities
sampling_factor = 10
</code></pre>
<p><a href="https://github.com/haddocking/haddock3/blob/main/examples/refine-complex/refine-complex-test.cfg">Here is a full example</a> with provided input file and also using an experimental reference to track the evolution of the refinement.</p>
<h3 id="openmm-md-simulation-2"><a class="header" href="#openmm-md-simulation-2">OpenMM MD simulation</a></h3>
<p>The OpenMM molecular dynamics engine has its own module in haddock3, where users can setup short molecular dynamics similation using openMM.
It can be used as a refinement module, in implicit or explicit solvent.
Note that the use of the <code>[openmm]</code> module is a thirdparty module that requires its own installation procedure that is not part of the standard haddock3 suite.</p>
<h4 id="as-quality-assessment-of-a-docking-pose-2"><a class="header" href="#as-quality-assessment-of-a-docking-pose-2">As quality assessment of a docking pose</a></h4>
<p>Using the <code>[openmm]</code> module allows to run unbiased molecular dynamics simulations in explicit solvent.
Previous work of <a href="https://doi.org/10.1021/acs.jctc.1c00336">Z. Jandova, <em>et al.</em>, <em>J. Chem. Theo. and Comp.</em> 2021</a>, showed that near-native complexes have less deviation from their input structure after 10 ns of simulation.
Setting up such kind of experiment with haddock3 is extremely easy, as it simply requires to use the <code>[openmm]</code> module with an input complex model, followed by the <code>[caprieval]</code> using the same input complex as reference structure.
This will allow to track how far from the original pose the final frame reached.</p>
<p>Here is an example configuration file:</p>
<pre><code class="language-toml"># General parameters
run_dir = "md_to_the_rescue"
molecules = "model_1.pdb"

[topoaa]
[openmm]
# Define the timesteps
timestep_ps = 0.002  # default parameter
# Increase the simulation timesteps (500000 * 0.002 = 10 ns)
simulation_timesteps = 5000000
# Save 100 intermediate frames
save_intermediate = 100
# Define force-field
forcefield = 'amber14-all.xml'  # default parameter
# Use TIP3P explicit water model
explicit_solvent_model = 'amber14/tip3p.xml'  # default parameter
# Keep HBonds rigid
constraints = 'HBonds'  # default parameter
# Generate a final ensemble composed of all the frames
generate_ensemble = true  # default parameter

[topoaa]
# Compare the generated ensemble with the initial model
[caprieval]
reference_fname = "model_1.pdb"
sort_by = "dockq"
</code></pre>
<p>This protocol has been used during CAPRI round 55 for target 231, to validate the docking poses of the FLAG-peptide on the antibody (see: <a href="https://www.biorxiv.org/content/10.1101/2024.09.16.613212v2">CAPRI rounds 47-55 paper</a>).</p>
<h2 id="peptide-cyclisation-2"><a class="header" href="#peptide-cyclisation-2">Peptide cyclisation</a></h2>
<p>The generation of cyclic peptides usually involve the formation of a disulphide bridge between two cysteins or the formation of a peptide bond between the N-terminus and C-terminus residues.
This can be performed by haddock3 in a two step process, by first generating restraints between the two resiudes involved to induce a pre-cyclic conformation, and then re-generating the topology with an increased range of chemical bond detection (tuning <code>cyclicpept_dist</code>, <code>disulphide_dist</code> and turning on the <code>cyclicpept</code> parameters in <code>[topoaa]</code> module), therefore detecting and creating the covalent cyclic bond and refining again.</p>
<p>Protocol described in: <a href="https://doi.org/10.1021/acs.jctc.2c00075">https://doi.org/10.1021/acs.jctc.2c00075</a></p>
<p>Two examples are provided in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/"><code>examples/peptide-cyclisation/</code></a>:</p>
<ul>
<li>1SFI, a 14 residue cyclic peptide with both backbone and disulphide bridge cyclisation: <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/cyclise-peptide-full.cfg">cyclise-peptide-full.cfg</a></li>
<li>3WNE, a 6 residue backbone cyclic peptide</li>
</ul>
<p>The input peptide was generated using PyMOL, using beta and polyproline initial conformation (available in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb"><code>examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb</code></a>).</p>
<p>The first step is using the <code>[flexref]</code> module, setting the <code>unambig_fname</code> to <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_unambig.tbl">1sfi_unambig.tbl</a> to drive both the backbone and disulphide bridge cyclisation, giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters), increasing the number steps by a factor 10 to allow for more flexible refinement (<code>mdsteps_rigid</code>, <code>mdsteps_cool1</code>, <code>mdsteps_cool2</code>, <code>mdsteps_cool3</code>), turning off the electrostatic <code>elecflag = false</code>. By setting <code>sampling_factor = 200</code>, we will generate 200 replicas with different initial seeds for each of the input conformations (in this case 2).
This is followed by an short molecular dynamics simulation in explicit solvent <code>[mdref]</code>, also giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters).</p>
<p>A RMSD clustering step is perfomed using <code>[rmsdmatrix]</code>, <code>[clustrmsd]</code> (with <code>criterion="maxclust"</code> and <code>n_clusters=50</code>) to generate a subset of 50 clusters, finalized by <code>[seletopclusts]</code> module setting <code>top_models=1</code>, to only extract one single model per clusters.</p>
<p><code>[topoaa]</code> module is then used again to re-generate the topology. In this case the three <strong>important</strong> parameters (<code>cyclicpept_dist</code>, <code>disulphide_dist</code>, and <code>cyclicpept</code>) are set, allowing for the detection of the disulphide bridge and peptide bond at higher distance, therefore generating the proper cyclicised topology.</p>
<p>A second round of <code>[emref]</code>, <code>[flexref]</code> and <code>[mdref]</code> is then performed, allowing to reduce the length of the newly formed chemical bonds and optimise the cyclic peptide conformation.</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the conformation of the peptide with respect to the known reference structure. Note that in this case, only the <code>global_rmsd</code> value is computed, as the structure is not a complex.</p>
<h2 id="scoring-workflow-2"><a class="header" href="#scoring-workflow-2">Scoring workflow</a></h2>
<h2 id="defining-a-haddock3-configuration-file-2"><a class="header" href="#defining-a-haddock3-configuration-file-2">Defining a haddock3 configuration file</a></h2>
<p>This example illustrates the use of Haddock3 for scoring purposes.
In contrast to HADDOCK2.X, Haddock3 can score a heterogenous set of complexes within one run/workflow.
In this example, four different types of complexes are scored within the same workflow:</p>
<ul>
<li>an ensemble of 5 models taken from CAPRI Target161</li>
<li>a protein-DNA complex (model taken from our protein-DNA docking example)</li>
<li>two models of a protein-protein complex (taken from our protein-protein docking example)</li>
<li>a homotrimer model (taken from our protein-homotrimer docking examples)</li>
</ul>
<p>Three scoring workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/emscoring-test.cfg">emscoring-test.cfg</a>: Only a short energy minimisation is performed on each model using <code>[emref]</code> module.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/mdscoring-test.cfg">mdscoring-test.cfg</a>: A short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module. In that case contact AIRs (<code>contactairs = true</code>), dihedral angle restraints on secondary structure element (<code>ssdihed = alphabeta</code>) and DNA restraints (<code>dnarest_on = true</code>) are automatically defined.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/capri-scoring-test.cfg">capri-scoring-test.cfg</a>: An example scoring pipeline using in the CAPRI55 competition, where energy minimisation ()<code>[emref]</code>) is followed by FCC clustering (<code>[clustfcc]</code>) and selection of the top 2 models per cluster (<code>[seletopclusts]</code> with <code>top_models = 2</code>). Then a short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module and the models are clustered again.</li>
</ul>
<p>The model listings with their associated HADDOCK scores can be found in a <code>.tsv</code> file in the stage <code>01_xxx</code> directory of the respective runs.</p>
<h3 id="using-scoring-command-line-2"><a class="header" href="#using-scoring-command-line-2">Using scoring command line</a></h3>
<p>Haddock3 also contain a simple command line interface that allows you to score a single pdb file.
To do so, just run:</p>
<pre><code class="language-bash">haddock3-score complex.pdb
</code></pre>
<p>This command is a short-cut to the following parameter file, and therefore can be really handy, as it simplify a lot the procedure, but is limitted to the scoring of a single model.</p>
<pre><code class="language-toml">run_dir = "tmp_score"
molecules = "complex.pdb"
[topoaa]
[emscoring]
</code></pre>
<p>For more details on the <code>haddock3-score</code> CLI, please refere to <a href="/software/haddock3/module/clis.html#haddock3-score">this section</a>.</p>
<h2 id="analysis-scenario-2"><a class="header" href="#analysis-scenario-2">Analysis scenario</a></h2>
<p>The addition and inclusion of analysis modules in haddock3 is one of its major new strength, as it allows to perform various kind of analysis directly during the workflow.
For the complete list of analysis modules and their capabilities, please refere to the <a href="software/haddock3/manual/modules/analysis.html">Analysis Modules section</a>.</p>
<h3 id="comparison-to-a-reference-structure-2"><a class="header" href="#comparison-to-a-reference-structure-2">Comparison to a reference structure</a></h3>
<p>The <code>[caprieval]</code> module is dedicated to the computation of the CAPRI metrics (rmsd, interface-rmsd, ligand-rmsd, interface-ligand rmsd and dockq) on a set of input models. A reference structure can be provided using the <code>reference_fname</code> parameter. If this parameter is not defined, the best scoring model will be used as reference.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/topoaa-caprieval-test.cfg">topoaa-caprieval-test.cfg</a>.</p>
<h3 id="hot-spot-detection-2"><a class="header" href="#hot-spot-detection-2">Hot spot detection</a></h3>
<p>The analysis of hot-spots and key residues involved in the interaction between two chain can be of valuable information for mutagenesis or design purposes.
The <code>[alascan]</code> module is designed to perform point mutation of residues at the interface of a complex, and evaluate the difference in HADDOCK score with respect to the original input complex. It also splits the scoring function in its various components and generate an interactive graph allowing for a visual representation of the scanned resiudes contributions.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/alascan-test.cfg">alascan-test.cfg</a>.</p>
<h3 id="generation-of-contact-maps-2"><a class="header" href="#generation-of-contact-maps-2">Generation of contact maps</a></h3>
<p>While HADDOCK is producing 3D atomistic models, having the opportunity to have a 2D representation of the complexes can allow to understand at the sequence level the contacts involved in the compelex.
The <code>[contactmap]</code> module is specially designed to produce interactive plots describing the contacts observed in the structures.
It will produce two types of figures:</p>
<ul>
<li>a pair-wise distance matrix between all residues</li>
<li>a chord chart recapitulating the residue-residue contacts observed</li>
</ul>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/contmap-test.cfg">contmap-test.cfg</a></p>
<h3 id="fine-tuning-clustering-parameters-2"><a class="header" href="#fine-tuning-clustering-parameters-2">Fine tuning clustering parameters</a></h3>
<p>Finding the appropriate threshold for the clustering parameters can be quite tricky, and often requires a first trial, followed by manual inspection to understand the content of the dataset.
We are providing examples (for <code>clustrmsd</code> and <code>clustfcc</code>) fine tuning of the parameters with visualisation of the matrices, to help you understand how to investigate the results you obtained after clustering.</p>
<p>Here are the two important step to analyse the structural diversity of you set of complexes in a clustering module:</p>
<ul>
<li>turn on the <code>plot_matrix</code> parameter to obtain a visual representation of the distance matrix.</li>
<li>set the <code>min_population</code> to 1, so even singloton complexes will be forwarded to the next module and displayed on the plot.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-ilrmsdmatrix-clustrmsd.cfg">fine tuning of the <code>clustrmsd</code> parameters</a>.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-clustfcc.cfg">fine tuning of the <code>clustfcc</code> parameters</a>.</li>
</ul>
<p>Note that fine tuning of clustering parameters can also be performed with the <code>haddock3-re</code> command, as both <code>[clustfcc]</code> and <code>[clustrmsd]</code> modules are subcommands of the <code>haddock3-re</code> CLI.</p>
<h1 id="web-application-pre-defined-scenario-2"><a class="header" href="#web-application-pre-defined-scenario-2">Web-application pre-defined scenario</a></h1>
<p><em>comming soon...</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-docking-scenario-3"><a class="header" href="#examples-of-docking-scenario-3">Examples of docking scenario</a></h1>
<p>As creating a new workflow can be complex at the beginning, we are providing a set of pre-defined haddock3 scenarios.
These examples are encompassing a wide range of applications, such as:</p>
<ul>
<li><a href="docking_scenarios.html#protein-protein-docking">Protein-protein docking</a></li>
<li><a href="docking_scenarios.html#protein-peptide-docking">Protein-peptide docking</a></li>
<li><a href="docking_scenarios.html#protein-dna-docking">Protein-DNA docking</a></li>
<li><a href="docking_scenarios.html#antibody-antigen-docking">Antibody-antigen docking</a></li>
<li><a href="docking_scenarios.html#protein-glycan-docking">Protein-glycan docking</a></li>
<li><a href="docking_scenarios.html#small-molecule-docking">Small-molecule docking</a></li>
<li><a href="docking_scenarios.html#refinement-protocols">Complexes refinement protocols</a></li>
<li><a href="docking_scenarios.html#cyclic-peptide">Building cyclic peptide</a></li>
<li><a href="docking_scenarios.html#scoring-workflow">Scoring workflow</a></li>
<li><a href="docking_scenarios.html#analysis-scenario">Analysis pipelines</a></li>
</ul>
<p>Alternatively, up-to-date examples can also be found:</p>
<ul>
<li>in your local installation of haddock3: <code>haddock3/examples/</code>.</li>
<li>online, on our <a href="https://github.com/haddocking/haddock3/tree/main/examples">GitHub repository <code>haddock3/examples/</code></a>.</li>
</ul>
<p>Please note the extension scheme we are using in the provided configuration file examples:</p>
<ul>
<li><strong>*-full.cfg</strong>: we are using the <code>*-full.cfg</code> suffix on protocols that have proper sampling, and therefore could be used in production. These are nice baseline workflow with appropriate parameters, but will obviously require more time to terminate the run. Examples making use of MPI are also provided in some cases, together with an associated job file that should be submitted to the slurm batch system (<strong>*-full-mpi.cfg</strong> and <strong>*-full-mpi.job</strong>). Make sure to adapt the full config files to your own system.</li>
<li><strong>*-test.cfg</strong>: we are using the <code>*-test.cfg</code> suffix on protocols that have low sampling, allowing for fast test of the functionalities present in the workflow. Of note, on a daily basis, we are running most of the <code>*-test.cfg</code> configuration files to make sure the <code>main</code> branch of haddock3 is functional.</li>
</ul>
<h2 id="protein-protein-docking-3"><a class="header" href="#protein-protein-docking-3">Protein-protein docking</a></h2>
<h3 id="two-body-docking-3"><a class="header" href="#two-body-docking-3">Two body docking</a></h3>
<p>Here we provide various examples using the standard HADDOCK2.X workflows, now well established and banchmarked, using <code>[rigidbody]</code> docking (former <em>it0</em>), followed by flexible refinement in torsional angle space with the <code>[flexref]</code> module (former <em>it1</em>), with a final refinement step using molecular dynamics simulation in an explicit solvent shell (<code>[mdref]</code>, former <em>itw</em>) or an energy minimisation step (<code>[emref]</code>).
The final set of complexes is later clustered using Fraction of Common Contacts clustering (FCC) with the <code>[clustfcc]</code> module.</p>
<p>The protein-protein docking example makes use of the NMR chemical shift perturbation data providing information on the residues of binding site to guide the docking.
The NMR-identified residues are defined as active with their surface neighbors as passive (the corresponding AIRs are defined in the <a href="../examples/docking-protein-protein/data/e2a-hpr_air.tbl">e2a-hpr_air.tbl</a> file in the <code>data</code> directory).
This system is the same as described in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-protein-protein-basic/">HADDOCK2.4 basic protein-protein docking tutorial</a>.
For the second molecule (HPR), an ensemble of 10 conformations (taken from the NMR solution structure of this protein) is used as starting point for the docking.
Refer to above tutorial for more details about the system and restraints.</p>
<p>Here are some examples:</p>
<ul>
<li>with molecular dynamics simulation in an explicit solvent shell -&gt; <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-mdref-full.cfg">docking-protein-protein-mdref-full.cfg</a></li>
<li>with an energy minimisation step only: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-full.cfg">docking-protein-protein-full.cfg</a></li>
</ul>
<p>Due to the flexibility allowed by haddock3, a clustering step can now be performed right after the rigidbody sampling, allowing to capture a higher structural diversity by not only relying on the HADDOCK scoring function to select the top ranked models.
Here is an example with an intermediate clustering step after the <code>[rigidbody]</code> docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-cltsel-full.cfg">docking-protein-protein-cltsel-full.cfg</a>.</p>
<h3 id="symmetrical-homotrimer-docking-3"><a class="header" href="#symmetrical-homotrimer-docking-3">Symmetrical homotrimer docking</a></h3>
<p>The homotimer docking scenario, <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-homotrimer">available here</a>, is first performing <code>[rigidbody]</code> docking, followed by <code>[flexref]</code> refinement and a final <code>[emref]</code> energy minimisation step of the complexe.
It also makes use of two types of symmetry restraints:</p>
<ul>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#non-crystallographic-symmetry">non-crystallographic symmetry restraints</a>: to make sure the three chains are having the same conformation.</li>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#rotational-symmetry">C3 symmetry restraints</a>: to obtain solutions respecting the C3 symmetry.</li>
</ul>
<h3 id="multiple-ambiguous-files-3"><a class="header" href="#multiple-ambiguous-files-3">Multiple ambiguous files</a></h3>
<p>In some case, restraints could be obtained from various sources; different experimental methods or multiple predictions.
In this case, knowing which AIR file will be leading to the correct complex can only be assessed once the docking is performed, and maybe some of them will lead to the same solutions.</p>
<p>It is possible to input multiple ambiguous restraints files in a single <code>.tgz</code> archive.
When providing the kind of input, each sampled docking solution will use an other AIR file contained in the archive.
A particular parameter should later be set in the downstream protocol, <code>previous_ambig = true</code>, enabling to use the AIR file used at the <code>[rigidbody]</code> stage and so on.</p>
<p>An example is <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig">provided here</a>.</p>
<p>This example shows how to use HADDOCK3 when several restraint files are available.
It is built upon the results obtained running <a href="https://github.com/haddocking/arctic3d">arctic3d</a> on two proteins forming the complex <code>2GAF</code>.
The presence of multiple interfaces in both structures allows to define several <code>.tbl</code> ambiguous restraint files to be used in the calculations.
At first, these files must be compressed in a <code>.tbl.tgz</code> archive.
During the workflow, the Haddock3 machinery unzips the archive and evenly assigns each <code>.tbl</code> file to a number of models to be generated.
Even if only one sixth of the restraint files contain reasonable information on the interface, Haddock3 is still able to retrieve good docking models in the best-scoring positions.</p>
<p><strong>Note</strong> how the information about restraint files is propagated during the workflow (<code>previous_ambig = true</code> for <code>flexref</code> and <code>emref</code> modules), so that each model is always refined with its corresponding <code>.tbl</code> file.</p>
<p>Importantly, in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig/docking-multiple-tbls-clt-full.cfg">docking-multiple-tbls-clt-full.cfg</a> example the clustering is performed right after the <code>rigidbody</code> module, so as to lump together solutions resulting from the application of different sets of restraints.</p>
<p>The <code>caprieval</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-peptide-docking-3"><a class="header" href="#protein-peptide-docking-3">Protein Peptide docking</a></h2>
<p>The protein-peptide docking example makes use of the knowledge of the binding site on the protein to guide the docking.
The active site residues are defined as active and the peptide as passive (the corresponding AIRs are defined in the <code>ambig.tbl</code> file in the <code>data</code> directory).
This example follows the protocol described in our protein-peptide docking article (<a href="https://dx.plos.org/10.1371/journal.pone.0058769">Trellet et. al. PLoS ONE 8, e58769 (2013)</a>).
For the peptide, an ensemble of three conformations (alpha-helix, polyproline-II and extended) is provided as starting point for the docking.
Those were built using PyMol (instructions on how to do that can be found <a href="https://www.bonvinlab.org/education/molmod_online/simulation/#preparing-the-system">here</a>).</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement and energy minimisation of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-full.cfg">docking-protein-peptide-full.cfg</a></li>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement followed by a final refinement in explicit solvent (water) of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-mdref-full.cfg">docking-protein-peptide-mdref-full.cfg</a></li>
<li>3000 rigidbody docking models, FCC clustering and selection of max 20 models per cluster followed by flexible refinement and energy minimisation (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-cltsel-full.cfg">docking-protein-peptide-cltsel-full.cfg</a>).</li>
</ul>
<p><strong>Note</strong> how the peptide is defined as fully flexible for the refinement phase in <code>[flexref]</code> (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>) and dihedral angle restraints are automatically defined to maintain secondary structure elements (<code>ssdihed = "alphabeta"</code>)</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-dna-docking-3"><a class="header" href="#protein-dna-docking-3">Protein DNA docking</a></h2>
<p>Haddock3 can also deal with nucleic acids, such as DNA and RNA molecules.
In such senario, various important parameters must be set, allowing to:</p>
<ul>
<li>keep the dielectric constant constant: <code>dielec = "cdie"</code></li>
<li>set the dielectric constant to an higher value: <code>epsilon = 78</code></li>
<li>remove the desolvation term from the scroing function, otherwise having a too strong influence due to the phosphate groups: <code>w_desolv = 0</code>.</li>
<li>automatically generate restraints allowing to keep the double stranded DNA 3' and 5' ends together: <code>dnarest_on = true</code>.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li>using a final energy minimisation step: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-full.cfg">docking-protein-DNA-full.cfg</a></li>
<li>refining the interface using MD in a solvent shell: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-mdref-full.cfg">docking-protein-DNA-mdref-full.cfg</a></li>
<li>with an intermediate clustering step after rigidbody docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cltsel-full.cfg">docking-protein-DNA-cltsel-full.cfg</a></li>
<li>using center of mass restraints instead of ambiguous restraints extracted from the literature: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cmrest-test.cfg">docking-protein-DNA-cmrest-test.cfg</a></li>
</ul>
<h2 id="antibody-antigen-docking-3"><a class="header" href="#antibody-antigen-docking-3">Antibody-antigen docking</a></h2>
<p>Multiple antibody - antigen docking configuration files are <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-antibody-antigen">available here</a>.
They encompass various aspects of docking, mainly related to the information available to guide the docking:</p>
<ul>
<li><a href="docking_scenarios.html#no-information-about-the-paratop">No information about the paratop</a>: No information is known about the paratop, therefore tagetting the entire surface accessible resiude of the antigen.</li>
<li><a href="docking_scenarios.html#nmr-informed-paratop">Experimental knowledge of the paratop resiudes</a>: NMR data was aquired and allowed to obtain information about residues involded in the binding on the antigen side.</li>
</ul>
<h3 id="no-information-about-the-paratop-3"><a class="header" href="#no-information-about-the-paratop-3">No information about the paratop</a></h3>
<p>When no information is known about the paratop on the antigen side, our only solution is to rely on the CDR loops of the antibody, as we know that a least a subset of the resiudes on those loops will be part of the interaction.
Two appoaches can then be used:</p>
<ul>
<li>One where a distance restraints file is generated, where CDR loops resiudes are targetting all surface residues on the antigen side.</li>
<li>The other one defining random distance restraints between the CDR loops and random patches on the antigen side.</li>
</ul>
<h4 id="using-surface-accessible-resiudes-3"><a class="header" href="#using-surface-accessible-resiudes-3">Using surface accessible resiudes</a></h4>
<p>Generating restraints guiding the antibody CDR loops towards surface resiudes on the antigen side is a solution that will sample the entire surface of the antigen. For this, two major information must be extracted:</p>
<ul>
<li>The residue indices of the antibody CDR loops: can be predicted using bioinformatics tools such as <a href="https://wenmr.science.uu.nl/proabc2">proABC2</a>.</li>
<li>The surface residue indices of the antigen: can be predicted computed using <code>haddock3-restraints calc_accessibility antigen.pdb</code>.</li>
</ul>
<p>Defining the CDR loops as <code>active</code> residues and all surface residues on the antigen as <code>passive</code>, we can create an ambiguous restraints file <code>ambig.tbl</code>, that will guide the docking sampling the entire surface of the antigen while making sure the CDR loops are interacting. For more details on how to generate restraints, please refere to the <a href="/software/haddock3/manual/restraints_cli.html"><code>haddock3-restraints</code> documention</a>.</p>
<p>For such kind of naive approach, increasing the sampling at the <code>[rigidbody]</code> level is important.</p>
<p>Various examples are available:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full.cfg">docking-antibody-antigen-CDR-accessible-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-clt-full.cfg">docking-antibody-antigen-CDR-accessible-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.cfg">docking-antibody-antigen-CDR-accessible-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.job">docking-antibody-antigen-CDR-accessible-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h4 id="using-random-distance-restraints-3"><a class="header" href="#using-random-distance-restraints-3">Using random distance restraints</a></h4>
<p>An other alternative for pseudo-naive antibody-antigen docking is to define random restraints.
In this case, we will define segments on the antibody CDR loops to limit the search on the antibody side, and do not provide any definition on the antigen side.
By doing so, random residues on the CDR loops will be restraints to random patches on the antigen surface accessible residues.
This is performed in the <code>[rigidbody]</code> module by:</p>
<ul>
<li>turning on the <code>randair</code> parameter</li>
<li>defining 6 segments to define what are the CDR loops residues</li>
<li>increasing the sampling</li>
</ul>
<pre><code class="language-toml"># Turning on the randair parameter
randair = true
# About to define 6 random segments for the antigen
nrair_1 = 6
# Start and end of first CDR loop
rair_sta_1_1 = 26
rair_end_1_1 = 32
# Start and end of second CDR loop
rair_sta_1_2 = 55
rair_end_1_2 = 57
# Start and end of third CDR loop
rair_sta_1_3 = 101
rair_end_1_3 = 108
# Start and end of fourth CDR loop
rair_sta_1_4 = 146
rair_end_1_4 = 152
# Start and end of fifth CDR loop
rair_sta_1_5 = 170
rair_end_1_5 = 172
# Start and end of sixth CDR loop
rair_sta_1_6 = 212
rair_end_1_6 = 215

# Increasing the sampling
sampling = 10000

###
# ....
# Insert other modules here if you want
# ....
###

[flexref]
contactairs = true
</code></pre>
<p>In this case, no AIR restraints files can be accepted (nor <code>unambig</code> and <code>hbond</code> ones).</p>
<p>Note that after random air definition, we will use <code>contactairs = true</code> in later stage modules such as <code>[flexref]</code> and <code>[emref]</code>, generating restraints based on resiudes already in contact, ensuring the complex will not detach.</p>
<p>Here are some examples:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full.cfg">docking-antibody-antigen-ranairCDR-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-clt-full.cfg">docking-antibody-antigen-ranairCDR-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.cfg">docking-antibody-antigen-ranairCDR-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.job">docking-antibody-antigen-ranairCDR-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h3 id="nmr-informed-paratop-3"><a class="header" href="#nmr-informed-paratop-3">NMR informed paratop</a></h3>
<p>An ideal case would be to have information about the antigen paratop.
Coming from experimental methods or bioinformatic predictions, this information is extremly valuable as it will focus the  search by sampling comformations near key residues involed in the interaction.
By generating a dedicated ambiguous restraint file (<code>ambig-CDR-NMR-CSP.tbl</code>), only antigen CDR residues and few residues on the antigen side will be interacting.</p>
<p>Here is an  example: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-NMR-CSP-full.cfg">docking-antibody-antigen-CDR-NMR-CSP-full.cfg</a></p>
<h2 id="protein-glycan-docking-3"><a class="header" href="#protein-glycan-docking-3">Protein glycan docking</a></h2>
<p>A protein-glycan docking example making use of the knowledge of the binding site on the protein to guide the docking. The conformation of the glycan has been obtained from the <a href="http://glycam.org/">GLYCAM webserver</a>, while the structure of the protein is taken from the PDB in its unbound form. In the proposed workflows, a clustering step is always performed after initial docking stage, so as to increase the diversity of the ensemble of models to be refined.</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-glycan/docking-protein-glycan-full.cfg">docking-protein-glycan-full.cfg</a>: 1000 rigidbody docking models, RMSD clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final RMSD clustering for cluster-based scoring. The RMSD clustering assumes a good knowledge of the interface, as the user has to define the residues involved in the binding site by means of the resdic_ parameter.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-protein-glycan-ilrmsd-full.cfg">docking-protein-glycan-ilrmsd-full.cfg</a>: 1000 rigidbody docking models, interface-ligand-RMSD (<code>ilrmsd</code>) clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final ilRMSD clustering for cluster-based scoring. The interface-ligand-RMSD clustering is a more general approach, as it does not require the user to define the residues involved in the binding site. The interface is automatically defined by the residues involved in the protein-glycan interaction in the input models.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-flexref-protein-glycan-full.cfg">docking-flexref-protein-glycan-full.cfg</a>: 500 flexible docking runs + final RMSD clustering for cluster-based scoring. In this case, the rigidbody docking is skipped and the docking is performed at the flexible refinement level. In this case the flexible refinement has more steps than usual (<code>mdsteps_rigid = 5000</code>, <code>mdsteps_cool1 = 5000</code> and so on) and the glycan is defined as fully flexible (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>).</li>
</ul>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>), as in the <a href="docking_scenarios.html#small-molecule-docking">protein-ligand example</a>.</p>
<h2 id="small-molecule-docking-3"><a class="header" href="#small-molecule-docking-3">Small molecule docking</a></h2>
<p>Small molecule docking can also be performed using haddock3.
It requires the use of custom topology and paramter files for the ligand, as it they are out of the scope of the OPLS force-field.
To generate them, please refere to the section: <a href="/software/haddock3/manual/structure_requirements.html#How-to-generate-topology-and-parameters-for-my-ligand">How to generate topology and parameters for my ligand ?</a></p>
<p>Two protocols have been proposed:</p>
<ul>
<li><a href="docking_scenarios.html#template-based-shape-docking">By homology docking using experimental template</a></li>
<li><a href="docking_scenarios.html#using-binding-site-definition">By defining a binding site</a></li>
</ul>
<h3 id="template-based-shape-docking-3"><a class="header" href="#template-based-shape-docking-3">Template-based shape docking</a></h3>
<p>The use of experimental structure as template for docking have been shown to provide helpful information to guide the conformation of the ligand towards both the binding site and an adequate conformation (see: <a href="https://doi.org/10.1007/s10822-019-00244-6">D3R Grand Challenge 4</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0022283624003139">@TOME 3.0</a> and <a href="">CAPRI16 (soon)</a>)</p>
<p>A protein-ligand docking example making use of the knowledge of a template ligand (a ligand similar to the ligand we want to dock and bind to the same receptor).
The template ligand information is used in the form of shape consisting of dummy beads and positioned within the binding site to which distance restraints are defined.
More details about the method and the performance of the protocol when benchmarked on a fully unbound dataset
can be seen in our freely available <a href="https://pubs.acs.org/doi/full/10.1021/acs.jcim.1c00796">paper on JCIM</a>.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule HADDOCK2.4 tutorial</a>, during the docking and refinement the protein and the shape are kept in their original positions (see the <code>mol_fix_origin_X</code> parameters in the config file) and ambiguous distance restraints between the ligand and the shape beads are defined (the corresponding AIRs are defined in the <code>shape-restraints-from-shape-1.tbl</code> file in the <code>data</code> directory).
This is effectively a three body docking.
For the ligand an ensemble of 10 different conformations is provided as starting point for the docking (<code>ligand-ensemble.pdb</code> in the <code>data</code> directory).
Please refer to our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule tutorial</a> for information on how to generate such an ensemble.</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand-shape/docking-protein-ligand-shape-full.cfg">docking-protein-ligand-shape-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models with the protein and shape kept in their origin position, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>).
To allow the ligand to penetrate better into the binding site the intermolecular energy components are scaled down during the rigidbody docking phase (<code>inter_rigid = 0.001</code>).
As for the protein-ligand example, parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h3 id="using-binding-site-definition-3"><a class="header" href="#using-binding-site-definition-3">Using binding site definition</a></h3>
<p>A protein-ligand docking example making use of the knowledge of the binding site on the protein to guide the docking.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-binding-sites/">protein-ligand HADDOCK2.4 tutorial</a>, in the rigidbody docking phase all residues of the binding site are defined as active to draw the ligand into it (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-active-rigidbody.tbl">ambig-active-rigidbody.tbl</a> file in the <code>data</code> directory).
For the flexible refinement only the ligand is defined as active and the binding site as passive to allow the ligand to explore the binding site (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-passive.tbl">ambig-passive.tbl</a> file in the <code>data</code> directory).</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/docking-protein-ligand-full.cfg">docking-protein-ligand-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the <code>[rigidbody]</code> docking models (<code>w_vdw = 1.0</code>) and the skipping of the high temperature first two stages of the simulated annealing protocol during the <code>[flexref]</code> refinement (<code>mdsteps_rigid = 0</code> and <code>mdsteps_cool1 = 0</code>).
Parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="refinement-protocols-3"><a class="header" href="#refinement-protocols-3">Refinement protocols</a></h2>
<p>All refinements examples can be found <a href="https://github.com/haddocking/haddock3/tree/main/examples/refine-complex">here</a>.</p>
<h3 id="short-molecular-dynamics-symulation-in-explicit-solvent-3"><a class="header" href="#short-molecular-dynamics-symulation-in-explicit-solvent-3">Short molecular dynamics symulation in explicit solvent</a></h3>
<p>This example illustrates the refinement of a complex.
In this case (workflow <code>refine-complex-test.cfg</code>) the molecules are kept in their original positions and the complex is subjected to a short flexible refinement in explicit solvent with the <code>[mdref]</code> module.
The same complex as for the <code>docking-protein-protein</code> example is used.
The molecules are defined separately in the config file (and could consist each of an ensemble, provided the two ensembles have exactly the same number of models).</p>
<p>In this example all parameters are left to their default settings, except for manually defining the histidines' protonation states and setting the <code>sampling_factor</code> to 10, which means that from each starting complex 10 models will be generated with different random seeds for initiating the molecular dynamics phase.</p>
<p>The <code>caprieval</code> module is called at the end to assess the quality of the models with respect to the known reference structure.</p>
<p>Here is an example:</p>
<pre><code class="language-toml">run_dir = "mdref_complex_5replicas"
molecules = "model.pdb"

[topoaa]
autohis = false
[topoaa.mol1]
nhisd = 0
nhise = 1
hise_1 = 75
[topoaa.mol2]
nhisd = 1
hisd_1 = 76
nhise = 1
hise_1 = 15

[mdref]
# Setting sampling factor to 10 will generate 
# 10 replicas with different initial seeds to set the velocities
sampling_factor = 10
</code></pre>
<p><a href="https://github.com/haddocking/haddock3/blob/main/examples/refine-complex/refine-complex-test.cfg">Here is a full example</a> with provided input file and also using an experimental reference to track the evolution of the refinement.</p>
<h3 id="openmm-md-simulation-3"><a class="header" href="#openmm-md-simulation-3">OpenMM MD simulation</a></h3>
<p>The OpenMM molecular dynamics engine has its own module in haddock3, where users can setup short molecular dynamics similation using openMM.
It can be used as a refinement module, in implicit or explicit solvent.
Note that the use of the <code>[openmm]</code> module is a thirdparty module that requires its own installation procedure that is not part of the standard haddock3 suite.</p>
<h4 id="as-quality-assessment-of-a-docking-pose-3"><a class="header" href="#as-quality-assessment-of-a-docking-pose-3">As quality assessment of a docking pose</a></h4>
<p>Using the <code>[openmm]</code> module allows to run unbiased molecular dynamics simulations in explicit solvent.
Previous work of <a href="https://doi.org/10.1021/acs.jctc.1c00336">Z. Jandova, <em>et al.</em>, <em>J. Chem. Theo. and Comp.</em> 2021</a>, showed that near-native complexes have less deviation from their input structure after 10 ns of simulation.
Setting up such kind of experiment with haddock3 is extremely easy, as it simply requires to use the <code>[openmm]</code> module with an input complex model, followed by the <code>[caprieval]</code> using the same input complex as reference structure.
This will allow to track how far from the original pose the final frame reached.</p>
<p>Here is an example configuration file:</p>
<pre><code class="language-toml"># General parameters
run_dir = "md_to_the_rescue"
molecules = "model_1.pdb"

[topoaa]
[openmm]
# Define the timesteps
timestep_ps = 0.002  # default parameter
# Increase the simulation timesteps (500000 * 0.002 = 10 ns)
simulation_timesteps = 5000000
# Save 100 intermediate frames
save_intermediate = 100
# Define force-field
forcefield = 'amber14-all.xml'  # default parameter
# Use TIP3P explicit water model
explicit_solvent_model = 'amber14/tip3p.xml'  # default parameter
# Keep HBonds rigid
constraints = 'HBonds'  # default parameter
# Generate a final ensemble composed of all the frames
generate_ensemble = true  # default parameter

[topoaa]
# Compare the generated ensemble with the initial model
[caprieval]
reference_fname = "model_1.pdb"
sort_by = "dockq"
</code></pre>
<p>This protocol has been used during CAPRI round 55 for target 231, to validate the docking poses of the FLAG-peptide on the antibody (see: <a href="https://www.biorxiv.org/content/10.1101/2024.09.16.613212v2">CAPRI rounds 47-55 paper</a>).</p>
<h2 id="peptide-cyclisation-3"><a class="header" href="#peptide-cyclisation-3">Peptide cyclisation</a></h2>
<p>The generation of cyclic peptides usually involve the formation of a disulphide bridge between two cysteins or the formation of a peptide bond between the N-terminus and C-terminus residues.
This can be performed by haddock3 in a two step process, by first generating restraints between the two resiudes involved to induce a pre-cyclic conformation, and then re-generating the topology with an increased range of chemical bond detection (tuning <code>cyclicpept_dist</code>, <code>disulphide_dist</code> and turning on the <code>cyclicpept</code> parameters in <code>[topoaa]</code> module), therefore detecting and creating the covalent cyclic bond and refining again.</p>
<p>Protocol described in: <a href="https://doi.org/10.1021/acs.jctc.2c00075">https://doi.org/10.1021/acs.jctc.2c00075</a></p>
<p>Two examples are provided in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/"><code>examples/peptide-cyclisation/</code></a>:</p>
<ul>
<li>1SFI, a 14 residue cyclic peptide with both backbone and disulphide bridge cyclisation: <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/cyclise-peptide-full.cfg">cyclise-peptide-full.cfg</a></li>
<li>3WNE, a 6 residue backbone cyclic peptide</li>
</ul>
<p>The input peptide was generated using PyMOL, using beta and polyproline initial conformation (available in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb"><code>examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb</code></a>).</p>
<p>The first step is using the <code>[flexref]</code> module, setting the <code>unambig_fname</code> to <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_unambig.tbl">1sfi_unambig.tbl</a> to drive both the backbone and disulphide bridge cyclisation, giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters), increasing the number steps by a factor 10 to allow for more flexible refinement (<code>mdsteps_rigid</code>, <code>mdsteps_cool1</code>, <code>mdsteps_cool2</code>, <code>mdsteps_cool3</code>), turning off the electrostatic <code>elecflag = false</code>. By setting <code>sampling_factor = 200</code>, we will generate 200 replicas with different initial seeds for each of the input conformations (in this case 2).
This is followed by an short molecular dynamics simulation in explicit solvent <code>[mdref]</code>, also giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters).</p>
<p>A RMSD clustering step is perfomed using <code>[rmsdmatrix]</code>, <code>[clustrmsd]</code> (with <code>criterion="maxclust"</code> and <code>n_clusters=50</code>) to generate a subset of 50 clusters, finalized by <code>[seletopclusts]</code> module setting <code>top_models=1</code>, to only extract one single model per clusters.</p>
<p><code>[topoaa]</code> module is then used again to re-generate the topology. In this case the three <strong>important</strong> parameters (<code>cyclicpept_dist</code>, <code>disulphide_dist</code>, and <code>cyclicpept</code>) are set, allowing for the detection of the disulphide bridge and peptide bond at higher distance, therefore generating the proper cyclicised topology.</p>
<p>A second round of <code>[emref]</code>, <code>[flexref]</code> and <code>[mdref]</code> is then performed, allowing to reduce the length of the newly formed chemical bonds and optimise the cyclic peptide conformation.</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the conformation of the peptide with respect to the known reference structure. Note that in this case, only the <code>global_rmsd</code> value is computed, as the structure is not a complex.</p>
<h2 id="scoring-workflow-3"><a class="header" href="#scoring-workflow-3">Scoring workflow</a></h2>
<h2 id="defining-a-haddock3-configuration-file-3"><a class="header" href="#defining-a-haddock3-configuration-file-3">Defining a haddock3 configuration file</a></h2>
<p>This example illustrates the use of Haddock3 for scoring purposes.
In contrast to HADDOCK2.X, Haddock3 can score a heterogenous set of complexes within one run/workflow.
In this example, four different types of complexes are scored within the same workflow:</p>
<ul>
<li>an ensemble of 5 models taken from CAPRI Target161</li>
<li>a protein-DNA complex (model taken from our protein-DNA docking example)</li>
<li>two models of a protein-protein complex (taken from our protein-protein docking example)</li>
<li>a homotrimer model (taken from our protein-homotrimer docking examples)</li>
</ul>
<p>Three scoring workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/emscoring-test.cfg">emscoring-test.cfg</a>: Only a short energy minimisation is performed on each model using <code>[emref]</code> module.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/mdscoring-test.cfg">mdscoring-test.cfg</a>: A short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module. In that case contact AIRs (<code>contactairs = true</code>), dihedral angle restraints on secondary structure element (<code>ssdihed = alphabeta</code>) and DNA restraints (<code>dnarest_on = true</code>) are automatically defined.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/capri-scoring-test.cfg">capri-scoring-test.cfg</a>: An example scoring pipeline using in the CAPRI55 competition, where energy minimisation ()<code>[emref]</code>) is followed by FCC clustering (<code>[clustfcc]</code>) and selection of the top 2 models per cluster (<code>[seletopclusts]</code> with <code>top_models = 2</code>). Then a short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module and the models are clustered again.</li>
</ul>
<p>The model listings with their associated HADDOCK scores can be found in a <code>.tsv</code> file in the stage <code>01_xxx</code> directory of the respective runs.</p>
<h3 id="using-scoring-command-line-3"><a class="header" href="#using-scoring-command-line-3">Using scoring command line</a></h3>
<p>Haddock3 also contain a simple command line interface that allows you to score a single pdb file.
To do so, just run:</p>
<pre><code class="language-bash">haddock3-score complex.pdb
</code></pre>
<p>This command is a short-cut to the following parameter file, and therefore can be really handy, as it simplify a lot the procedure, but is limitted to the scoring of a single model.</p>
<pre><code class="language-toml">run_dir = "tmp_score"
molecules = "complex.pdb"
[topoaa]
[emscoring]
</code></pre>
<p>For more details on the <code>haddock3-score</code> CLI, please refere to <a href="/software/haddock3/module/clis.html#haddock3-score">this section</a>.</p>
<h2 id="analysis-scenario-3"><a class="header" href="#analysis-scenario-3">Analysis scenario</a></h2>
<p>The addition and inclusion of analysis modules in haddock3 is one of its major new strength, as it allows to perform various kind of analysis directly during the workflow.
For the complete list of analysis modules and their capabilities, please refere to the <a href="software/haddock3/manual/modules/analysis.html">Analysis Modules section</a>.</p>
<h3 id="comparison-to-a-reference-structure-3"><a class="header" href="#comparison-to-a-reference-structure-3">Comparison to a reference structure</a></h3>
<p>The <code>[caprieval]</code> module is dedicated to the computation of the CAPRI metrics (rmsd, interface-rmsd, ligand-rmsd, interface-ligand rmsd and dockq) on a set of input models. A reference structure can be provided using the <code>reference_fname</code> parameter. If this parameter is not defined, the best scoring model will be used as reference.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/topoaa-caprieval-test.cfg">topoaa-caprieval-test.cfg</a>.</p>
<h3 id="hot-spot-detection-3"><a class="header" href="#hot-spot-detection-3">Hot spot detection</a></h3>
<p>The analysis of hot-spots and key residues involved in the interaction between two chain can be of valuable information for mutagenesis or design purposes.
The <code>[alascan]</code> module is designed to perform point mutation of residues at the interface of a complex, and evaluate the difference in HADDOCK score with respect to the original input complex. It also splits the scoring function in its various components and generate an interactive graph allowing for a visual representation of the scanned resiudes contributions.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/alascan-test.cfg">alascan-test.cfg</a>.</p>
<h3 id="generation-of-contact-maps-3"><a class="header" href="#generation-of-contact-maps-3">Generation of contact maps</a></h3>
<p>While HADDOCK is producing 3D atomistic models, having the opportunity to have a 2D representation of the complexes can allow to understand at the sequence level the contacts involved in the compelex.
The <code>[contactmap]</code> module is specially designed to produce interactive plots describing the contacts observed in the structures.
It will produce two types of figures:</p>
<ul>
<li>a pair-wise distance matrix between all residues</li>
<li>a chord chart recapitulating the residue-residue contacts observed</li>
</ul>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/contmap-test.cfg">contmap-test.cfg</a></p>
<h3 id="fine-tuning-clustering-parameters-3"><a class="header" href="#fine-tuning-clustering-parameters-3">Fine tuning clustering parameters</a></h3>
<p>Finding the appropriate threshold for the clustering parameters can be quite tricky, and often requires a first trial, followed by manual inspection to understand the content of the dataset.
We are providing examples (for <code>clustrmsd</code> and <code>clustfcc</code>) fine tuning of the parameters with visualisation of the matrices, to help you understand how to investigate the results you obtained after clustering.</p>
<p>Here are the two important step to analyse the structural diversity of you set of complexes in a clustering module:</p>
<ul>
<li>turn on the <code>plot_matrix</code> parameter to obtain a visual representation of the distance matrix.</li>
<li>set the <code>min_population</code> to 1, so even singloton complexes will be forwarded to the next module and displayed on the plot.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-ilrmsdmatrix-clustrmsd.cfg">fine tuning of the <code>clustrmsd</code> parameters</a>.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-clustfcc.cfg">fine tuning of the <code>clustfcc</code> parameters</a>.</li>
</ul>
<p>Note that fine tuning of clustering parameters can also be performed with the <code>haddock3-re</code> command, as both <code>[clustfcc]</code> and <code>[clustrmsd]</code> modules are subcommands of the <code>haddock3-re</code> CLI.</p>
<h1 id="web-application-pre-defined-scenario-3"><a class="header" href="#web-application-pre-defined-scenario-3">Web-application pre-defined scenario</a></h1>
<p><em>comming soon...</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-docking-scenario-4"><a class="header" href="#examples-of-docking-scenario-4">Examples of docking scenario</a></h1>
<p>As creating a new workflow can be complex at the beginning, we are providing a set of pre-defined haddock3 scenarios.
These examples are encompassing a wide range of applications, such as:</p>
<ul>
<li><a href="docking_scenarios.html#protein-protein-docking">Protein-protein docking</a></li>
<li><a href="docking_scenarios.html#protein-peptide-docking">Protein-peptide docking</a></li>
<li><a href="docking_scenarios.html#protein-dna-docking">Protein-DNA docking</a></li>
<li><a href="docking_scenarios.html#antibody-antigen-docking">Antibody-antigen docking</a></li>
<li><a href="docking_scenarios.html#protein-glycan-docking">Protein-glycan docking</a></li>
<li><a href="docking_scenarios.html#small-molecule-docking">Small-molecule docking</a></li>
<li><a href="docking_scenarios.html#refinement-protocols">Complexes refinement protocols</a></li>
<li><a href="docking_scenarios.html#cyclic-peptide">Building cyclic peptide</a></li>
<li><a href="docking_scenarios.html#scoring-workflow">Scoring workflow</a></li>
<li><a href="docking_scenarios.html#analysis-scenario">Analysis pipelines</a></li>
</ul>
<p>Alternatively, up-to-date examples can also be found:</p>
<ul>
<li>in your local installation of haddock3: <code>haddock3/examples/</code>.</li>
<li>online, on our <a href="https://github.com/haddocking/haddock3/tree/main/examples">GitHub repository <code>haddock3/examples/</code></a>.</li>
</ul>
<p>Please note the extension scheme we are using in the provided configuration file examples:</p>
<ul>
<li><strong>*-full.cfg</strong>: we are using the <code>*-full.cfg</code> suffix on protocols that have proper sampling, and therefore could be used in production. These are nice baseline workflow with appropriate parameters, but will obviously require more time to terminate the run. Examples making use of MPI are also provided in some cases, together with an associated job file that should be submitted to the slurm batch system (<strong>*-full-mpi.cfg</strong> and <strong>*-full-mpi.job</strong>). Make sure to adapt the full config files to your own system.</li>
<li><strong>*-test.cfg</strong>: we are using the <code>*-test.cfg</code> suffix on protocols that have low sampling, allowing for fast test of the functionalities present in the workflow. Of note, on a daily basis, we are running most of the <code>*-test.cfg</code> configuration files to make sure the <code>main</code> branch of haddock3 is functional.</li>
</ul>
<h2 id="protein-protein-docking-4"><a class="header" href="#protein-protein-docking-4">Protein-protein docking</a></h2>
<h3 id="two-body-docking-4"><a class="header" href="#two-body-docking-4">Two body docking</a></h3>
<p>Here we provide various examples using the standard HADDOCK2.X workflows, now well established and banchmarked, using <code>[rigidbody]</code> docking (former <em>it0</em>), followed by flexible refinement in torsional angle space with the <code>[flexref]</code> module (former <em>it1</em>), with a final refinement step using molecular dynamics simulation in an explicit solvent shell (<code>[mdref]</code>, former <em>itw</em>) or an energy minimisation step (<code>[emref]</code>).
The final set of complexes is later clustered using Fraction of Common Contacts clustering (FCC) with the <code>[clustfcc]</code> module.</p>
<p>The protein-protein docking example makes use of the NMR chemical shift perturbation data providing information on the residues of binding site to guide the docking.
The NMR-identified residues are defined as active with their surface neighbors as passive (the corresponding AIRs are defined in the <a href="../examples/docking-protein-protein/data/e2a-hpr_air.tbl">e2a-hpr_air.tbl</a> file in the <code>data</code> directory).
This system is the same as described in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-protein-protein-basic/">HADDOCK2.4 basic protein-protein docking tutorial</a>.
For the second molecule (HPR), an ensemble of 10 conformations (taken from the NMR solution structure of this protein) is used as starting point for the docking.
Refer to above tutorial for more details about the system and restraints.</p>
<p>Here are some examples:</p>
<ul>
<li>with molecular dynamics simulation in an explicit solvent shell -&gt; <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-mdref-full.cfg">docking-protein-protein-mdref-full.cfg</a></li>
<li>with an energy minimisation step only: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-full.cfg">docking-protein-protein-full.cfg</a></li>
</ul>
<p>Due to the flexibility allowed by haddock3, a clustering step can now be performed right after the rigidbody sampling, allowing to capture a higher structural diversity by not only relying on the HADDOCK scoring function to select the top ranked models.
Here is an example with an intermediate clustering step after the <code>[rigidbody]</code> docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-protein/docking-protein-protein-cltsel-full.cfg">docking-protein-protein-cltsel-full.cfg</a>.</p>
<h3 id="symmetrical-homotrimer-docking-4"><a class="header" href="#symmetrical-homotrimer-docking-4">Symmetrical homotrimer docking</a></h3>
<p>The homotimer docking scenario, <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-homotrimer">available here</a>, is first performing <code>[rigidbody]</code> docking, followed by <code>[flexref]</code> refinement and a final <code>[emref]</code> energy minimisation step of the complexe.
It also makes use of two types of symmetry restraints:</p>
<ul>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#non-crystallographic-symmetry">non-crystallographic symmetry restraints</a>: to make sure the three chains are having the same conformation.</li>
<li><a href="/software/haddock3/manual/symmetry_restraints.html#rotational-symmetry">C3 symmetry restraints</a>: to obtain solutions respecting the C3 symmetry.</li>
</ul>
<h3 id="multiple-ambiguous-files-4"><a class="header" href="#multiple-ambiguous-files-4">Multiple ambiguous files</a></h3>
<p>In some case, restraints could be obtained from various sources; different experimental methods or multiple predictions.
In this case, knowing which AIR file will be leading to the correct complex can only be assessed once the docking is performed, and maybe some of them will lead to the same solutions.</p>
<p>It is possible to input multiple ambiguous restraints files in a single <code>.tgz</code> archive.
When providing the kind of input, each sampled docking solution will use an other AIR file contained in the archive.
A particular parameter should later be set in the downstream protocol, <code>previous_ambig = true</code>, enabling to use the AIR file used at the <code>[rigidbody]</code> stage and so on.</p>
<p>An example is <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig">provided here</a>.</p>
<p>This example shows how to use HADDOCK3 when several restraint files are available.
It is built upon the results obtained running <a href="https://github.com/haddocking/arctic3d">arctic3d</a> on two proteins forming the complex <code>2GAF</code>.
The presence of multiple interfaces in both structures allows to define several <code>.tbl</code> ambiguous restraint files to be used in the calculations.
At first, these files must be compressed in a <code>.tbl.tgz</code> archive.
During the workflow, the Haddock3 machinery unzips the archive and evenly assigns each <code>.tbl</code> file to a number of models to be generated.
Even if only one sixth of the restraint files contain reasonable information on the interface, Haddock3 is still able to retrieve good docking models in the best-scoring positions.</p>
<p><strong>Note</strong> how the information about restraint files is propagated during the workflow (<code>previous_ambig = true</code> for <code>flexref</code> and <code>emref</code> modules), so that each model is always refined with its corresponding <code>.tbl</code> file.</p>
<p>Importantly, in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-multiple-ambig/docking-multiple-tbls-clt-full.cfg">docking-multiple-tbls-clt-full.cfg</a> example the clustering is performed right after the <code>rigidbody</code> module, so as to lump together solutions resulting from the application of different sets of restraints.</p>
<p>The <code>caprieval</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-peptide-docking-4"><a class="header" href="#protein-peptide-docking-4">Protein Peptide docking</a></h2>
<p>The protein-peptide docking example makes use of the knowledge of the binding site on the protein to guide the docking.
The active site residues are defined as active and the peptide as passive (the corresponding AIRs are defined in the <code>ambig.tbl</code> file in the <code>data</code> directory).
This example follows the protocol described in our protein-peptide docking article (<a href="https://dx.plos.org/10.1371/journal.pone.0058769">Trellet et. al. PLoS ONE 8, e58769 (2013)</a>).
For the peptide, an ensemble of three conformations (alpha-helix, polyproline-II and extended) is provided as starting point for the docking.
Those were built using PyMol (instructions on how to do that can be found <a href="https://www.bonvinlab.org/education/molmod_online/simulation/#preparing-the-system">here</a>).</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement and energy minimisation of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-full.cfg">docking-protein-peptide-full.cfg</a></li>
<li>3000 rigidbody docking models, selection of top 400 and flexible refinement followed by a final refinement in explicit solvent (water) of those (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-mdref-full.cfg">docking-protein-peptide-mdref-full.cfg</a></li>
<li>3000 rigidbody docking models, FCC clustering and selection of max 20 models per cluster followed by flexible refinement and energy minimisation (<a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-peptide/docking-protein-peptide-cltsel-full.cfg">docking-protein-peptide-cltsel-full.cfg</a>).</li>
</ul>
<p><strong>Note</strong> how the peptide is defined as fully flexible for the refinement phase in <code>[flexref]</code> (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>) and dihedral angle restraints are automatically defined to maintain secondary structure elements (<code>ssdihed = "alphabeta"</code>)</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="protein-dna-docking-4"><a class="header" href="#protein-dna-docking-4">Protein DNA docking</a></h2>
<p>Haddock3 can also deal with nucleic acids, such as DNA and RNA molecules.
In such senario, various important parameters must be set, allowing to:</p>
<ul>
<li>keep the dielectric constant constant: <code>dielec = "cdie"</code></li>
<li>set the dielectric constant to an higher value: <code>epsilon = 78</code></li>
<li>remove the desolvation term from the scroing function, otherwise having a too strong influence due to the phosphate groups: <code>w_desolv = 0</code>.</li>
<li>automatically generate restraints allowing to keep the double stranded DNA 3' and 5' ends together: <code>dnarest_on = true</code>.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li>using a final energy minimisation step: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-full.cfg">docking-protein-DNA-full.cfg</a></li>
<li>refining the interface using MD in a solvent shell: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-mdref-full.cfg">docking-protein-DNA-mdref-full.cfg</a></li>
<li>with an intermediate clustering step after rigidbody docking: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cltsel-full.cfg">docking-protein-DNA-cltsel-full.cfg</a></li>
<li>using center of mass restraints instead of ambiguous restraints extracted from the literature: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-DNA/docking-protein-DNA-cmrest-test.cfg">docking-protein-DNA-cmrest-test.cfg</a></li>
</ul>
<h2 id="antibody-antigen-docking-4"><a class="header" href="#antibody-antigen-docking-4">Antibody-antigen docking</a></h2>
<p>Multiple antibody - antigen docking configuration files are <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-antibody-antigen">available here</a>.
They encompass various aspects of docking, mainly related to the information available to guide the docking:</p>
<ul>
<li><a href="docking_scenarios.html#no-information-about-the-paratop">No information about the paratop</a>: No information is known about the paratop, therefore tagetting the entire surface accessible resiude of the antigen.</li>
<li><a href="docking_scenarios.html#nmr-informed-paratop">Experimental knowledge of the paratop resiudes</a>: NMR data was aquired and allowed to obtain information about residues involded in the binding on the antigen side.</li>
</ul>
<h3 id="no-information-about-the-paratop-4"><a class="header" href="#no-information-about-the-paratop-4">No information about the paratop</a></h3>
<p>When no information is known about the paratop on the antigen side, our only solution is to rely on the CDR loops of the antibody, as we know that a least a subset of the resiudes on those loops will be part of the interaction.
Two appoaches can then be used:</p>
<ul>
<li>One where a distance restraints file is generated, where CDR loops resiudes are targetting all surface residues on the antigen side.</li>
<li>The other one defining random distance restraints between the CDR loops and random patches on the antigen side.</li>
</ul>
<h4 id="using-surface-accessible-resiudes-4"><a class="header" href="#using-surface-accessible-resiudes-4">Using surface accessible resiudes</a></h4>
<p>Generating restraints guiding the antibody CDR loops towards surface resiudes on the antigen side is a solution that will sample the entire surface of the antigen. For this, two major information must be extracted:</p>
<ul>
<li>The residue indices of the antibody CDR loops: can be predicted using bioinformatics tools such as <a href="https://wenmr.science.uu.nl/proabc2">proABC2</a>.</li>
<li>The surface residue indices of the antigen: can be predicted computed using <code>haddock3-restraints calc_accessibility antigen.pdb</code>.</li>
</ul>
<p>Defining the CDR loops as <code>active</code> residues and all surface residues on the antigen as <code>passive</code>, we can create an ambiguous restraints file <code>ambig.tbl</code>, that will guide the docking sampling the entire surface of the antigen while making sure the CDR loops are interacting. For more details on how to generate restraints, please refere to the <a href="/software/haddock3/manual/restraints_cli.html"><code>haddock3-restraints</code> documention</a>.</p>
<p>For such kind of naive approach, increasing the sampling at the <code>[rigidbody]</code> level is important.</p>
<p>Various examples are available:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full.cfg">docking-antibody-antigen-CDR-accessible-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-clt-full.cfg">docking-antibody-antigen-CDR-accessible-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.cfg">docking-antibody-antigen-CDR-accessible-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-accessible-full-mpi.job">docking-antibody-antigen-CDR-accessible-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h4 id="using-random-distance-restraints-4"><a class="header" href="#using-random-distance-restraints-4">Using random distance restraints</a></h4>
<p>An other alternative for pseudo-naive antibody-antigen docking is to define random restraints.
In this case, we will define segments on the antibody CDR loops to limit the search on the antibody side, and do not provide any definition on the antigen side.
By doing so, random residues on the CDR loops will be restraints to random patches on the antigen surface accessible residues.
This is performed in the <code>[rigidbody]</code> module by:</p>
<ul>
<li>turning on the <code>randair</code> parameter</li>
<li>defining 6 segments to define what are the CDR loops residues</li>
<li>increasing the sampling</li>
</ul>
<pre><code class="language-toml"># Turning on the randair parameter
randair = true
# About to define 6 random segments for the antigen
nrair_1 = 6
# Start and end of first CDR loop
rair_sta_1_1 = 26
rair_end_1_1 = 32
# Start and end of second CDR loop
rair_sta_1_2 = 55
rair_end_1_2 = 57
# Start and end of third CDR loop
rair_sta_1_3 = 101
rair_end_1_3 = 108
# Start and end of fourth CDR loop
rair_sta_1_4 = 146
rair_end_1_4 = 152
# Start and end of fifth CDR loop
rair_sta_1_5 = 170
rair_end_1_5 = 172
# Start and end of sixth CDR loop
rair_sta_1_6 = 212
rair_end_1_6 = 215

# Increasing the sampling
sampling = 10000

###
# ....
# Insert other modules here if you want
# ....
###

[flexref]
contactairs = true
</code></pre>
<p>In this case, no AIR restraints files can be accepted (nor <code>unambig</code> and <code>hbond</code> ones).</p>
<p>Note that after random air definition, we will use <code>contactairs = true</code> in later stage modules such as <code>[flexref]</code> and <code>[emref]</code>, generating restraints based on resiudes already in contact, ensuring the complex will not detach.</p>
<p>Here are some examples:</p>
<ul>
<li>standard HADDOCK workflow: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full.cfg">docking-antibody-antigen-ranairCDR-full.cfg</a></li>
<li>with intermediate clustering steps: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-clt-full.cfg">docking-antibody-antigen-ranairCDR-clt-full.cfg</a></li>
<li>using MPI to spread the workload:
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.cfg">docking-antibody-antigen-ranairCDR-full-mpi.cfg</a></li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-ranairCDR-full-mpi.job">docking-antibody-antigen-ranairCDR-full-mpi.job</a></li>
</ul>
</li>
</ul>
<h3 id="nmr-informed-paratop-4"><a class="header" href="#nmr-informed-paratop-4">NMR informed paratop</a></h3>
<p>An ideal case would be to have information about the antigen paratop.
Coming from experimental methods or bioinformatic predictions, this information is extremly valuable as it will focus the  search by sampling comformations near key residues involed in the interaction.
By generating a dedicated ambiguous restraint file (<code>ambig-CDR-NMR-CSP.tbl</code>), only antigen CDR residues and few residues on the antigen side will be interacting.</p>
<p>Here is an  example: <a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-antibody-antigen/docking-antibody-antigen-CDR-NMR-CSP-full.cfg">docking-antibody-antigen-CDR-NMR-CSP-full.cfg</a></p>
<h2 id="protein-glycan-docking-4"><a class="header" href="#protein-glycan-docking-4">Protein glycan docking</a></h2>
<p>A protein-glycan docking example making use of the knowledge of the binding site on the protein to guide the docking. The conformation of the glycan has been obtained from the <a href="http://glycam.org/">GLYCAM webserver</a>, while the structure of the protein is taken from the PDB in its unbound form. In the proposed workflows, a clustering step is always performed after initial docking stage, so as to increase the diversity of the ensemble of models to be refined.</p>
<p>Three different workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/docking-protein-glycan/docking-protein-glycan-full.cfg">docking-protein-glycan-full.cfg</a>: 1000 rigidbody docking models, RMSD clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final RMSD clustering for cluster-based scoring. The RMSD clustering assumes a good knowledge of the interface, as the user has to define the residues involved in the binding site by means of the resdic_ parameter.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-protein-glycan-ilrmsd-full.cfg">docking-protein-glycan-ilrmsd-full.cfg</a>: 1000 rigidbody docking models, interface-ligand-RMSD (<code>ilrmsd</code>) clustering to select 50 clusters, flexible refinement of the top 5 models of each cluster, final ilRMSD clustering for cluster-based scoring. The interface-ligand-RMSD clustering is a more general approach, as it does not require the user to define the residues involved in the binding site. The interface is automatically defined by the residues involved in the protein-glycan interaction in the input models.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/examples/docking-protein-glycan/docking-flexref-protein-glycan-full.cfg">docking-flexref-protein-glycan-full.cfg</a>: 500 flexible docking runs + final RMSD clustering for cluster-based scoring. In this case, the rigidbody docking is skipped and the docking is performed at the flexible refinement level. In this case the flexible refinement has more steps than usual (<code>mdsteps_rigid = 5000</code>, <code>mdsteps_cool1 = 5000</code> and so on) and the glycan is defined as fully flexible (<code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code>).</li>
</ul>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>), as in the <a href="docking_scenarios.html#small-molecule-docking">protein-ligand example</a>.</p>
<h2 id="small-molecule-docking-4"><a class="header" href="#small-molecule-docking-4">Small molecule docking</a></h2>
<p>Small molecule docking can also be performed using haddock3.
It requires the use of custom topology and paramter files for the ligand, as it they are out of the scope of the OPLS force-field.
To generate them, please refere to the section: <a href="/software/haddock3/manual/structure_requirements.html#How-to-generate-topology-and-parameters-for-my-ligand">How to generate topology and parameters for my ligand ?</a></p>
<p>Two protocols have been proposed:</p>
<ul>
<li><a href="docking_scenarios.html#template-based-shape-docking">By homology docking using experimental template</a></li>
<li><a href="docking_scenarios.html#using-binding-site-definition">By defining a binding site</a></li>
</ul>
<h3 id="template-based-shape-docking-4"><a class="header" href="#template-based-shape-docking-4">Template-based shape docking</a></h3>
<p>The use of experimental structure as template for docking have been shown to provide helpful information to guide the conformation of the ligand towards both the binding site and an adequate conformation (see: <a href="https://doi.org/10.1007/s10822-019-00244-6">D3R Grand Challenge 4</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0022283624003139">@TOME 3.0</a> and <a href="">CAPRI16 (soon)</a>)</p>
<p>A protein-ligand docking example making use of the knowledge of a template ligand (a ligand similar to the ligand we want to dock and bind to the same receptor).
The template ligand information is used in the form of shape consisting of dummy beads and positioned within the binding site to which distance restraints are defined.
More details about the method and the performance of the protocol when benchmarked on a fully unbound dataset
can be seen in our freely available <a href="https://pubs.acs.org/doi/full/10.1021/acs.jcim.1c00796">paper on JCIM</a>.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule HADDOCK2.4 tutorial</a>, during the docking and refinement the protein and the shape are kept in their original positions (see the <code>mol_fix_origin_X</code> parameters in the config file) and ambiguous distance restraints between the ligand and the shape beads are defined (the corresponding AIRs are defined in the <code>shape-restraints-from-shape-1.tbl</code> file in the <code>data</code> directory).
This is effectively a three body docking.
For the ligand an ensemble of 10 different conformations is provided as starting point for the docking (<code>ligand-ensemble.pdb</code> in the <code>data</code> directory).
Please refer to our <a href="https://www.bonvinlab.org/education/HADDOCK24/shape-small-molecule/">shape small molecule tutorial</a> for information on how to generate such an ensemble.</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand-shape/docking-protein-ligand-shape-full.cfg">docking-protein-ligand-shape-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models with the protein and shape kept in their origin position, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the van der Waals energy term for the scoring of the rigidbody docking models (<code>w_vdw = 1.0</code>).
To allow the ligand to penetrate better into the binding site the intermolecular energy components are scaled down during the rigidbody docking phase (<code>inter_rigid = 0.001</code>).
As for the protein-ligand example, parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h3 id="using-binding-site-definition-4"><a class="header" href="#using-binding-site-definition-4">Using binding site definition</a></h3>
<p>A protein-ligand docking example making use of the knowledge of the binding site on the protein to guide the docking.</p>
<p>As explained in our <a href="https://www.bonvinlab.org/education/HADDOCK24/HADDOCK24-binding-sites/">protein-ligand HADDOCK2.4 tutorial</a>, in the rigidbody docking phase all residues of the binding site are defined as active to draw the ligand into it (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-active-rigidbody.tbl">ambig-active-rigidbody.tbl</a> file in the <code>data</code> directory).
For the flexible refinement only the ligand is defined as active and the binding site as passive to allow the ligand to explore the binding site (the corresponding AIRs are defined in the <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/data/ambig-passive.tbl">ambig-passive.tbl</a> file in the <code>data</code> directory).</p>
<p>The <a href="https://github.com/haddocking/haddock3/tree/main/examples/docking-protein-ligand/docking-protein-ligand-full.cfg">docking-protein-ligand-full.cfg</a> workflow consists of the generation of 1000 rigidbody docking models, selection of top200 and flexible refinement of those.</p>
<p><strong>Note</strong> the modified weight of the Van der Waals energy term for the scoring of the <code>[rigidbody]</code> docking models (<code>w_vdw = 1.0</code>) and the skipping of the high temperature first two stages of the simulated annealing protocol during the <code>[flexref]</code> refinement (<code>mdsteps_rigid = 0</code> and <code>mdsteps_cool1 = 0</code>).
Parameter and topology files must be provided for the ligand (<code>ligand_param_fname = "data/ligand.param"</code> and <code>ligand_top_fname = "data/ligand.top"</code>).
Those were obtained with a local version of PRODRG (<a href="http://scripts.iucr.org/cgi-bin/paper?S0907444904011679">Schüttelkopf and van Aalten Acta Crystallogr. D 60, 1355−1363 (2004)</a>).</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the quality of the models with respect to the known reference structure.</p>
<h2 id="refinement-protocols-4"><a class="header" href="#refinement-protocols-4">Refinement protocols</a></h2>
<p>All refinements examples can be found <a href="https://github.com/haddocking/haddock3/tree/main/examples/refine-complex">here</a>.</p>
<h3 id="short-molecular-dynamics-symulation-in-explicit-solvent-4"><a class="header" href="#short-molecular-dynamics-symulation-in-explicit-solvent-4">Short molecular dynamics symulation in explicit solvent</a></h3>
<p>This example illustrates the refinement of a complex.
In this case (workflow <code>refine-complex-test.cfg</code>) the molecules are kept in their original positions and the complex is subjected to a short flexible refinement in explicit solvent with the <code>[mdref]</code> module.
The same complex as for the <code>docking-protein-protein</code> example is used.
The molecules are defined separately in the config file (and could consist each of an ensemble, provided the two ensembles have exactly the same number of models).</p>
<p>In this example all parameters are left to their default settings, except for manually defining the histidines' protonation states and setting the <code>sampling_factor</code> to 10, which means that from each starting complex 10 models will be generated with different random seeds for initiating the molecular dynamics phase.</p>
<p>The <code>caprieval</code> module is called at the end to assess the quality of the models with respect to the known reference structure.</p>
<p>Here is an example:</p>
<pre><code class="language-toml">run_dir = "mdref_complex_5replicas"
molecules = "model.pdb"

[topoaa]
autohis = false
[topoaa.mol1]
nhisd = 0
nhise = 1
hise_1 = 75
[topoaa.mol2]
nhisd = 1
hisd_1 = 76
nhise = 1
hise_1 = 15

[mdref]
# Setting sampling factor to 10 will generate 
# 10 replicas with different initial seeds to set the velocities
sampling_factor = 10
</code></pre>
<p><a href="https://github.com/haddocking/haddock3/blob/main/examples/refine-complex/refine-complex-test.cfg">Here is a full example</a> with provided input file and also using an experimental reference to track the evolution of the refinement.</p>
<h3 id="openmm-md-simulation-4"><a class="header" href="#openmm-md-simulation-4">OpenMM MD simulation</a></h3>
<p>The OpenMM molecular dynamics engine has its own module in haddock3, where users can setup short molecular dynamics similation using openMM.
It can be used as a refinement module, in implicit or explicit solvent.
Note that the use of the <code>[openmm]</code> module is a thirdparty module that requires its own installation procedure that is not part of the standard haddock3 suite.</p>
<h4 id="as-quality-assessment-of-a-docking-pose-4"><a class="header" href="#as-quality-assessment-of-a-docking-pose-4">As quality assessment of a docking pose</a></h4>
<p>Using the <code>[openmm]</code> module allows to run unbiased molecular dynamics simulations in explicit solvent.
Previous work of <a href="https://doi.org/10.1021/acs.jctc.1c00336">Z. Jandova, <em>et al.</em>, <em>J. Chem. Theo. and Comp.</em> 2021</a>, showed that near-native complexes have less deviation from their input structure after 10 ns of simulation.
Setting up such kind of experiment with haddock3 is extremely easy, as it simply requires to use the <code>[openmm]</code> module with an input complex model, followed by the <code>[caprieval]</code> using the same input complex as reference structure.
This will allow to track how far from the original pose the final frame reached.</p>
<p>Here is an example configuration file:</p>
<pre><code class="language-toml"># General parameters
run_dir = "md_to_the_rescue"
molecules = "model_1.pdb"

[topoaa]
[openmm]
# Define the timesteps
timestep_ps = 0.002  # default parameter
# Increase the simulation timesteps (500000 * 0.002 = 10 ns)
simulation_timesteps = 5000000
# Save 100 intermediate frames
save_intermediate = 100
# Define force-field
forcefield = 'amber14-all.xml'  # default parameter
# Use TIP3P explicit water model
explicit_solvent_model = 'amber14/tip3p.xml'  # default parameter
# Keep HBonds rigid
constraints = 'HBonds'  # default parameter
# Generate a final ensemble composed of all the frames
generate_ensemble = true  # default parameter

[topoaa]
# Compare the generated ensemble with the initial model
[caprieval]
reference_fname = "model_1.pdb"
sort_by = "dockq"
</code></pre>
<p>This protocol has been used during CAPRI round 55 for target 231, to validate the docking poses of the FLAG-peptide on the antibody (see: <a href="https://www.biorxiv.org/content/10.1101/2024.09.16.613212v2">CAPRI rounds 47-55 paper</a>).</p>
<h2 id="peptide-cyclisation-4"><a class="header" href="#peptide-cyclisation-4">Peptide cyclisation</a></h2>
<p>The generation of cyclic peptides usually involve the formation of a disulphide bridge between two cysteins or the formation of a peptide bond between the N-terminus and C-terminus residues.
This can be performed by haddock3 in a two step process, by first generating restraints between the two resiudes involved to induce a pre-cyclic conformation, and then re-generating the topology with an increased range of chemical bond detection (tuning <code>cyclicpept_dist</code>, <code>disulphide_dist</code> and turning on the <code>cyclicpept</code> parameters in <code>[topoaa]</code> module), therefore detecting and creating the covalent cyclic bond and refining again.</p>
<p>Protocol described in: <a href="https://doi.org/10.1021/acs.jctc.2c00075">https://doi.org/10.1021/acs.jctc.2c00075</a></p>
<p>Two examples are provided in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/"><code>examples/peptide-cyclisation/</code></a>:</p>
<ul>
<li>1SFI, a 14 residue cyclic peptide with both backbone and disulphide bridge cyclisation: <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/cyclise-peptide-full.cfg">cyclise-peptide-full.cfg</a></li>
<li>3WNE, a 6 residue backbone cyclic peptide</li>
</ul>
<p>The input peptide was generated using PyMOL, using beta and polyproline initial conformation (available in <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb"><code>examples/peptide-cyclisation/data/1sfi_peptide-ensemble.pdb</code></a>).</p>
<p>The first step is using the <code>[flexref]</code> module, setting the <code>unambig_fname</code> to <a href="https://github.com/haddocking/haddock3/blob/main/examples/peptide-cyclisation/data/1sfi_unambig.tbl">1sfi_unambig.tbl</a> to drive both the backbone and disulphide bridge cyclisation, giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters), increasing the number steps by a factor 10 to allow for more flexible refinement (<code>mdsteps_rigid</code>, <code>mdsteps_cool1</code>, <code>mdsteps_cool2</code>, <code>mdsteps_cool3</code>), turning off the electrostatic <code>elecflag = false</code>. By setting <code>sampling_factor = 200</code>, we will generate 200 replicas with different initial seeds for each of the input conformations (in this case 2).
This is followed by an short molecular dynamics simulation in explicit solvent <code>[mdref]</code>, also giving full flexibility to the peptide (with <code>fle_sta_1</code>, <code>fle_end_1</code>, <code>fle_seg_1</code> parameters).</p>
<p>A RMSD clustering step is perfomed using <code>[rmsdmatrix]</code>, <code>[clustrmsd]</code> (with <code>criterion="maxclust"</code> and <code>n_clusters=50</code>) to generate a subset of 50 clusters, finalized by <code>[seletopclusts]</code> module setting <code>top_models=1</code>, to only extract one single model per clusters.</p>
<p><code>[topoaa]</code> module is then used again to re-generate the topology. In this case the three <strong>important</strong> parameters (<code>cyclicpept_dist</code>, <code>disulphide_dist</code>, and <code>cyclicpept</code>) are set, allowing for the detection of the disulphide bridge and peptide bond at higher distance, therefore generating the proper cyclicised topology.</p>
<p>A second round of <code>[emref]</code>, <code>[flexref]</code> and <code>[mdref]</code> is then performed, allowing to reduce the length of the newly formed chemical bonds and optimise the cyclic peptide conformation.</p>
<p>The <code>[caprieval]</code> module is called at various stages during the workflow to assess the conformation of the peptide with respect to the known reference structure. Note that in this case, only the <code>global_rmsd</code> value is computed, as the structure is not a complex.</p>
<h2 id="scoring-workflow-4"><a class="header" href="#scoring-workflow-4">Scoring workflow</a></h2>
<h2 id="defining-a-haddock3-configuration-file-4"><a class="header" href="#defining-a-haddock3-configuration-file-4">Defining a haddock3 configuration file</a></h2>
<p>This example illustrates the use of Haddock3 for scoring purposes.
In contrast to HADDOCK2.X, Haddock3 can score a heterogenous set of complexes within one run/workflow.
In this example, four different types of complexes are scored within the same workflow:</p>
<ul>
<li>an ensemble of 5 models taken from CAPRI Target161</li>
<li>a protein-DNA complex (model taken from our protein-DNA docking example)</li>
<li>two models of a protein-protein complex (taken from our protein-protein docking example)</li>
<li>a homotrimer model (taken from our protein-homotrimer docking examples)</li>
</ul>
<p>Three scoring workflows are illustrated:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/emscoring-test.cfg">emscoring-test.cfg</a>: Only a short energy minimisation is performed on each model using <code>[emref]</code> module.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/mdscoring-test.cfg">mdscoring-test.cfg</a>: A short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module. In that case contact AIRs (<code>contactairs = true</code>), dihedral angle restraints on secondary structure element (<code>ssdihed = alphabeta</code>) and DNA restraints (<code>dnarest_on = true</code>) are automatically defined.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/scoring/capri-scoring-test.cfg">capri-scoring-test.cfg</a>: An example scoring pipeline using in the CAPRI55 competition, where energy minimisation ()<code>[emref]</code>) is followed by FCC clustering (<code>[clustfcc]</code>) and selection of the top 2 models per cluster (<code>[seletopclusts]</code> with <code>top_models = 2</code>). Then a short molecular dynamics simulation in explicit solvent (water) is performed on each model using <code>[mdref]</code> module and the models are clustered again.</li>
</ul>
<p>The model listings with their associated HADDOCK scores can be found in a <code>.tsv</code> file in the stage <code>01_xxx</code> directory of the respective runs.</p>
<h3 id="using-scoring-command-line-4"><a class="header" href="#using-scoring-command-line-4">Using scoring command line</a></h3>
<p>Haddock3 also contain a simple command line interface that allows you to score a single pdb file.
To do so, just run:</p>
<pre><code class="language-bash">haddock3-score complex.pdb
</code></pre>
<p>This command is a short-cut to the following parameter file, and therefore can be really handy, as it simplify a lot the procedure, but is limitted to the scoring of a single model.</p>
<pre><code class="language-toml">run_dir = "tmp_score"
molecules = "complex.pdb"
[topoaa]
[emscoring]
</code></pre>
<p>For more details on the <code>haddock3-score</code> CLI, please refere to <a href="/software/haddock3/module/clis.html#haddock3-score">this section</a>.</p>
<h2 id="analysis-scenario-4"><a class="header" href="#analysis-scenario-4">Analysis scenario</a></h2>
<p>The addition and inclusion of analysis modules in haddock3 is one of its major new strength, as it allows to perform various kind of analysis directly during the workflow.
For the complete list of analysis modules and their capabilities, please refere to the <a href="software/haddock3/manual/modules/analysis.html">Analysis Modules section</a>.</p>
<h3 id="comparison-to-a-reference-structure-4"><a class="header" href="#comparison-to-a-reference-structure-4">Comparison to a reference structure</a></h3>
<p>The <code>[caprieval]</code> module is dedicated to the computation of the CAPRI metrics (rmsd, interface-rmsd, ligand-rmsd, interface-ligand rmsd and dockq) on a set of input models. A reference structure can be provided using the <code>reference_fname</code> parameter. If this parameter is not defined, the best scoring model will be used as reference.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/topoaa-caprieval-test.cfg">topoaa-caprieval-test.cfg</a>.</p>
<h3 id="hot-spot-detection-4"><a class="header" href="#hot-spot-detection-4">Hot spot detection</a></h3>
<p>The analysis of hot-spots and key residues involved in the interaction between two chain can be of valuable information for mutagenesis or design purposes.
The <code>[alascan]</code> module is designed to perform point mutation of residues at the interface of a complex, and evaluate the difference in HADDOCK score with respect to the original input complex. It also splits the scoring function in its various components and generate an interactive graph allowing for a visual representation of the scanned resiudes contributions.</p>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/alascan-test.cfg">alascan-test.cfg</a>.</p>
<h3 id="generation-of-contact-maps-4"><a class="header" href="#generation-of-contact-maps-4">Generation of contact maps</a></h3>
<p>While HADDOCK is producing 3D atomistic models, having the opportunity to have a 2D representation of the complexes can allow to understand at the sequence level the contacts involved in the compelex.
The <code>[contactmap]</code> module is specially designed to produce interactive plots describing the contacts observed in the structures.
It will produce two types of figures:</p>
<ul>
<li>a pair-wise distance matrix between all residues</li>
<li>a chord chart recapitulating the residue-residue contacts observed</li>
</ul>
<p>An example is provided here: <a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/contmap-test.cfg">contmap-test.cfg</a></p>
<h3 id="fine-tuning-clustering-parameters-4"><a class="header" href="#fine-tuning-clustering-parameters-4">Fine tuning clustering parameters</a></h3>
<p>Finding the appropriate threshold for the clustering parameters can be quite tricky, and often requires a first trial, followed by manual inspection to understand the content of the dataset.
We are providing examples (for <code>clustrmsd</code> and <code>clustfcc</code>) fine tuning of the parameters with visualisation of the matrices, to help you understand how to investigate the results you obtained after clustering.</p>
<p>Here are the two important step to analyse the structural diversity of you set of complexes in a clustering module:</p>
<ul>
<li>turn on the <code>plot_matrix</code> parameter to obtain a visual representation of the distance matrix.</li>
<li>set the <code>min_population</code> to 1, so even singloton complexes will be forwarded to the next module and displayed on the plot.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-ilrmsdmatrix-clustrmsd.cfg">fine tuning of the <code>clustrmsd</code> parameters</a>.</li>
<li><a href="https://github.com/haddocking/haddock3/blob/main/examples/analysis/plot-finetune-clustfcc.cfg">fine tuning of the <code>clustfcc</code> parameters</a>.</li>
</ul>
<p>Note that fine tuning of clustering parameters can also be performed with the <code>haddock3-re</code> command, as both <code>[clustfcc]</code> and <code>[clustrmsd]</code> modules are subcommands of the <code>haddock3-re</code> CLI.</p>
<h1 id="web-application-pre-defined-scenario-4"><a class="header" href="#web-application-pre-defined-scenario-4">Web-application pre-defined scenario</a></h1>
<p><em>comming soon...</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-support"><a class="header" href="#user-support">User support</a></h1>
<p>In HADDOCK, not only we want to provide a cutting edge biomolecular docking suite, but we also care about our users.
Several dedicated channels are available for you to ask questions, submit feedback, request new feature you would like to see in haddock3 or simply discuss topics.</p>
<h2 id="code-related-issues"><a class="header" href="#code-related-issues">Code related issues</a></h2>
<p>For code related issues, please refere to the <a href="https://github.com/haddocking/haddock3/issues">GitHub repository issues</a>, which allows us as well as users to track known issues and their progress.</p>
<p>In the GitHub issues, you can <a href="https://github.com/haddocking/haddock3/issues/new/choose">create a new issue</a> related to:</p>
<ul>
<li><strong>Report a bug</strong>: A bug is an error, flaw, or unintended behavior in the software that causes it to produce incorrect or unexpected results, or to behave in unintended ways.</li>
<li><strong>Request for an enhancement/feature</strong>: An enhancement/feature request is a suggestion for new functionality or an enhancement to existing features in the software.</li>
<li><strong>Ask Question</strong>: Question about the source code of the project.</li>
</ul>
<h2 id="related-to-haddock-in-general"><a class="header" href="#related-to-haddock-in-general">Related to HADDOCK in general</a></h2>
<p>The BioExcel forum (<a href="https://ask.bioexcel.eu/">https://ask.bioexcel.eu/</a>) is the exact location where you can ask any question related to HADDOCK (and other BioExcel core applications).
You can search for previous post, as maybe your question has been asked by other scientist before you.
Or create a new post, in which case we will try to answer it as fast as we can.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-support-1"><a class="header" href="#user-support-1">User support</a></h1>
<p>In HADDOCK, not only we want to provide a cutting edge biomolecular docking suite, but we also care about our users.
Several dedicated channels are available for you to ask questions, submit feedback, request new feature you would like to see in haddock3 or simply discuss topics.</p>
<h2 id="code-related-issues-1"><a class="header" href="#code-related-issues-1">Code related issues</a></h2>
<p>For code related issues, please refere to the <a href="https://github.com/haddocking/haddock3/issues">GitHub repository issues</a>, which allows us as well as users to track known issues and their progress.</p>
<p>In the GitHub issues, you can <a href="https://github.com/haddocking/haddock3/issues/new/choose">create a new issue</a> related to:</p>
<ul>
<li><strong>Report a bug</strong>: A bug is an error, flaw, or unintended behavior in the software that causes it to produce incorrect or unexpected results, or to behave in unintended ways.</li>
<li><strong>Request for an enhancement/feature</strong>: An enhancement/feature request is a suggestion for new functionality or an enhancement to existing features in the software.</li>
<li><strong>Ask Question</strong>: Question about the source code of the project.</li>
</ul>
<h2 id="related-to-haddock-in-general-1"><a class="header" href="#related-to-haddock-in-general-1">Related to HADDOCK in general</a></h2>
<p>The BioExcel forum (<a href="https://ask.bioexcel.eu/">https://ask.bioexcel.eu/</a>) is the exact location where you can ask any question related to HADDOCK (and other BioExcel core applications).
You can search for previous post, as maybe your question has been asked by other scientist before you.
Or create a new post, in which case we will try to answer it as fast as we can.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haddock3-tutorial"><a class="header" href="#haddock3-tutorial">Haddock3 tutorial</a></h1>
<p>Haddock3 is not only a tool, but also a set of training materials, allowing to new user to understand the main aspects and functionalities available in haddock3.</p>
<p>The list of tutorial is available from our <a href="/education/HADDOCK3/index.html">laboratory website -&gt; education -&gt; haddock3 -&gt; tutorials</a></p>
<p>Please note that we are constantly adding new tutorials, and therefore new ones may appear from time to time.</p>
<h2 id="haddock2x-tutorial"><a class="header" href="#haddock2x-tutorial">Haddock2.X tutorial</a></h2>
<p>Together with the development of haddock3, we are trying to update and port previously written tutorials made for the haddock2.X series to haddock3.
If a specific tutorial is not available for haddock3, you can always refere to <a href="/education/HADDOCK24/index.html">the haddock2.x tutorials</a> to obtain input files and understand what are the key points required for a sucessful docking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haddock3-tutorial-1"><a class="header" href="#haddock3-tutorial-1">Haddock3 tutorial</a></h1>
<p>Haddock3 is not only a tool, but also a set of training materials, allowing to new user to understand the main aspects and functionalities available in haddock3.</p>
<p>The list of tutorial is available from our <a href="/education/HADDOCK3/index.html">laboratory website -&gt; education -&gt; haddock3 -&gt; tutorials</a></p>
<p>Please note that we are constantly adding new tutorials, and therefore new ones may appear from time to time.</p>
<h2 id="haddock2x-tutorial-1"><a class="header" href="#haddock2x-tutorial-1">Haddock2.X tutorial</a></h2>
<p>Together with the development of haddock3, we are trying to update and port previously written tutorials made for the haddock2.X series to haddock3.
If a specific tutorial is not available for haddock3, you can always refere to <a href="/education/HADDOCK24/index.html">the haddock2.x tutorials</a> to obtain input files and understand what are the key points required for a sucessful docking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haddock-best-practice-guide"><a class="header" href="#haddock-best-practice-guide">HADDOCK best practice guide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haddock3-eco-system"><a class="header" href="#haddock3-eco-system">Haddock3 eco-system</a></h1>
<p>Haddock3 can be used together with other tools that have been developped and maintained by the BonvinLab.</p>
<h2 id="local-installation-of-tools"><a class="header" href="#local-installation-of-tools">Local installation of tools</a></h2>
<p>Here are some usefull links to software that can be useful to solve your research question:</p>
<h3 id="featured-research-software"><a class="header" href="#featured-research-software">Featured research software</a></h3>
<ul>
<li><a href="https://github.com/haddocking/haddock3">haddock v3</a>: The  <strong>H</strong>igh <strong>A</strong>mbiguity <strong>D</strong>riven biomolecular <strong>DOCK</strong>ing is our flagship software, it is an integrative platform for modelling biomolecular complexes. It is one of the most popular software for protein-protein and protein-ligand docking.</li>
<li><a href="https://github.com/haddocking/pdb-tools">pdb-tools</a>: A dependency-free cross-platform swiss army knife for PDB files.</li>
<li><a href="https://github.com/haddocking/prodigy">prodigy</a>: Predict the binding affinity of protein-protein complexes from structural data</li>
<li><a href="https://github.com/haddocking/arctic3d">arctic3d</a>: Automatic Retrieval and ClusTering of Interfaces in Complexes from 3D structural information</li>
<li><a href="https://github.com/haddocking/proABC-2">proabc-2</a>: Deep learning framework to predict antibody paratope residues</li>
<li><a href="https://github.com/haddocking/disvis">disvis</a>: Visualisation of conformational space restriction by distance restraints</li>
<li><a href="https://github.com/haddocking/DeepRank-GNN-esm">DeepRank-GNN-ESM</a>: Deep learning framework for scroing protein-protein interaction docking poses.</li>
</ul>
<h3 id="useful-utilities"><a class="header" href="#useful-utilities">Useful utilities</a></h3>
<ul>
<li><a href="https://github.com/haddocking/haddock-restraints">haddock-restraints</a>: Generate restraints to be used in HADDOCK</li>
<li><a href="https://github.com/haddocking/haddock-runner">haddock-runner</a>: Run large scale HADDOCK simulations using multiple input molecules in different scenarios</li>
<li><a href="https://github.com/haddocking/haddock-tools">haddock-tools</a>: Set of useful utility scripts developed by the BonvinLab group members</li>
<li><a href="https://github.com/haddocking/haddock-mmcif">haddock-mmcif</a>: Encode information from a HADDOCK run to a cif file to be deposited in PDB-Dev</li>
</ul>
<h2 id="webservers"><a class="header" href="#webservers">Webservers</a></h2>
<p>We also provide online resources to perform computation related to the tools we developed.</p>
<p>Access our web-portal here: <a href="https://wenmr.science.uu.nl/">https://wenmr.science.uu.nl/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="online-lectures"><a class="header" href="#online-lectures">Online lectures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-cite-haddock3"><a class="header" href="#how-to-cite-haddock3">How to cite haddock3</a></h1>
<h2 id="citing-haddock3"><a class="header" href="#citing-haddock3">Citing haddock3</a></h2>
<p>Here is the list of research articles related to haddock3:</p>
<ul>
<li><strong>Description of haddock3</strong>: (soon!)</li>
<li><strong>Haddock3 web-application</strong>: (soon!)</li>
<li><strong>Benchmarks</strong>: (soon!)</li>
</ul>
<h2 id="citing-haddock3-source-code"><a class="header" href="#citing-haddock3-source-code">Citing haddock3 source-code</a></h2>
<p>The haddock3 source-code can be cited, as the GitHub repository contains a CITATION.cff file.
For this, go to <a href="https://github.com/haddocking/haddock3">https://github.com/haddocking/haddock3</a> and click on the <code>Cite this repository</code> on the right (see image).</p>
<figure align="center">
  <img src="cite_haddock3_github_repo.png">
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-cite-haddock3-1"><a class="header" href="#how-to-cite-haddock3-1">How to cite haddock3</a></h1>
<h2 id="citing-haddock3-1"><a class="header" href="#citing-haddock3-1">Citing haddock3</a></h2>
<p>Here is the list of research articles related to haddock3:</p>
<ul>
<li><strong>Description of haddock3</strong>: (soon!)</li>
<li><strong>Haddock3 web-application</strong>: (soon!)</li>
<li><strong>Benchmarks</strong>: (soon!)</li>
</ul>
<h2 id="citing-haddock3-source-code-1"><a class="header" href="#citing-haddock3-source-code-1">Citing haddock3 source-code</a></h2>
<p>The haddock3 source-code can be cited, as the GitHub repository contains a CITATION.cff file.
For this, go to <a href="https://github.com/haddocking/haddock3">https://github.com/haddocking/haddock3</a> and click on the <code>Cite this repository</code> on the right (see image).</p>
<figure align="center">
  <img src="cite_haddock3_github_repo.png">
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publications-related-to-haddock"><a class="header" href="#publications-related-to-haddock">Publications related to HADDOCK</a></h1>
<p>Here is shorten list of important publications describing HADDOCK related work:</p>
<ul>
<li><strong>First publication</strong>: C. Dominguez, R. Boelens and A.M.J.J. Bonvin. <a href="https://pubs.acs.org/doi/abs/10.1021/ja026939x">HADDOCK: A protein-protein docking approach based on biochemical or biophysical information.</a> <em>J. Am. Chem. Soc.</em>, 125, 1731-1737 (2003).</li>
<li><strong>HADDOCK webserver</strong>: S.J. de Vries, M. van Dijk and A.M.J.J. Bonvin <a href="https://www.nature.com/nprot/journal/v5/n5/abs/nprot.2010.32.html">The HADDOCK web server for data-driven biomolecular docking.</a> <em>Nature Protocols</em>, 5, 883-897 (2010).</li>
<li><strong>HADDOCK2.2 webserver</strong>: G.C.P van Zundert, J.P.G.L.M. Rodrigues, M. Trellet, C. Schmitz, P.L. Kastritis, E. Karaca, A.S.J. Melquiond, M. van Dijk, S.J. de Vries and A.M.J.J. Bonvin. <a href="https://doi.org/doi:10.1016/j.jmb.2015.09.014">The HADDOCK2.2 webserver: User-friendly integrative modeling of biomolecular complexes.</a> <em>J. Mol. Biol.</em>, 428, 720-725 (2016).</li>
<li><strong>HADDOCK2.4 webserver</strong>: R.V. Honorato, M.E. Trellet, B. Jiménez-García1, J.J. Schaarschmidt, M. Giulini, V. Reys, P.I. Koukos, J.P.G.L.M. Rodrigues, E. Karaca, G.C.P. van Zundert, J. Roel-Touris, C.W. van Noort, Z. Jandová, A.S.J. Melquiond and A.M.J.J. Bonvin. <a href="https://www.nature.com/articles/s41596-024-01011-0.epdf?sharing_token=UHDrW9bNh3BqijxD2u9Xd9RgN0jAjWel9jnR3ZoTv0O8Cyf_B_3QikVaNIBRHxp9xyFsQ7dSV3t-kBtpCaFZWPfnuUnAtvRG_vkef9o4oWuhrOLGbBXJVlaaA9ALOULn6NjxbiqC2VkmpD2ZR_r-o0sgRZoHVz10JqIYOeus_nM%3D">The HADDOCK2.4 web server: A leap forward in integrative modelling of biomolecular complexes.</a> <em>Nature Prot.</em>, Advanced Online Publication DOI: 10.1038/s41596-024-01011-0 (2024).</li>
<li><strong>How to generate restraints for HADDOCK</strong>: A.M.J.J. Bonvin, E. Karaca, P.L. Kastritis &amp; J.P.G.L.M. Rodrigues. Correspondence: <a href="https://doi.org/10.1038/s41596-018-0017-6">Defining distance restraints in HADDOCK</a>. <em>Nature Protocols</em> <em>13</em>, 1503 (2018). <a href="https://rdcu.be/1OyH">Free online only access</a></li>
</ul>
<p>For the complete list, please refere to our online <a href="https://www.bonvinlab.org/publications/">BonvinLab resource.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<h2 id="fundings"><a class="header" href="#fundings">Fundings</a></h2>
<p>The development of Haddock3 is made possible thanks to the financial support from Horizon 2020, projects <a href="https://www.bioexcel.eu">BioExcel</a> <a href="https://cordis.europa.eu/project/id/823830">823830</a> and <a href="https://cordis.europa.eu/project/id/101093290">101093290</a>, EGI-ACE <a href="https://cordis.europa.eu/project/id/101017567">101017567</a>, and from the Netherlands e-Science Center (027.020.G13), that provided and still provides substancial fundings for software development.
This allows the HADDOCK team to ensure software quality, imporvements, maintenance and user supports.</p>
<h2 id="user-driven-developments"><a class="header" href="#user-driven-developments">User driven developments</a></h2>
<p>In Haddock3, not only we try to provide a powerfull docking tool that can handle a variety of biomolecular entities, but we are also develloping new modules and functionalities based on user requests.
On a yearly basis, we ask users to fill a survey, allowing us to focus on several different directions to improve the tool and make it more suitable for the community.
Feature requests can also be performed directly from our <a href="https://github.com/haddocking/haddock3/issues/new/choose">GitHub repository issues</a>.</p>
<h2 id="20-years-of-haddock"><a class="header" href="#20-years-of-haddock">20 years of HADDOCK</a></h2>
<p>Haddock3 is the newest version of HADDOCK, an original idea initially developped by <a href="https://pubs.acs.org/doi/10.1021/ja026939x">Dominguez, C., Boelens, R. &amp; Bonvin, A. M. J. J. in 2003</a>.
Since more than 20 years now, HADDOCK has been improved, going from its first description to several milestones, namely Haddock2.2, Haddock2.4 and now Haddock3.</p>
<p>In november 2023, we celebrated the 20 years anniversary of HADDOCK, where most of the incredible scientists that contributed to its developement attended.</p>
<figure style="text-align: center;">
<img width="75%" src="20yearshaddock.png" alt="photo 20 years haddock3">
</figure>
<p>We wish to thank all the students, PhD candidates, PostDoctoral researchers for each of their contribution to the tool, as it allowed to continuously develop new methods and improve HADDOCK functionalities over the years.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
